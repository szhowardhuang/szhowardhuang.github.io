<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szhowardhuang.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="嵌入式老兵博客">
<meta property="og:url" content="https://szhowardhuang.github.io/index.html">
<meta property="og:site_name" content="嵌入式老兵博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Howard Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://szhowardhuang.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>嵌入式老兵博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">嵌入式老兵博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Howard Huang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/11/19/agenticmesh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/agenticmesh/" class="post-title-link" itemprop="url">自主网格：GPT驱动的自主代理生态系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-11-19 14:59:16 / 修改时间：14:58:43" itemprop="dateCreated datePublished" datetime="2024-11-19T14:59:16+08:00">2024-11-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/../assets_agenticmesh/net-img-1xfMpmYK1b2_Czg7cT4F5Og-20241112165906-5zs74jv.png"></p>
<p> </p>
<p>Agentic 代理的：&#x2F;əˈd͡ʒɛn.tɪk&#x2F;，能够独立做出决策以追求目标。来源：维基词典</p>
<p>Agentic AI 自主智能体人工智能：使用复杂的推理和迭代规划自主解决复杂的多步骤问题。来源：英伟达</p>
<p>Autonomous Agents 自主代理使用代理人工智能完成任务。</p>
<p>Agentic Mesh 自主网格：一个互联生态系统，使自主代理能够轻松找到彼此，协作、互动和交易。</p>
<ul>
<li>彭博社，2024 年 10 月 21 日：微软推出人工智能代理，深化与 Salesforce 的竞争；“总部位于华盛顿州雷德蒙德的软件制造商周一表示，将推出 10 个“自主代理”，以代表人们完成销售、客户支持和会计等领域的任务”</li>
<li>彭博社，2024 年 10 月 24 日：人工智能代理已正式进入职场，缺陷也在其中；“企业正在接受不需要吃饭且可以全天候工作的人工智能代理”</li>
<li>亚马逊支持的 Anthropic 推出可以执行复杂任务的人工智能代理，竞速 OpenAI、微软和谷歌。</li>
<li>销售云，2024 年 9 月 12 日：销售云推出 Agentforce — 人工智能的本质。</li>
</ul>
<p>数十亿美元的投资正流入一些全球最大的公司，用于开发便于构建自主智能体的工具。如果这笔巨额投资和最近的头条新闻有任何迹象的话，我们很快将会有很多自主智能体在动态生态系统中协作。</p>
<p>那么问题就不是“如何构建自主代理”而是，我们如何管理这个不断增长的自主代理生态系统？如何找到一个执行我们想要的任务的自主代理？如何与自主代理进行交互？如果我们想与自主代理进行交易，这如何实现？而且如何安全地实现？</p>
<p>自主网格就是在这里发挥作用。它是一个生态系统，使自主代理能够安全地找到彼此，协作、互动和交易。</p>
<p>本文通过讨论代理网格的框架、组件及其带来的变革价值，使代理网格生动起来。本文将：</p>
<ul>
<li>定义代理网格为一个互联生态系统，在该系统中，联邦自治代理和人类共同发起和完成工作。</li>
<li>描述代理网格是如何工作的，以及自主代理如何在代理网格中找到其他自主代理以完成任务。</li>
<li>识别自主网络组件 — 例如市场、注册中心、信任建立机制和人工干预监督 — 说明自主代理如何在自主网络中透明和安全地发现、交易和协作。</li>
<li>提供一组共同特征，使自主代理能够轻松找到彼此，协作、互动并安全交易。</li>
<li>描述一个代理堆栈，使自主代理能够在代理网中安全且可信地互操作。</li>
</ul>
<h1 id="自主代理-—-生成式人工智能的新前沿"><a href="#自主代理-—-生成式人工智能的新前沿" class="headerlink" title="自主代理 — 生成式人工智能的新前沿"></a>自主代理 — 生成式人工智能的新前沿</h1><p>生成式人工智能建立在令人难以置信的技术基础之上。在其演变的早期阶段（下图 1），生成式人工智能基于机器学习算法，如决策树、随机森林和回归模型，这些算法提供了从结构化数据中进行模式识别和预测的初始能力。在此基础上，深度学习在 1980 年代开始初步发展，杰弗里·辛顿等人提出了反向传播等关键概念，以更有效地训练多层神经网络。然而，深度学习在 2012 年真正开始流行并提升能力，此前辛顿团队在 ImageNet 竞赛中通过卷积神经网络（CNN）实现了图像识别的突破。</p>
<p><img src="/../assets_agenticmesh/net-img-1M0xf2qdXEqiloBUFC2QiCg-20241112165907-p46mylo.png"></p>
<p>图 1，代理进化</p>
<p>变压器于 2017 年通过开创性论文“注意力机制是你所需要的一切”被引入，该论文提出了变压器架构作为传统序列模型的更高效、更强大的替代方案。随后，GPT（生成式预训练变压器）在变压器基础上构建，实现了自然语言理解和生成的出色性能。这为 2022 年 11 月 OpenAI 的 ChatGPT 的里程碑发布奠定了基础。ChatGPT 专门训练以通过自然对话与人互动。此次发布使人工智能在日常应用中的使用变得普及，推动了几乎所有行业的各种工具和平台的集成浪潮。ChatGPT（以及其他类似工具如 DALL-E）展示了这些模型的创造性和生产力，有效地定义了人工智能技术中的新类别“生成式人工智能”（生成式人工智能）。</p>
<p>今天，生成式人工智能工具有基本的交互式聊天机器人，这些机器人通过人们提供的指令（提示）进行引导。然而，尽管生成式人工智能带来了显著的价值，但这在很大程度上是一个手动且有时繁琐的过程。称聊天机器人为“代理”可能并不完全准确。</p>
<p>然而，生成式人工智能仍然是自主代理的超能力！代理使用生成式人工智能更全面地创建独立思考和行动的自主代理（以下简称代理）。这些代理始终可用，能够感知环境，识别机会，并且可以在获得许可的情况下无需人工干预进行操作。生成式人工智能的语言模型使代理能够使用自然语言进行对话，从而便于人类和其他代理进行互动。生成式人工智能还允许代理确定执行计划，以完成由人类或其他代理分配的任务。生成式人工智能还使代理更容易使用工具来完成任务。</p>
<p>随着生成式人工智能能力呈指数级增长——其成本也呈指数级下降——我们预见到一个庞大而多样化的生成式人工智能驱动的代理生态系统，这些代理不仅适合特定目的，而且具有与其范围和价值相称的广泛成本。我们预计会看到使用LLMs的代理，既有大规模的，也有小规模的，还有介于两者之间的；适合代理的最小LLMs位于低功耗边缘设备（手机、本地计算）上，而最大的则用于最复杂的任务；代理将成为专家——一些是行业特定的深度专家；代理可能专注于编排和执行规划，而其他代理则专注于专业任务执行，还有一些则专注于治理和合规。</p>
<p>然而，对所有代理的基本期望是它们是可信的、安全的、可靠的，并且按预期行事。今天，ChatGPT 的用户实际上是环中的人。然而，当代理独立处理操作任务时，我们需要让人们不仅容易理解代理的能力，还要理解它们的操作政策、实现结果的记录、使用它们的人的任何反馈，以及第三方审计和认证结果的可用性。</p>
<p>代理网格</p>
<h1 id="代理网格-—-代理生态系统的支柱"><a href="#代理网格-—-代理生态系统的支柱" class="headerlink" title="代理网格 — 代理生态系统的支柱"></a>代理网格 — 代理生态系统的支柱</h1><p>代理网格由多个组件组成，如下图 2 所示。市场作为用户发现和与代理互动的主要接口。通过市场，用户可以找到符合其特定需求的代理，发起和跟踪请求，并对代理的表现提供反馈。它还允许用户对代理的行为进行监督，确保任务按照预期和政策执行。</p>
<p><img src="/../assets_agenticmesh/net-img-1XMmz9_ivM13U1qO0DXv8Yg-20241112165907-uecenec.png"></p>
<p>图 2，代理网格生态系统</p>
<p>支持此交互的是注册表，它充当所有代理元数据的中央存储库。这包括代理的目的、所有者信息、策略、安全角色、能力、端点描述和生命周期状态等基本细节。通过维护这些元数据，注册表确保代理可以在系统中被准确描述、发现和管理，为代理操作提供结构化和安全的环境。</p>
<p>代理网格使用 DNS（域名系统）来定位代理。该服务将人类可读的名称，如“agent.company.com”，转换为 IP 地址或 URL，使得代理在被发现后可以轻松地从世界任何地方定位和连接。</p>
<h1 id="自主代理特征"><a href="#自主代理特征" class="headerlink" title="自主代理特征"></a>自主代理特征</h1><p>代理本身是“量子”或主要实体，具有代理网格，代表用户和其他代理执行任务。每个代理由生成式人工智能模型驱动，或更具体地说，是两种类型的语言模型：通常使用大型通用语言模型生成跨多个领域的逐步执行路径，确保任务高效规划和执行。每个代理还可以使用针对其专业能力定制的本地模型，从而在特定领域实现专家级性能。</p>
<p>为了有效和高效地操作代理网格，代理必须设计成一套一致的特征，以定义它们的行为、范围和责任。这些共同特征如下面的图 3 所示，为开发者、用户和拥有者提供了清晰度，促进了信任，并使得在代理网格中设计、管理和监控代理变得更加容易。</p>
<p><img src="/../assets_agenticmesh/net-img-1_SogEShUxfVU2hZBC-PLgA-20241112165908-do10dsn.png"></p>
<p>图 3，自治代理特征</p>
<p>每个代理必须有一个清晰、透明且公开的目的，以指导其行动和决策，确保其执行的每个任务都与其特定目标和期望一致。明确定义的目的使代理保持专注，并提供高层次的边界，以便实施政策（代理的可信属性的一部分）。代理的目的还防止其参与不相关或不合适的活动，并提供可衡量的结果以评估性能。代理的目的定义了其必须操作的边界，确保其行动保持相关性和目标导向。这个目的由一个注册中心提供，允许其他代理识别合适的协作代理。</p>
<p>所有权对于确保问责制至关重要。每个代理都需要一个负责监控其行为、监督绩效以及解决可能出现的任何问题或错误的所有者。所有权是治理建立的基础，允许权力和控制的委托与执行。显然，关于所有者的信息是确定代理可信度的关键代理。</p>
<p>代理必须通过一致、可预测的行为以及在其目的范围内表现出可信赖性。可信赖的代理通过可靠地履行其角色并遵循预期标准来激发用户、所有者和其他系统的信心。可信赖性还包括提供和发布（在注册表&#x2F;市场）遵循伦理指南和法律要求的合规证明。提供审计追踪和错误处理机制进一步增强了信任，确保代理在不可预见的情况下仍然保持可靠性。</p>
<p>为了使代理高效运作，它们必须在其目的和所有者设定的限制范围内拥有独立行动的自主权。自主权使代理能够在没有持续监督的情况下做出决策和采取行动，这对于可扩展性和实时操作至关重要。然而，通过定义明确的边界，代理可以适应并自由行动，同时保持与其目标和所有权规则的一致性。</p>
<p>代理可以被用户和其他代理发现。代理发现是根据特定标准在代理网络中定位代理的过程，通过代理的注册信息（目的、所有权、政策等）实现。</p>
<p>最后，代理是“智能的”。代理有一个“智能”的 LLM 来确定执行路径，但可能还有其他 LLMs （大或小，通用或特定用途，昂贵或便宜，非常“智能”或不智能）来有效地完成他们的任务。</p>
<p>这六个特征——目标明确、问责制、可信赖性、自主性、可发现性和智能——构成了可靠、负责任和有效的代理设计基础。然而，定义这些特征只是方程的一部分。现在让我们讨论代理交互的核心类型：注册、发现和任务执行。</p>
<h1 id="自主代理注册"><a href="#自主代理注册" class="headerlink" title="自主代理注册"></a>自主代理注册</h1><p>代理注册描述了代理如何配置其身份，向中央注册表和 DNS 注册，并获得可发现性的批准。它展示了在网络中使代理可访问的关键步骤，支持更新和状态管理。代理注册如下面的图 4 所示。</p>
<p><img src="/../assets_agenticmesh/net-img-1rGnBrMlTQdK1t7bPn6Y4aw-20241112165908-hfko60v.png"></p>
<p>图 4，自主代理注册</p>
<p>代理注册有几个步骤。代理注册的第一步是配置代理（步骤 1），这涉及通过定义代理的目的、能力、所有者信息、政策和安全要求来设置代理。此配置描述了代理的元数据，定义了它可以做什么、谁拥有它以及什么规则或限制管理它的行为。</p>
<p>一旦代理配置完成，下一步是注册代理（步骤 2），它将其元数据提交到中央注册表。注册表存储代理的关键细节，例如其能力、所有权、策略和 DNS 名称。通过注册这些信息，代理成为 Agentic Mesh 生态系统的一部分。</p>
<p>随后，代理注册到 DNS（步骤 3）。DNS 注册步骤将代理选择的 DNS 名称——例如“agent.enterprise.com”——与其 IP 地址关联，使代理可以通过名称访问。这与网络上的域名工作方式相同——实际上，目的是使代理与任何其他可通过互联网访问的属性一样。</p>
<p>最终阶段包括批准代理注册，其中可能需要“环中人”或指定第三方的批准来验证代理的注册。一旦获得批准，代理将发送状态和状态更新（步骤 5），将其状态更改为“活动”，使代理可以完全访问客户端查询和交互。</p>
<h1 id="自主智能体发现"><a href="#自主智能体发现" class="headerlink" title="自主智能体发现"></a>自主智能体发现</h1><p>代理发现是注册后代理可以通过注册表找到的过程（如下图 5 所示）。</p>
<p><img src="/../assets_agenticmesh/net-img-1le1FdZqzsF0h2quhD_XiLQ-20241112165909-x9wdfx8.png"></p>
<p>图 5，自主代理发现</p>
<p>代理发现有几个步骤。首先，一旦代理注册（步骤 1）并且代理已在 DNS 中注册（步骤 2），就可以被发现（步骤 3）。发现使其他代理或用户（通常通过市场接口）能够查询注册表以获取具有特定能力或属性的代理。注册表通过提供匹配代理的可用信息（元数据等）来响应这些查询。</p>
<p>步骤 4 是代理执行注册表提供的协作代理主机名的 DNS 查找。一旦解析，步骤 5 涉及代理或用户（通过市场）直接连接到协作代理以执行任务。</p>
<h1 id="自主代理执行"><a href="#自主代理执行" class="headerlink" title="自主代理执行"></a>自主代理执行</h1><p>代理执行是用户选择并使用代理执行特定任务的端到端过程。下图 6 显示了端到端代理执行过程中的步骤。</p>
<p><img src="/../assets_agenticmesh/net-img-1AmtdaituUMJL8JfSIgJj9w-20241112165909-6lmee4u.png"></p>
<p>图 6，自主代理执行</p>
<p>代理执行有几个步骤：当用户查看代理库存时，流程开始（步骤 1），并查看代理市场中可用代理的列表（市场提供代理功能和属性的集中视图，使用户能够在开始任何交互之前评估他们的选项）。</p>
<p>接下来，在用户找到合适的代理（步骤 2）。他们使用市场的搜索和过滤工具与注册中心互动。通过注册中心，用户可以搜索符合特定要求的代理（例如能力或行业重点，从而帮助他们找到最适合其任务的代理）。</p>
<p>一旦用户选择了代理，用户（通过市场）开始与所选代理进行交互以完成指定任务。</p>
<p>在与代理交互后，代理识别执行计划（步骤 4），通过向大型语言模型（LLM）提交请求（带上下文的提示）来创建请求任务的执行计划。根据该计划，代理可能需要通过从注册表中选择符合所需目的、能力、所有权、政策和安全要求的合适代理来参与其他协作者（步骤 5）。最后，在管理交互（步骤 6）中，代理与用户沟通结果和任何交互，以获取完成任务的额外指导。</p>
<h1 id="代理网格体验平面"><a href="#代理网格体验平面" class="headerlink" title="代理网格体验平面"></a>代理网格体验平面</h1><p>代理网格有三个“体验”层，如下图 7 所示：</p>
<ul>
<li>用户体验层：关注用户如何与自主网格互动。</li>
<li>代理体验平面：处理代理在代理网格中如何与其他代理互动。</li>
<li>操作员体验层：专注于运行代理的操作方面。</li>
</ul>
<p><img src="/../assets_agenticmesh/net-img-1uvzU3OE2Lf4Hzf41GZ6jyg-20241112165910-pqrwqu5.png"></p>
<p>图 7，代理网格体验平面</p>
<p><strong>代理网格：用户体验</strong></p>
<p>用户体验层关注用户（个人、企业或管理员）如何与自主网格互动，针对三个特定用户群体：消费者、创作者和治理专业人士。</p>
<p>代理商“市场”是代理商的“应用商店”。市场的主要目的是方便消费者与代理商互动。市场的核心是视口或交互层，为用户提供无缝访问代理商及其能力的途径。其主要受众是消费（向）代理商发起请求的用户。它允许用户根据特定需求搜索代理商，查看代理商认证，查看代理商绩效指标，发起和跟踪请求，向代理商提供指导和反馈，当然，还可以查看有关代理商使用的账单信息。</p>
<p>用户体验还通过“创作者工作台”满足代理创建者。工作台允许创建者发布代理并在市场中提供，查看他们创建的代理的操作指标，包括例如使用情况和计费信息。</p>
<p>政策工作台也可用，允许治理专业人员定义管理代理操作和交互的政策，定义认证代理的标准（即他们遵循政策），并定义第三方组以提供和发布代理的独立审计。</p>
<p><strong>代理网格：代理体验</strong></p>
<p>代理体验层定义了代理之间如何相互作用、协作和自主执行任务。代理体验主要基于通过 API 和代理注册表的交互。</p>
<p>每个代理实现了一组简单的标准原语：</p>
<ul>
<li>可发现性，使代理能够发布并提供其目的、所有者和能力（以及任何其他相关元数据）。</li>
<li>可观测性，使代理能够发布有关其性能或操作能力的指标。</li>
<li>任务执行，指示代理执行任务。</li>
<li>控制功能，让用户（或其他代理）监控、修改，并在需要时终止请求。</li>
</ul>
<p>注册表作为该平面的视口或交互层，充当代理查询、发现和参与其他代理以完成复杂工作流的中心。注册表为代理提供元数据和能力描述的访问，帮助他们动态识别合适的协作伙伴。</p>
<p>在这个层面上运行的代理通过 API 等协议进行通信，使它们能够在生态系统中无缝交换数据。虽然注册表提供有关代理的信息，但一旦代理获得所需的信息，它们可以在很大程度上自行协作。</p>
<p><strong>自主网格：操作员体验</strong></p>
<p>操作员体验层确保支持自主网格的技术基础设施保持弹性、安全和可靠。它专注于运行代理的操作方面，包括系统性能、技术支持和故障排除。</p>
<p>基础设施工具（及其控制台）作为该层的视口或交互层，为操作员提供监控和管理环境所需的可见性和控制。通过该控制台，操作员可以监督代理部署，解决技术问题，并维护系统稳定性，确保代理继续最佳运行。</p>
<h1 id="自主代理堆栈"><a href="#自主代理堆栈" class="headerlink" title="自主代理堆栈"></a>自主代理堆栈</h1><p>图 8（下方）所示的自主代理堆栈概述了在代理网格中构建和操作代理所需的核心组件。</p>
<p><img src="/../assets_agenticmesh/net-img-1lJKoLOdlmYPnyCrs6qJ1cg-20241112165910-6h19b5h.png"></p>
<p>图 8，自主代理堆栈</p>
<p>堆栈中有几个组件：</p>
<ul>
<li>通信和 API：这允许代理使用 API（嵌入自然语言&#x2F;提示）与其他代理、系统或用户进行交互；基本服务解决“发现”、“可观察性”和“交互性”，通过使用“工具”、API 和系统功能来实现。</li>
<li>控制与管理：该能力收集并处理来自其他代理、环境或其他数据源的信息；传感器使代理能够感知和理解其环境，执行器使代理能够与其环境互动；控制服务促进代理管理。</li>
<li>学习与决策：这使得智能体能够通过从数据或经验中学习来提高性能；大型语言模型（LLM）帮助智能体确定执行计划并执行这些计划。此外，智能体存储它所学习的关于其工作环境、执行的任务以及与领域相关的政策、预定义规则或事实的信息。</li>
<li>运行时环境：这是代理运行的技术环境。运行时环境确保代理能够在其指定角色中安全、一致和可靠地运行，无论是在物理环境还是虚拟系统中。它提供基础设施，包括执行代理过程所需的工具和资源。</li>
<li>编排和专业化LLMs：代理可以访问编排LLMs（那些擅长任务规划的代理，今天可能包括大多数流行的LLMs），以及经过培训和微调的专业化LLMs，这些代理在特定行业、领域或主题上具有专业知识。代理使用编排LLMs来规划执行路径以完成请求的任务，并可能调用具有专业化LLMs的代理来完成单个任务。</li>
</ul>
<h1 id="自主代理接口"><a href="#自主代理接口" class="headerlink" title="自主代理接口"></a>自主代理接口</h1><p>有三种关键类别的接口用于与代理进行交互：发现接口、可观察性接口和交互接口。每个类别都有特定的 API 端点，用于管理和与代理交互，如下图 9 所示。</p>
<p><img src="/../assets_agenticmesh/net-img-1-YHRoEKCNKP3wgPK0NDRfQ-20241112165911-u5vybbl.png"></p>
<p>图 9，自主代理接口</p>
<p>发现接口允许代理（以及通过市场的用户）检索有关代理的关键信息。端点包括：</p>
<ul>
<li>GET &#x2F;metadata: 获取代理的元数据，包括其目的、能力描述、政策和其他相关信息。这一接口对于用户或系统理解代理可以做什么以及如何与其交互是基础。</li>
</ul>
<p>可观察性接口旨在监控和检索有关代理的操作数据。端点包括：</p>
<ul>
<li>获取 &#x2F;使用情况：提供有关代理使用情况的数据，可能包括任务频率或资源消耗的统计信息。</li>
<li>获取 &#x2F;alerts：获取由代理生成的警报和异常，用于识别和排除操作问题。</li>
<li>获取 &#x2F;logs：访问代理的日志，这是其活动的详细记录，有助于审计和理解其随时间的行为。</li>
</ul>
<p>交互接口专注于任务执行和用户与代理之间的交互控制。端点包括：</p>
<ul>
<li>POST &#x2F;execute: 允许用户或其他代理请求代理执行特定任务。这是与代理交互的主要端点。</li>
<li>POST &#x2F;subscribe：允许用户订阅与代理的当前或未来交互，包括有关代理活动的更新或通知。</li>
<li>获取 &#x2F;交互：返回涉及该代理的当前或过去交互的列表，以便为用户提供代理参与情况的洞察。</li>
<li>POST &#x2F;operations：提供一个控制机制，用于管理代理的操作，以便对其任务和流程进行调整或直接控制。</li>
</ul>
<p>注意，这些端点经过简化以便于理解。在实际应用中，还需要考虑 REST 参数约定和安全性等额外因素，以确保稳健和安全的交互。</p>
<h1 id="代理网格注册表栈"><a href="#代理网格注册表栈" class="headerlink" title="代理网格注册表栈"></a>代理网格注册表栈</h1><p>注册表栈示例了用于管理和与代理交互的组件，包括通信&#x2F;API、控制服务、元数据管理和运行时环境，如下图 10 所示。</p>
<p><img src="/../assets_agenticmesh/net-img-1R3cHnbR04bJRqP7l9T3o9w-20241112165911-u9xc3f5.png"></p>
<p>图 10，代理网格注册表栈</p>
<p>通信接口侧重于注册表如何通过明确定义的 API 与其他代理、系统或用户交互。它包括三个主要接口：</p>
<ul>
<li>发现&#x2F;注册：注册新代理并让用户和代理找到代理。</li>
<li>可观察性：提供监控代理性能的服务，并检索操作数据，如使用情况、警报和日志。</li>
<li>交互性：促进任务执行，使用户或其他代理能够启动、控制和管理代理执行的任务。</li>
</ul>
<p>控制服务提供代理活动的集中管理：</p>
<ul>
<li>代理管理：处理代理的配置和监督，确保它们按照定义的角色和政策运行。</li>
<li>交互管理：管理用户与代理之间的交互，确保顺畅的沟通和任务执行。</li>
</ul>
<p>注册表以安全和弹性的方式管理与代理相关的所有元数据，并负责：</p>
<ul>
<li>数据管理：确保可靠存储和检索与代理相关的元数据，包括它们的目的、能力和操作政策。</li>
<li>安全管理：处理代理数据的安全方面，确保敏感信息受到保护，交互符合安全协议。</li>
</ul>
<p>运行时环境提供了注册表操作的上下文。</p>
<h1 id="自主网格注册接口"><a href="#自主网格注册接口" class="headerlink" title="自主网格注册接口"></a>自主网格注册接口</h1><p>注册表接口管理与代理相关的操作。这些接口分为发现&#x2F;注册、可观察性和交互接口，如下图 11 所示。</p>
<p><img src="/../assets_agenticmesh/net-img-1fraw8Yo2X_P_mSSvvLV8Cg-20241112165911-nv6wdcf.png"></p>
<p>图 11，代理网格注册接口</p>
<p>发现&#x2F;注册接口促进代理注册，并允许它们在注册表中被发现。接口包括：</p>
<ul>
<li>POST &#x2F;registrations: 允许代理在注册中心注册，使其可以通过市场进行发现和交互。</li>
<li>GET &#x2F;registrations：检索有关注册代理的状态信息，提供它们在系统中的当前状态的详细信息。</li>
<li>GET &#x2F;metadata: 获取所有注册代理的元数据，包括它们的目的、能力和策略等详细信息，使用户能够理解和评估代理的功能。</li>
</ul>
<p>可观察性接口提供有关注册表自身的操作指标和性能的洞察：</p>
<ul>
<li>GET &#x2F;usage：返回有关注册表如何被利用的数据，例如它促进的交互的频率和类型。</li>
<li>GET &#x2F;alerts：检索与注册表操作相关的警报和异常，这对于识别和解决可能出现的任何问题至关重要。</li>
<li>GET &#x2F;logs：访问注册表的日志，提供事件和活动的详细记录，可用于审计、故障排除和监控目的。</li>
</ul>
<p>交互接口旨在促进用户（或其他代理）与注册表之间的直接交互，以执行和管理任务：</p>
<ul>
<li>POST &#x2F;execute: 允许用户或其他代理通过注册表请求任务执行，基于目标代理的能力启动操作。</li>
<li>POST &#x2F;subscribe：启用对特定代理的交互订阅，确保用户或系统接收有关正在进行或未来活动的更新或通知。</li>
<li>GET &#x2F;interactions：检索涉及代理的交互列表，提供对过去或当前参与的透明度和洞察。</li>
<li>POST &#x2F;operations：提供对注册表操作的控制，允许授权用户或系统根据需要管理和调整其功能。</li>
</ul>
<p>再次注意，这些接口端点是为了概念理解而示例化和简化的。在实际生产环境中，将实施标准的 REST 参数和安全措施，以确保稳健和安全的操作。</p>
<h1 id="信任代理网络：核心价值主张"><a href="#信任代理网络：核心价值主张" class="headerlink" title="信任代理网络：核心价值主张"></a>信任代理网络：核心价值主张</h1><p>信任是代理网中的一个关键价值主张，使用户和代理能够无缝有效地协作。为了让用户能够自信地将任务委托给代理，他们必须信任代理能够准确可靠地完成工作。当然，代理之间也需要相互信任以执行任务。代理网中的信任建立在几个关键支柱之上：</p>
<ul>
<li>反馈机制：用户和代理可以对性能提供反馈（例如，“点赞”），帮助其他人识别网络中的可靠代理。</li>
<li>履行期望的记录：代理通过持续满足或超越绩效期望来建立信任，形成可靠性历史。这些记录会被发布，并成为代理历史记录的一部分，供人们和其他代理查看。</li>
<li>透明认证方案：一种认证机制确保代理满足预定义标准，使用户和代理对其能力充满信心。</li>
<li>第三方认证：允许独立第三方审核代理活动，并根据其目的和政策进行评估。代理可以被“认证”，以表明其以可信的方式按预期行事，认证状态会发布（到市场和注册中心），以便人们和代理都能了解代理的能力和可信度。</li>
<li>信任指标发布：信任指标对市场中的用户和所有代理都可用，通过注册表确保整个生态系统的透明度。代理网捕获、维护和发布信任指标，使其对人类和代理都可访问。</li>
</ul>
<p>将信任纳入代理网格确保人类用户和自主代理可以相互依赖，创建一个 cohesive、透明和有效的生态系统。</p>
<h1 id="前方的道路：新时代的工作与协作"><a href="#前方的道路：新时代的工作与协作" class="headerlink" title="前方的道路：新时代的工作与协作"></a>前方的道路：新时代的工作与协作</h1><p>自主网格生态系统解决了大型代理生态系统中的一个实际问题：它让代理能够相互发现、协作、互动和交易。随着代理变得更加高效、可靠和可信，企业很可能不可避免地依赖代理来自动化任务、动态响应变化并释放新的效率。</p>
<p>自主网格提供自主代理、人工干预监督和动态协作的组合，将重新定义商业模型和运营。无论您是创建代理的开发者、为未来制定战略的商业高管，还是寻求效率的用户，自主网格都为您提供了通往新工作和协作时代的路径。</p>
<p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/agentic-mesh-the-future-of-generative-ai-enabled-autonomous-agent-ecosystems-d6a11381c979">Agentic Mesh: The Future of Generative AI-Enabled Autonomous Agent Ecosystems | by Eric Broda | Nov, 2024 | Towards Data Science</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/10/08/finetuneembed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/08/finetuneembed/" class="post-title-link" itemprop="url">特定领域Embed模型的微调指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-08 11:36:55 / 修改时间：11:35:42" itemprop="dateCreated datePublished" datetime="2024-10-08T11:36:55+08:00">2024-10-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>想象一下你正在为医疗领域构建一个问答系统。你希望确保它能够准确检索相关的医疗文章，当用户提问时。但是通用嵌入模型可能难以处理高度专业化的词汇和医学术语的细微差别。</p>
<p><strong>这就是微调的用武之地！！</strong></p>
<p>在这篇博客中，我们将深入探讨针对特定领域（如医学、法律或金融）微调嵌入模型的过程。我们将生成一个专门针对您领域的数据集，并使用它来训练模型，以更好地理解您选择的领域中的细微语言模式和概念。</p>
<blockquote>
<p><em>到最后，您将拥有一个针对您的领域优化的更强大的嵌入模型，从而实现更准确的检索和改进的自然语言处理任务结果。</em></p>
</blockquote>
<h1 id="嵌入：理解概念"><a href="#嵌入：理解概念" class="headerlink" title="嵌入：理解概念"></a>嵌入：理解概念</h1><p><img src="/../asset_finetuneembed/net-img-0AjX-xfa4UvNVu9js-20241008112653-df9yses.jpg"></p>
<p>嵌入是文本或图像的强大数值表示，捕捉语义关系。想象一下，将文本或音频视为多维空间中的一个点，相似的单词或短语比不相似的更靠近。</p>
<p><img src="/../asset_finetuneembed/net-img-0SdkOLVaUARue8gWb-20241008112654-oguu9m1.png"></p>
<p>嵌入对于许多自然语言处理任务是必不可少的，例如：</p>
<p><img src="/../asset_finetuneembed/net-img-0MpKQ16XXAOxwyIJy-20241008112654-wsisckp.jpg"></p>
<ul>
<li>语义相似度：找出两段图像或文本的相似程度。</li>
<li>文本分类：根据数据的含义将其分组到类别中。</li>
<li>问答：找到最相关的文档以回答问题。</li>
<li>检索增强生成（RAG）：结合用于检索的嵌入模型和用于文本生成的语言模型，以提高生成文本的质量和相关性。</li>
</ul>
<h1 id="套娃式的表示学习"><a href="#套娃式的表示学习" class="headerlink" title="套娃式的表示学习"></a>套娃式的表示学习</h1><p><img src="/../asset_finetuneembed/net-img-06-f6qOEl0Pjwh9Rz-20241008112655-yq8a6jp.png"></p>
<p>Matryoshka 表示学习（MRL）是一种创建“可截断”嵌入向量的技术。想象一系列嵌套的娃娃，每个娃娃里面包含一个更小的娃娃。MRL 以一种方式嵌入文本，使得早期维度（如外层娃娃）包含最重要的信息，而后续维度添加细节。这使得在需要时只使用嵌入向量的一部分，从而减少存储和计算成本。</p>
<p><img src="/../asset_finetuneembed/net-img-1meSlEskxptTA_5rz10iNBw-20241008112656-103n9el.gif"></p>
<h1 id="Bge-base-en"><a href="#Bge-base-en" class="headerlink" title="Bge-base-en"></a>Bge-base-en</h1><p>BAAI&#x2F;bge-base-en-v1.5 模型，由北京人工智能研究院开发，是一个强大的文本嵌入模型。它在各种自然语言处理任务中表现出色，并且在 MTEB 和 C-MTEB 等基准测试中表现良好。 bge-base-en 模型是计算资源有限的应用程序（比如我的情况）的不错选择。</p>
<h1 id="为什么要微调嵌入模型？"><a href="#为什么要微调嵌入模型？" class="headerlink" title="为什么要微调嵌入模型？"></a>为什么要微调嵌入模型？</h1><p>针对特定领域微调嵌入模型对于优化 RAG 系统至关重要。这个过程确保模型对相似性的理解与您领域的特定上下文和语言细微差别相一致。经过微调的嵌入模型更能检索与问题最相关的文档，从而最终导致您的 RAG 系统提供更准确和相关的响应。</p>
<h1 id="数据集格式：构建微调的基础"><a href="#数据集格式：构建微调的基础" class="headerlink" title="数据集格式：构建微调的基础"></a>数据集格式：构建微调的基础</h1><p>您可以使用各种数据集格式进行微调。</p>
<p>这里是最常见的类型：</p>
<ul>
<li>正向对: 一对相关句子（例如，问题，答案）。</li>
<li>三元组：（锚点，正样本，负样本）三元组，其中锚点与正样本相似，与负样本不同。</li>
<li>相似度得分的句子对：一对句子及其表示关系的相似度得分。</li>
<li>带类的文本：带有相应类标签的文本。</li>
</ul>
<p>在这篇博客中，我们将创建一个问题和答案对的数据集，以微调我们的 bge-base-en-v1.5 模型。</p>
<h1 id="损失函数：指导训练过程"><a href="#损失函数：指导训练过程" class="headerlink" title="损失函数：指导训练过程"></a>损失函数：指导训练过程</h1><p>损失函数对于训练嵌入模型至关重要。它们衡量模型预测与实际标签之间的差异，为模型调整权重提供信号。</p>
<p>不同的损失函数适用于不同的数据集格式：</p>
<ul>
<li>三元组损失：与（锚点，正样本，负样本）三元组一起使用，鼓励模型将相似句子靠近，非相似句子远离。</li>
<li>对比损失：与正负样本对一起使用，鼓励相似句子靠近，不相似句子远离。</li>
<li>余弦相似度损失：与句子对和相似度评分一起使用，鼓励模型生成与提供的评分匹配的余弦相似度的嵌入。</li>
<li>套娃损失：一种专门设计的损失函数，用于创建可截断的套娃嵌入。</li>
</ul>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h2><p>我们首先安装必要的库。我们将使用 datasets 、 sentence-transformers 和 google-generativeai 来处理数据集、嵌入模型和文本生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get -qq install poppler-utils tesseract-ocr</span><br><span class="line">pip install datasets sentence-transformers google-generativeai</span><br><span class="line">pip install -q --user --upgrade pillow</span><br><span class="line">pip install -q unstructured[&quot;all-docs&quot;] pi_heif</span><br><span class="line">pip install -q --upgrade unstructured</span><br><span class="line">pip install --upgrade nltk</span><br></pre></td></tr></table></figure>

<p>我们还将安装 unstructured 用于 PDF 解析和 nltk 用于文本处理。</p>
<h2 id="PDF-解析和文本提取"><a href="#PDF-解析和文本提取" class="headerlink" title="PDF 解析和文本提取"></a>PDF 解析和文本提取</h2><p>我们将使用 unstructured 库从 PDF 文件中提取文本和表格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import nltk</span><br><span class="line">import os </span><br><span class="line">from unstructured.partition.pdf import partition_pdf</span><br><span class="line">from collections import Counter</span><br><span class="line">nltk.download(&#x27;punkt&#x27;)</span><br><span class="line">nltk.download(&#x27;averaged_perceptron_tagger&#x27;)</span><br><span class="line">nltk.download(&#x27;punkt_tab&#x27;) </span><br><span class="line"></span><br><span class="line">def process_pdfs_in_folder(folder_path):</span><br><span class="line">    total_text = []  # To accumulate the text from all PDFs</span><br><span class="line"></span><br><span class="line">    # Get list of all PDF files in the folder</span><br><span class="line">    pdf_files = [f for f in os.listdir(folder_path) if f.endswith(&#x27;.pdf&#x27;)]</span><br><span class="line"></span><br><span class="line">    for pdf_file in pdf_files:</span><br><span class="line">        pdf_path = os.path.join(folder_path, pdf_file)</span><br><span class="line">        print(f&quot;Processing: &#123;pdf_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        # Apply the partition logic</span><br><span class="line">        elements = partition_pdf(pdf_path, strategy=&quot;auto&quot;)</span><br><span class="line"></span><br><span class="line">        # Display the types of elements</span><br><span class="line">        display(Counter(type(element) for element in elements))</span><br><span class="line"></span><br><span class="line">        # Join the elements to form text and add it to total_text list</span><br><span class="line">        text = &quot;\n\n&quot;.join([str(el) for el in elements])</span><br><span class="line">        total_text.append(text)</span><br><span class="line"></span><br><span class="line">    # Return the total concatenated text</span><br><span class="line">    return &quot;\n\n&quot;.join(total_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">folder_path = &quot;data&quot;</span><br><span class="line">all_text = process_pdfs_in_folder(folder_path)</span><br></pre></td></tr></table></figure>

<p>我们遍历指定文件夹中的每个 PDF，并将内容分割为文本、表格和图形。</p>
<p>然后将文本元素组合成一个单一的文本表示。</p>
<h2 id="自定义文本分块"><a href="#自定义文本分块" class="headerlink" title="自定义文本分块"></a>自定义文本分块</h2><p>我们现在使用 nltk 将提取的文本分成可管理的块。这对于使文本更适合llm处理是必不可少的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import nltk</span><br><span class="line"></span><br><span class="line">nltk.download(&#x27;punkt&#x27;)</span><br><span class="line"></span><br><span class="line">def nltk_based_splitter(text: str, chunk_size: int, overlap: int) -&gt; list:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Splits the input text into chunks of a specified size, with optional overlap between chunks.</span><br><span class="line"></span><br><span class="line">    Parameters:</span><br><span class="line">    - text: The input text to be split.</span><br><span class="line">    - chunk_size: The maximum size of each chunk (in terms of characters).</span><br><span class="line">    - overlap: The number of overlapping characters between consecutive chunks.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    - A list of text chunks, with or without overlap.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    from nltk.tokenize import sent_tokenize</span><br><span class="line"></span><br><span class="line">    # Tokenize the input text into individual sentences</span><br><span class="line">    sentences = sent_tokenize(text)</span><br><span class="line"></span><br><span class="line">    chunks = []</span><br><span class="line">    current_chunk = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    for sentence in sentences:</span><br><span class="line">        # If the current chunk plus the next sentence doesn&#x27;t exceed the chunk size, add the sentence to the chunk</span><br><span class="line">        if len(current_chunk) + len(sentence) &lt;= chunk_size:</span><br><span class="line">            current_chunk += &quot; &quot; + sentence</span><br><span class="line">        else:</span><br><span class="line">            # Otherwise, add the current chunk to the list of chunks and start a new chunk with the current sentence</span><br><span class="line">            chunks.append(current_chunk.strip())  # Strip to remove leading spaces</span><br><span class="line">            current_chunk = sentence</span><br><span class="line"></span><br><span class="line">    # After the loop, if there is any leftover text in the current chunk, add it to the list of chunks</span><br><span class="line">    if current_chunk:</span><br><span class="line">        chunks.append(current_chunk.strip())</span><br><span class="line"></span><br><span class="line">    # Handle overlap if it&#x27;s specified (overlap &gt; 0)</span><br><span class="line">    if overlap &gt; 0:</span><br><span class="line">        overlapping_chunks = []</span><br><span class="line">        for i in range(len(chunks)):</span><br><span class="line">            if i &gt; 0:</span><br><span class="line">                # Calculate the start index for overlap from the previous chunk</span><br><span class="line">                start_overlap = max(0, len(chunks[i-1]) - overlap)</span><br><span class="line">                # Combine the overlapping portion of the previous chunk with the current chunk</span><br><span class="line">                chunk_with_overlap = chunks[i-1][start_overlap:] + &quot; &quot; + chunks[i]</span><br><span class="line">                # Append the combined chunk, making sure it&#x27;s not longer than chunk_size</span><br><span class="line">                overlapping_chunks.append(chunk_with_overlap[:chunk_size])</span><br><span class="line">            else:</span><br><span class="line">                # For the first chunk, there&#x27;s no previous chunk to overlap with</span><br><span class="line">                overlapping_chunks.append(chunks[i][:chunk_size])</span><br><span class="line"></span><br><span class="line">        return overlapping_chunks  # Return the list of chunks with overlap</span><br><span class="line"></span><br><span class="line">    # If overlap is 0, return the non-overlapping chunks</span><br><span class="line">    return chunks</span><br><span class="line"></span><br><span class="line">chunks = nltk_based_splitter(text=all_text, </span><br><span class="line">                                  chunk_size=2048,</span><br><span class="line">                                  overlap=0)</span><br></pre></td></tr></table></figure>

<h2 id="数据集生成器"><a href="#数据集生成器" class="headerlink" title="数据集生成器"></a>数据集生成器</h2><p>在本节中，我们定义两个函数：</p>
<p>prompt 函数为 Google Gemini 创建一个提示，请求基于提供的文本块的问题-答案对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import google.generativeai as genai</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># Replace with your valid Google API key</span><br><span class="line">GOOGLE_API_KEY = &quot;xxxxxxxxxxxx&quot;</span><br><span class="line"></span><br><span class="line"># Prompt generator with an explicit request for structured output</span><br><span class="line">def prompt(text_chunk):</span><br><span class="line">    return f&quot;&quot;&quot;</span><br><span class="line">    Based on the following text, generate one Question and its corresponding Answer.</span><br><span class="line">    Please format the output as follows:</span><br><span class="line">    Question: [Your question]</span><br><span class="line">    Answer: [Your answer]</span><br><span class="line"></span><br><span class="line">    Text: &#123;text_chunk&#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"># Function to interact with Google&#x27;s Gemini and return a QA pair</span><br><span class="line">def generate_with_gemini(text_chunk:str, temperature:float, model_name:str):</span><br><span class="line">    genai.configure(api_key=GOOGLE_API_KEY)</span><br><span class="line">    generation_config = &#123;&quot;temperature&quot;: temperature&#125;</span><br><span class="line"></span><br><span class="line">    # Initialize the generative model</span><br><span class="line">    gen_model = genai.GenerativeModel(model_name, generation_config=generation_config)</span><br><span class="line"></span><br><span class="line">    # Generate response based on the prompt</span><br><span class="line">    response = gen_model.generate_content(prompt(text_chunk))</span><br><span class="line"></span><br><span class="line">    # Extract question and answer from response using keyword</span><br><span class="line">    try:</span><br><span class="line">        question, answer = response.text.split(&quot;Answer:&quot;, 1)</span><br><span class="line">        question = question.replace(&quot;Question:&quot;, &quot;&quot;).strip()</span><br><span class="line">        answer = answer.strip()</span><br><span class="line">    except ValueError:</span><br><span class="line">        question, answer = &quot;N/A&quot;, &quot;N/A&quot;  # Handle unexpected format in response</span><br><span class="line"></span><br><span class="line">    return question, answer</span><br></pre></td></tr></table></figure>

<p>generate_with_gemini 函数与Gemini模型交互，并使用创建的提示生成问答对。</p>
<h2 id="运行问答生成"><a href="#运行问答生成" class="headerlink" title="运行问答生成"></a>运行问答生成</h2><p>使用 process_text_chunks 函数，我们使用Gemini模型为每个文本块生成问答对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def process_text_chunks(text_chunks:list, temperature:int, model_name=str):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Processes a list of text chunks to generate questions and answers using a specified model.</span><br><span class="line"></span><br><span class="line">    Parameters:</span><br><span class="line">    - text_chunks: A list of text chunks to process.</span><br><span class="line">    - temperature: The sampling temperature to control randomness in the generated outputs.</span><br><span class="line">    - model_name: The name of the model to use for generating questions and answers.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    - A Pandas DataFrame containing the text chunks, questions, and answers.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    results = []</span><br><span class="line"></span><br><span class="line">    # Iterate through each text chunk</span><br><span class="line">    for chunk in text_chunks:</span><br><span class="line">        question, answer = generate_with_gemini(chunk, temperature, model_name)</span><br><span class="line">        results.append(&#123;&quot;Text Chunk&quot;: chunk, &quot;Question&quot;: question, &quot;Answer&quot;: answer&#125;)</span><br><span class="line"></span><br><span class="line">    # Convert results into a Pandas DataFrame</span><br><span class="line">    df = pd.DataFrame(results)</span><br><span class="line">    return df</span><br><span class="line"># Process the text chunks and get the DataFrame</span><br><span class="line">df_results = process_text_chunks(text_chunks=chunks, </span><br><span class="line">                                 temperature=0.7, </span><br><span class="line">                                 model_name=&quot;gemini-1.5-flash&quot;)</span><br><span class="line">df_results.to_csv(&quot;generated_qa_pairs.csv&quot;, index=False)</span><br></pre></td></tr></table></figure>

<p>这些结果然后存储在一个 Pandas 数据框中。</p>
<h2 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h2><p>接下来，我们从 CSV 文件加载生成的问答对到 HuggingFace 数据集中。我们确保数据格式正确，以便进行微调。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from datasets import load_dataset</span><br><span class="line"></span><br><span class="line"># Load the CSV file into a Hugging Face Dataset</span><br><span class="line">dataset = load_dataset(&#x27;csv&#x27;, data_files=&#x27;generated_qa_pairs.csv&#x27;)</span><br><span class="line"></span><br><span class="line">def process_example(example, idx):</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;id&quot;: idx,  # Add unique ID based on the index</span><br><span class="line">        &quot;anchor&quot;: example[&quot;Question&quot;],</span><br><span class="line">        &quot;positive&quot;: example[&quot;Answer&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">dataset = dataset.map(process_example,</span><br><span class="line">                      with_indices=True , </span><br><span class="line">                      remove_columns=[&quot;Text Chunk&quot;, &quot;Question&quot;, &quot;Answer&quot;])</span><br></pre></td></tr></table></figure>

<h2 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h2><p>我们从 HuggingFace 加载 BAAI&#x2F;bge-base-en-v1.5 模型，确保选择适当的执行设备（CPU 或 GPU）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from sentence_transformers import SentenceTransformer</span><br><span class="line">from sentence_transformers.evaluation import (</span><br><span class="line">    InformationRetrievalEvaluator,</span><br><span class="line">    SequentialEvaluator,</span><br><span class="line">)</span><br><span class="line">from sentence_transformers.util import cos_sim</span><br><span class="line">from datasets import load_dataset, concatenate_datasets</span><br><span class="line">from sentence_transformers.losses import MatryoshkaLoss, MultipleNegativesRankingLoss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_id = &quot;BAAI/bge-base-en-v1.5&quot; </span><br><span class="line"></span><br><span class="line"># Load a model</span><br><span class="line">model = SentenceTransformer(</span><br><span class="line">    model_id, device=&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><p>在这里，我们配置Matryoshka 损失函数，指定用于截断嵌入的维度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Important: large to small</span><br><span class="line">matryoshka_dimensions = [768, 512, 256, 128, 64] </span><br><span class="line">inner_train_loss = MultipleNegativesRankingLoss(model)</span><br><span class="line">train_loss = MatryoshkaLoss(</span><br><span class="line">    model, inner_train_loss, matryoshka_dims=matryoshka_dimensions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>内部损失函数， MultipleNegativesRankingLoss ，帮助模型生成适合检索任务的嵌入。</p>
<h2 id="定义训练参数"><a href="#定义训练参数" class="headerlink" title="定义训练参数"></a>定义训练参数</h2><p>我们使用 SentenceTransformerTrainingArguments 来定义训练参数。这包括输出目录、训练轮数、批量大小、学习率和评估策略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from sentence_transformers import SentenceTransformerTrainingArguments</span><br><span class="line">from sentence_transformers.training_args import BatchSamplers</span><br><span class="line"></span><br><span class="line"># define training arguments</span><br><span class="line">args = SentenceTransformerTrainingArguments(</span><br><span class="line">    output_dir=&quot;bge-finetuned&quot;,                 # output directory and hugging face model ID</span><br><span class="line">    num_train_epochs=1,                         # number of epochs</span><br><span class="line">    per_device_train_batch_size=4,              # train batch size</span><br><span class="line">    gradient_accumulation_steps=16,             # for a global batch size of 512</span><br><span class="line">    per_device_eval_batch_size=16,              # evaluation batch size</span><br><span class="line">    warmup_ratio=0.1,                           # warmup ratio</span><br><span class="line">    learning_rate=2e-5,                         # learning rate, 2e-5 is a good value</span><br><span class="line">    lr_scheduler_type=&quot;cosine&quot;,                 # use constant learning rate scheduler</span><br><span class="line">    optim=&quot;adamw_torch_fused&quot;,                  # use fused adamw optimizer</span><br><span class="line">    tf32=True,                                  # use tf32 precision</span><br><span class="line">    bf16=True,                                  # use bf16 precision</span><br><span class="line">    batch_sampler=BatchSamplers.NO_DUPLICATES,  # MultipleNegativesRankingLoss benefits from no duplicate samples in a batch</span><br><span class="line">    eval_strategy=&quot;epoch&quot;,                      # evaluate after each epoch</span><br><span class="line">    save_strategy=&quot;epoch&quot;,                      # save after each epoch</span><br><span class="line">    logging_steps=10,                           # log every 10 steps</span><br><span class="line">    save_total_limit=3,                         # save only the last 3 models</span><br><span class="line">    load_best_model_at_end=True,                # load the best model when training ends</span><br><span class="line">    metric_for_best_model=&quot;eval_dim_128_cosine_ndcg@10&quot;,  # Optimizing for the best ndcg@10 score for the 128 dimension</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意：如果您在使用 Tesla T4 时遇到训练错误，请尝试注释掉 tf32&#x3D;True 和 bf16&#x3D;True 行以禁用 TF32 和 BF16 精度。</p>
<h2 id="创建评估器"><a href="#创建评估器" class="headerlink" title="创建评估器"></a>创建评估器</h2><p>我们创建一个评估器来衡量模型在训练过程中的性能。评估器使用 InformationRetrievalEvaluator 评估模型在Matryoshka  损失中每个维度的检索性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">corpus = dict(</span><br><span class="line">    zip(dataset[&#x27;train&#x27;][&#x27;id&#x27;], </span><br><span class="line">        dataset[&#x27;train&#x27;][&#x27;positive&#x27;])</span><br><span class="line">)  # Our corpus (cid =&gt; document)</span><br><span class="line"></span><br><span class="line">queries = dict(</span><br><span class="line">    zip(dataset[&#x27;train&#x27;][&#x27;id&#x27;], </span><br><span class="line">        dataset[&#x27;train&#x27;][&#x27;anchor&#x27;])</span><br><span class="line">)  # Our queries (qid =&gt; question)</span><br><span class="line"></span><br><span class="line"># Create a mapping of relevant document (1 in our case) for each query</span><br><span class="line">relevant_docs = &#123;&#125;  # Query ID to relevant documents (qid =&gt; set([relevant_cids])</span><br><span class="line">for q_id in queries:</span><br><span class="line">    relevant_docs[q_id] = [q_id]</span><br><span class="line"></span><br><span class="line">matryoshka_evaluators = []</span><br><span class="line"># Iterate over the different dimensions</span><br><span class="line">for dim in matryoshka_dimensions:</span><br><span class="line">    ir_evaluator = InformationRetrievalEvaluator(</span><br><span class="line">        queries=queries,</span><br><span class="line">        corpus=corpus,</span><br><span class="line">        relevant_docs=relevant_docs,</span><br><span class="line">        name=f&quot;dim_&#123;dim&#125;&quot;,</span><br><span class="line">        truncate_dim=dim,  # Truncate the embeddings to a certain dimension</span><br><span class="line">        score_functions=&#123;&quot;cosine&quot;: cos_sim&#125;,</span><br><span class="line">    )</span><br><span class="line">    matryoshka_evaluators.append(ir_evaluator)</span><br><span class="line"></span><br><span class="line"># Create a sequential evaluator</span><br><span class="line">evaluator = SequentialEvaluator(matryoshka_evaluators)</span><br></pre></td></tr></table></figure>

<h2 id="在微调之前评估模型"><a href="#在微调之前评估模型" class="headerlink" title="在微调之前评估模型"></a>在微调之前评估模型</h2><p>我们评估基础模型以获取微调前的基准性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">results = evaluator(model)</span><br><span class="line"></span><br><span class="line">for dim in matryoshka_dimensions:</span><br><span class="line">    key = f&quot;dim_&#123;dim&#125;_cosine_ndcg@10&quot;</span><br><span class="line">    print(f&quot;&#123;key&#125;: &#123;results[key]&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="定义训练器"><a href="#定义训练器" class="headerlink" title="定义训练器"></a>定义训练器</h2><p>我们创建一个 SentenceTransformerTrainer 对象，指定模型、训练参数、数据集、损失函数和评估器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sentence_transformers import SentenceTransformerTrainer</span><br><span class="line"></span><br><span class="line">trainer = SentenceTransformerTrainer(</span><br><span class="line">    model=model, # our embedding model</span><br><span class="line">    args=args,  # training arguments we defined above</span><br><span class="line">    train_dataset=dataset.select_columns(</span><br><span class="line">        [&quot;positive&quot;, &quot;anchor&quot;]</span><br><span class="line">    ),</span><br><span class="line">    loss=train_loss, # Matryoshka loss</span><br><span class="line">    evaluator=evaluator, # Sequential Evaluator</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="开始微调"><a href="#开始微调" class="headerlink" title="开始微调"></a>开始微调</h2><p>trainer.train() 方法开始微调过程，使用提供的数据和损失函数更新模型的权重。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># start training </span><br><span class="line">trainer.train()</span><br><span class="line"># save the best model</span><br><span class="line">trainer.save_model()</span><br></pre></td></tr></table></figure>

<p>训练完成后，我们将最佳性能模型保存到指定的输出目录。</p>
<h2 id="微调后的评估"><a href="#微调后的评估" class="headerlink" title="微调后的评估"></a>微调后的评估</h2><p>最后，我们加载微调后的模型，并使用相同的评估器进行评估，以衡量微调后性能的提升。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sentence_transformers import SentenceTransformer</span><br><span class="line"></span><br><span class="line">fine_tuned_model = SentenceTransformer(</span><br><span class="line">    args.output_dir, device=&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;</span><br><span class="line">)</span><br><span class="line"># Evaluate the model</span><br><span class="line">results = evaluator(fine_tuned_model)</span><br><span class="line"></span><br><span class="line"># Print the main score</span><br><span class="line">for dim in matryoshka_dimensions:</span><br><span class="line">    key = f&quot;dim_&#123;dim&#125;_cosine_ndcg@10&quot;</span><br><span class="line">    print(f&quot;&#123;key&#125;: &#123;results[key]&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>通过对您领域的嵌入模型进行微调，您为您的自然语言处理应用程序提供了对该领域特定语言和概念的更深入理解，这可以在问答、文档检索和文本生成等任务中带来显著改善。</p>
<p>本文讨论的技术，例如利用 mrl 和使用像 bge-base-en 这样的强大模型，为构建特定领域的嵌入模型提供了一条实用路径。虽然我们专注于微调的过程，但请记住，数据集的质量同样重要，仔细策划一个准确反映您领域细微差别的数据集对于实现最佳结果至关重要。</p>
<p><a target="_blank" rel="noopener" href="https://blog.gopenai.com/fine-tuning-embeddings-for-specific-domains-a-comprehensive-guide-5e4298b42185">Fine-tuning Embeddings for Specific Domains: A Comprehensive Guide | by kirouane Ayoub | Oct, 2024 | GoPenAI</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/26/GPUMemoryNeed4LLMs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/26/GPUMemoryNeed4LLMs/" class="post-title-link" itemprop="url">如何估算大模型推理占用的VRAM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-09-26 11:58:47 / 修改时间：12:02:15" itemprop="dateCreated datePublished" datetime="2024-09-26T11:58:47+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇论文：<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2309.06180">基于分页注意力的大型语言模型服务的高效内存管理</a>，提供了详细技术理解。</p>
<h1 id="LLM推理的-GPU-内存消耗"><a href="#LLM推理的-GPU-内存消耗" class="headerlink" title="LLM推理的 GPU 内存消耗"></a>LLM推理的 GPU 内存消耗</h1><p>在LLM推理过程中，主要的 GPU 内存消耗是权重（模型参数）、键值缓存、激活值和临时缓冲区及开销</p>
<h1 id="模型参数（权重）"><a href="#模型参数（权重）" class="headerlink" title="模型参数（权重）"></a>模型参数（权重）</h1><p>模型参数是神经网络在训练过程中学习到的数值（权重和偏置）。这些参数定义了模型如何处理输入数据以生成输出。</p>
<p><strong>模型大小对 GPU 内存的影响</strong></p>
<ul>
<li>直接关系：模型越大（参数越多），所需的 GPU 内存就越多来存储这些权重。</li>
<li>内存计算：每个参数通常在使用半精度（FP16）格式时需要 2 个字节，这在推理中很常见，节省内存而不显著损失精度。</li>
</ul>
<p><strong>让我们看看一些模型大小：</strong></p>
<ol>
<li><p>考虑一个小型LLM，具有 3.45 亿个参数：</p>
<p> 所需内存：3.45 亿 × 2 字节 &#x3D; 690 MB。这可以舒适地放在单个 GPU 上。</p>
</li>
<li><p>现在如果我们采用 llama2-13b 模型：</p>
<p> 参数量为 13B，所需内存为：13B × 2 字节 &#x3D; 26 GB。在这种情况下，我们需要一块具有 40 GB 内存的 A100 GPU。</p>
</li>
<li><p>如果我们看看 supposedly 的 GPT-3，175B参数模型：</p>
<p> 所需内存：175B × 2 字节 &#x3D; 350 GB</p>
</li>
</ol>
<p>我们至少需要 9 个 A100 GPU 来保存模型权重。</p>
<h1 id="键值-KV-缓存"><a href="#键值-KV-缓存" class="headerlink" title="键值(KV)缓存"></a>键值(KV)缓存</h1><p>KV 缓存存储生成序列中每个令牌所需的中间表示。简单来说，当模型一次生成一个令牌时，它需要记住之前的令牌以保持上下文。KV 缓存存储到目前为止生成的每个令牌的键和值向量，使模型能够关注过去的令牌，而无需重新计算它们。</p>
<p> <strong>工作原理</strong>：</p>
<ul>
<li>键和值：对于每个令牌，模型在注意力机制中计算一个键和一个值向量。</li>
<li>存储：这些向量存储在 KV 缓存中，并在后续步骤中用于生成新令牌。</li>
</ul>
<p><strong>序列长度和并发请求的影响：</strong></p>
<ul>
<li>更长的序列：更多的令牌意味着 KV 缓存中更多的条目，增加内存使用。</li>
<li>多个用户：同时处理多个请求会增加所需的 KV 缓存内存。</li>
</ul>
<p>如何计算每个令牌的 KV 缓存大小：</p>
<h2 id="每个令牌的总向量数："><a href="#每个令牌的总向量数：" class="headerlink" title="每个令牌的总向量数："></a>每个令牌的总向量数：</h2><blockquote>
<p>层数 (L)：模型深度    x    隐藏层大小 (H)：每个向量的维度。</p>
</blockquote>
<p>以 llama-13b 模型为参考，假设该模型具有：</p>
<ul>
<li>层数（L）：40 层</li>
<li>隐藏层大小（H）：5120 维</li>
</ul>
<h2 id="计算每个令牌的内存："><a href="#计算每个令牌的内存：" class="headerlink" title="计算每个令牌的内存："></a><strong>计算每个令牌的内存：</strong></h2><ol>
<li>键向量：</li>
</ol>
<ul>
<li>总元素：L 层 × H 维度 &#x3D; 40 × 5120 &#x3D; 204,800 个元素</li>
<li>内存大小：204,800 个元素 × 2 字节 (FP16) &#x3D; 409,600 字节 (或 400 KB)</li>
</ul>
<ol start="2">
<li>值向量：</li>
</ol>
<ul>
<li>与关键向量相同：也为 400 KB</li>
</ul>
<p><strong>每个令牌的总 KV 缓存：</strong></p>
<ul>
<li>键 + 值：400 KB + 400 KB &#x3D; 800 KB</li>
</ul>
<p><em><strong>现在考虑输出 2000 个令牌：</strong></em></p>
<blockquote>
<p>800 KB&#x2F;令牌 × 2000 令牌 &#x3D; 1.6 GB 每个序列<br>如果我们有 10 个并发请求（同时为 10 个用户提供模型服务）：<br>16 GB 的 KV 缓存内存</p>
</blockquote>
<p>KV 缓存随着序列长度和并发请求数量线性增长。从论文中了解到，KV 缓存在LLM服务期间可能消耗超过 30%的 GPU 内存。</p>
<h1 id="3-激活和临时缓冲区"><a href="#3-激活和临时缓冲区" class="headerlink" title="3. 激活和临时缓冲区"></a>3. 激活和临时缓冲区</h1><p>激活是推理过程中神经网络层的输出，临时缓冲区用于中间计算。激活和缓冲区通常消耗的内存少于模型权重和 KV 缓存。</p>
<blockquote>
<p><em><strong>它们可能使用大约 5%–10%的总 GPU 内存。</strong></em></p>
</blockquote>
<p>尽管它们的大小较小，但激活是模型在每一层计算输出所必需的。它们在前向传播过程中创建并丢弃，但仍然需要足够的内存分配。</p>
<h1 id="4-内存开销"><a href="#4-内存开销" class="headerlink" title="4. 内存开销"></a>4. 内存开销</h1><p>额外的内存使用是由于内存分配和使用效率低下造成的。以下是快速概述以便理解：</p>
<p><strong>碎片化：</strong></p>
<ul>
<li>内部碎片: 当分配的内存块未被完全利用时发生。</li>
<li>外部碎片化：随着时间的推移，空闲内存被分割成小块，导致在需要时很难分配较大的连续块。</li>
</ul>
<p><strong>中间计算：</strong></p>
<ul>
<li>临时数据：矩阵乘法等操作可能会创建消耗内存的临时张量。</li>
</ul>
<p><strong>低效内存管理的影响：</strong></p>
<ul>
<li>性能降低：浪费的内存可能限制系统可以处理的并发请求数量。</li>
<li>较低的吞吐量：低效可能导致延迟并降低响应用户的整体速度。</li>
</ul>
<p>示例：如果碎片化浪费了 40 GB GPU 上的 20%内存，那就是 8 GB的内存。</p>
<h1 id="计算-GPU-内存需求"><a href="#计算-GPU-内存需求" class="headerlink" title="计算 GPU 内存需求"></a>计算 GPU 内存需求</h1><p>现在我们已经对关键概念有了足够的理解，开始计算完整的 GPU 内存需求！</p>
<h2 id="逐步计算："><a href="#逐步计算：" class="headerlink" title="逐步计算："></a>逐步计算：</h2><p>计算任何模型的需求基本上需要以下内容：权重、KV 缓存、激活值、临时缓冲区和开销。参考 llama-2 13B 模型，公式为：</p>
<p>所需总内存：权重 + KV 缓存 + 激活和开销</p>
<h2 id="对于-13B-模型："><a href="#对于-13B-模型：" class="headerlink" title="对于 13B 模型："></a>对于 13B 模型：</h2><p><strong>权重</strong> &#x3D; 参数数量 × 每个参数的字节数<br><strong>总 KV 缓存内存</strong> &#x3D; 每个令牌的 KV 缓存内存 × 序列长度 × 序列数量<br><strong>激活和开销</strong> &#x3D; 5–10% 的总 GPU 内存</p>
<blockquote>
<p>激活和开销通常占用模型参数和 KV 缓存使用的总 GPU 内存的约 5-10%，用 10%来估算</p>
</blockquote>
<p><strong>假设一个 8192 Token 模型，支持 10 个并行请求</strong><strong>:</strong></p>
<p><strong>权重</strong> &#x3D; 130 亿 × 2 字节 &#x3D; 26 GB<br><strong>总 KV 缓存内存</strong> &#x3D; 800 KB × 8192 令牌 × 10 并发请求 &#x3D; 66 GB<br><strong>激活和开销</strong> &#x3D; 0.1 × (26 GB + 66 GB) &#x3D; 9.2 GB</p>
<p>所需总内存：26 GB + 66 GB + 9.2 GB &#x3D; 101.2 GB</p>
<p>所以，您至少需要 3 个 A100 40GB GPU 来运行 llama-2 13B 模型。</p>
<p><strong>假设一个 8192 Token 模型，支持 1个并行请求</strong><strong>:</strong></p>
<p><strong>权重</strong> &#x3D; 130 亿 × 2 字节 &#x3D; 26 GB<br><strong>总 KV 缓存内存</strong> &#x3D; 800 KB × 8192 令牌 × 1 并发请求 &#x3D; 6.6 GB<br><strong>激活和开销</strong> &#x3D; 0.1 × (26 GB + 6.6 GB) &#x3D; 3.26 GB</p>
<p>所需总内存：26 GB + 6.6 GB + 3.26 GB &#x3D; 29.86 GB</p>
<p>所以，您需要 1 个 A100 40GB GPU 来运行 llama-2 13B 模型。</p>
<p>基于公开可用的模型大小和参数信息，1个用户计算如下所示：</p>
<p><img src="/../assets_llmvram/image-20240926112552-jzkg9ms.png" alt="image.png"></p>
<p>10个用户计算如下所示：</p>
<p><img src="/../assets_llmvram/image-20240926112611-0xo99sm.png" alt="image.png"></p>
<p>在处理多个请求时，内存消耗显著增加。这里的一个主要消耗是 KV 缓存，因为模型权重和开销保持不变，随着令牌数量和并发请求的增加，KV 缓存会大幅增加，直接增加内存消耗。</p>
<h1 id="GPU-内存的优化方法"><a href="#GPU-内存的优化方法" class="headerlink" title="GPU 内存的优化方法"></a>GPU 内存的优化方法</h1><p>我们通常静态分配键值（KV）缓存的内存，为每个请求预留最大可能的空间。这导致了过度分配，因为系统为最长可能的序列保留空间，即使实际序列更短。动态管理的必要性就体现出来。</p>
<h2 id="分页注意力"><a href="#分页注意力" class="headerlink" title="分页注意力"></a>分页注意力</h2><p>分页注意力受到操作系统管理内存方式的启发，将虚拟内存分页的概念应用于 KV 缓存。这允许 KV 缓存数据存储在非连续的内存块（页面）中，而不需要一个大的连续块。分页注意力通过动态内存分配工作，即根据需要为 KV 缓存分配内存，而不预先分配最大序列长度。注意力机制可以无缝地从不同的内存位置检索 KV 缓存数据。</p>
<p>分页注意力的好处在于通过使用更小的内存块来减少碎片化，最小化由于碎片化造成的空间浪费，提高内存利用率。</p>
<h2 id="交换-KV-缓存到-CPU-内存"><a href="#交换-KV-缓存到-CPU-内存" class="headerlink" title="交换 KV 缓存到 CPU 内存"></a><strong>交换 KV 缓存到 CPU 内存</strong></h2><p>当 GPU 内存满时，暂时将 KV 缓存数据从 GPU 内存移动到 CPU 内存。同时释放 GPU 内存以处理新请求。</p>
<p>缺点：</p>
<ul>
<li>增加延迟增加：从 CPU 内存访问数据比从 GPU 内存慢。</li>
<li>数据传输开销：在 CPU 和 GPU 之间移动数据可能会消耗带宽和时间。</li>
</ul>
<h2 id="vLLM"><a href="#vLLM" class="headerlink" title="vLLM"></a>vLLM</h2><p>vLLM是基于分页注意力构建的高吞吐量LLM服务系统。其核心目的是在推理过程中高效管理 GPU 内存，特别是 KV 缓存。理论上，vLLM 是近零内存浪费的解决方案。通过动态分配和非连续存储，它几乎消除了内存浪费。在原则上，它还支持在请求内和请求之间共享 KV 缓存数据，特别适用于高级解码方法。基于这些，vLLM 可以处理更大的批量和更多的并发请求，从而增强整体性能。但是即使经过优化，仍可能出现 GPU 内存不足的情况。vLLM 通过交换KV 缓存到 CPU 内存来解决这个问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/20/aiassistedprogramming10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/aiassistedprogramming10/" class="post-title-link" itemprop="url">第10章  重点总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-20T11:48:32+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-21 09:22:18" itemprop="dateModified" datetime="2024-09-21T09:22:18+08:00">2024-09-21</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本章旨在为您简要概述我希望您从本书中获得的主要思想。</p>
<h1 id="学习曲线陡峭"><a href="#学习曲线陡峭" class="headerlink" title="学习曲线陡峭"></a>学习曲线陡峭</h1><p>人工智能辅助编程虽然是技术领域令人兴奋的前沿，但对于即使是最有经验的开发者来说，也存在显著的学习曲线。随着技术行业快速发展的步伐，这一挑战变得更加明显，创新不断，新发展层出不穷。跟上这些变化可能会让人感到不知所措，就像试图徒步追赶一列快速移动的高铁。</p>
<p>一个关键挑战在于适应与大型语言模型的细微差别，这些模型比传统编程方法复杂得多且不可预测。习惯于传统编码的开发人员期望一个线性过程，其中代码的行为是可预测的，并且按书写的方式精确执行。然而，对于人工智能模型来说，存在一种不可预测性和自主性的元素，这可能既令人困惑又令人兴奋。这些模型通常以人类程序员不立即直观的方式处理和响应编码请求。</p>
<p>这种转变要求开发者 adopt 新的思维方式。他们必须学会预测和解释人工智能模型的常常意外的输出，而这种与他们习惯的简单、逻辑的过程的偏离在开始时可能会让人感到不适。</p>
<h1 id="主要好处"><a href="#主要好处" class="headerlink" title="主要好处"></a>主要好处</h1><p>传统编码时，当遇到问题时，通常需要停止一切，去 Stack Overflow 上搜索或者翻阅大量文档或搜索谷歌。但人工智能辅助编程工具就像可以给你提供帮助的伙伴。这些工具在你输入时会弹出建议和修复，让你可以专注于编程，而不必在多个标签页或应用之间切换而迷失。你可以进入“流畅状态”并保持在那里。</p>
<p>一些工具足够智能，可以识别你的编码风格以及你为变量、函数和方法使用的名称。它们能够理解你代码的整体氛围。因此，当它们提出建议时，它们不仅仅是在给你一些随机的建议。它们的智慧是为你的项目量身定制的。</p>
<p>现在让我们谈谈真正的价值主张：让你摆脱无聊的事情。这些都是让你想打瞌睡的老一套例行任务——文件处理、数据处理、API 调用、UI 相关、正则表达式、启动代码，那些令人烦恼的 bash 命令，以及处理 GitHub Actions，仅举几例。编程中的人工智能就像是：“别担心，我来搞定，”然后为你生成代码。</p>
<p>而且这还不止于此。人工智能在理解你的代码方面也很厉害。首先，它可以自动记录所有内容。你不需要熬夜，试图写下笔记和解释，人工智能会用简单的英语整理好这一切。这一点非常重要，特别是在你将新成员引入项目或重新审视旧代码时。人工智能已经把所有内容整理好了。</p>
<h1 id="但也有缺点"><a href="#但也有缺点" class="headerlink" title="但也有缺点"></a>但也有缺点</h1><p>人工智能辅助编程也有一些棘手的问题。首先，关于人工智能工具生成的代码归属问题非常混乱。这些工具从各处学习大量代码，其中一些可能是受版权保护的。如果人工智能生成的内容与现有内容过于相似，这算不算侵犯他人权益？如果你在人工智能的帮助下制作了一些很棒的东西，谁来获利？整个法律问题很复杂，可能需要时间才能达成一些共识。</p>
<p>安全是另一个需要注意的事项。事实证明，有时这些人工智能工具生成的代码可能存在安全漏洞。由于我们无法真正了解LLM是如何构思其魔法的——这基本上是一个黑箱——因此很难确定你得到的是什么。这意味着你不能仅仅拿着代码就直接使用。相反，你必须经过测试和检查才能实际使用它。</p>
<p>然后是潜在的隐私问题。如果不加以管理，人工智能工具可能会无意中从私有代码库或专有数据中学习。此外，开发者输入到这些人工智能模型中的数据可能包含个人信息。</p>
<p>挑战在于确保人工智能编程助手的训练和使用尊重隐私和机密性。这意味着实施强有力的数据处理和隐私政策，并确保遵守 GDPR 等法规。</p>
<p>我们也不要忘记，有时人工智能辅助编程工具可能会出错。或者代码可能远非最佳，或者过于冗长。这是由于基础训练数据质量参差不齐等因素造成的。还有LLMs的不可预测性和复杂性。你永远不知道你会得到什么。</p>
<h1 id="提示工程是一门艺术和科学"><a href="#提示工程是一门艺术和科学" class="headerlink" title="提示工程是一门艺术和科学"></a>提示工程是一门艺术和科学</h1><p>学习提示工程远非易事。这是一门艺术，因为你需要有选择正确词语来引导人工智能的能力。这通常涉及到你如何提出问题或设置场景的创造力。</p>
<p>但提示工程也是一门科学。你需要深入了解人工智能模型是如何工作的。你试图在对人工智能如何响应你的提示的猜测中变得越来越精确。这就像是一名侦探，进行实验，检查发生了什么，并调整你的提示以获得你想要的答案。</p>
<p>幸运的是，有一些指导方针可以帮助。例如，提示的长度是关键。如果你的提示太长，人工智能可能会感到困惑或错过要点。你还需要具体。“提示需要清晰和集中，”资深软件工程师安基特·安克利亚说。“必须有足够的上下文。如果没有，你可能得不到想要的回应。”</p>
<h1 id="超越编程"><a href="#超越编程" class="headerlink" title="超越编程"></a>超越编程</h1><p>人工智能辅助编程工具不仅仅是编码。它们还有很多技巧。在本书中，我们看到它们就像是各种任务的瑞士军刀，从头脑风暴创意和项目规划到深入市场调研和记录项目所需内容。例如，想象一下快速编写高质量的产品需求文档和软件需求规格说明。人工智能可以帮助你完成这些任务，甚至做得更好。</p>
<p>当你准备推出产品时，猜猜怎么着？人工智能也可以帮助你。这就像口袋里有一个营销大师。你可以使用人工智能工具制定一个营销计划，让你的产品被看到。你还可以使用人工智能分析用户反馈，随着你不断改进应用程序。</p>
<h1 id="人工智能不会取代你的工作"><a href="#人工智能不会取代你的工作" class="headerlink" title="人工智能不会取代你的工作"></a>人工智能不会取代你的工作</h1><p>当然，人们非常担心人工智能会介入并抢走每个人的工作。世界正朝着某种天网场景发展，机器接管，对吧？你花在学习编码上的所有努力，难道就白费了吗？其实并不是。</p>
<p>这里是重点：人工智能辅助编程工具很强大，但它们不是来取代你的。它们更像是你的助手，帮助你成为更优秀的编码者。它们没有真正开发者的智能或独立性。</p>
<p>但是，重要的是，如果你不使用这些工具，你可能会发现自己落后了。越来越多的雇主希望他们的开发人员使用这些人工智能系统。为什么？因为这些好处实在太好了。我们都需要跟上时代。使用人工智能工具正成为一项必备技能，不是为了防止它们取代你（它们无法取代你），而是因为它们会帮助你更好地完成工作。</p>
<p>根据詹姆斯·克利夫特，耐用公司的创始人兼首席执行官：</p>
<blockquote>
<p>人工智能的进步将导致劳动市场动态的变化，但重要的是要记住，人工智能和商业是相辅相成的。一个不会取代另一个。关键是不要害怕，而是要拥抱技术以支持进一步的业务增长和就业创造。人工智能工具将曾经仅限于大公司的资源放到每个人手中。</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们在这本书中覆盖了很多内容，深入探讨了人工智能辅助编程的方方面面。但即便如此，我们只是触及了表面！我们正处于这段人工智能旅程的早期阶段，令人兴奋的是，从这里开始只会变得更好。技术正在以惊人的速度发展，这意味着开发者将会获得更多很棒的工具和技巧。我们正处于一场非常激动人心的比赛的起跑线上，可能性正在不断增加。</p>
<p>在这个领域工作是令人兴奋的时刻。想象一下我们将能够以多么新的方式提升技能、简化工作，并创造出我们甚至还没有梦想过的东西。人工智能辅助编程的未来光明且充满潜力，所以让我们保持警觉，准备迎接所有即将到来的惊人进展。作为开发者,让我们一起乘着人工智能创新的浪潮，看看它将带我们去往何处。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/18/aiassistedprogramming09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/18/aiassistedprogramming09/" class="post-title-link" itemprop="url">第9章  调试、测试和部署</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-18 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-18T11:48:32+08:00">2024-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 11:55:46" itemprop="dateModified" datetime="2024-09-26T11:55:46+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本章是关于软件开发中常常得不到足够关注的部分：调试、测试和部署。这是一个指南，涵盖从发现不同的错误，到编写人们可以理解的文档，再到确保你的代码按预期运行的所有内容。我们还将深入探讨如何顺利合并更改，使你的软件平稳安全地运行，采纳用户反馈，甚至在发布时引起轰动。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>在编写代码时，开发人员大约会花费 35%到 50%的时间在调试上。这不仅仅是时间消耗。它还占用了软件项目预算的一大部分。</p>
<p>有两种主要类型的错误。首先是语法错误。当你的代码不遵循语言结构的规则时，这些错误就会出现。可能只是忘记在 for 循环的末尾添加冒号。像 VS Code 这样的现代 IDE 应该能够检测并修复这些类型的错误。</p>
<p>接下来是逻辑错误。这些错误更棘手，因为它们发生在你的逻辑有问题的时候。例如，假设你创建了一个程序，根据年龄从列表中筛选出成人用户。唯一的问题是，你的代码错误地排除了 18 岁以下的人，而不是排除 18 岁及以上的人。因此，你最终得到的列表满是成年人，而不是青少年。这种混淆就是逻辑错误的一个典型例子。你的代码做的正好是你所不想要的。找出为什么它标记 18 岁以下的人，而不是 18 岁及以上的人，可能会很棘手。修复方法可以从快速调整年龄条件到重新考虑整个逻辑。</p>
<p>无论如何，在调试时使用人工智能辅助编程工具并不是你应该首先尝试的。通常，传统方法就足够了。VS Code 提供强大的调试功能，可以检测和解决问题。毕竟，你可以轻松设置断点来检查变量值，逐行查看代码，了解具体发生了什么。这些在大型程序中特别有用。</p>
<p>当然，有些错误确实让人头疼。现代软件通常是一个复杂的拼图，有很多层和部分需要协同工作。有时候，错误出现是因为这些部分以意想不到的方式相互作用，找出实际出错的地方可能是一个真正的挑战。还有文档的问题——或者说缺乏文档。当软件没有清晰的说明或解释时，很难理解它应该如何工作，这使得查找和修复错误变得更加困难。您的软件通常依赖于外部库或服务，如果那里出现问题，您软件中的错误可能会让人抓狂。</p>
<p>所以这就是你可以求助于人工智能的地方。例如，一个场景是解读晦涩或冗长的错误信息。这些可能是堆栈跟踪，例如，当程序出现问题时的快照。你还可能获得关于各种框架和库之间交互的详细信息。</p>
<p>您可以复制并粘贴错误消息到提示中，并包含一些简单的内容，例如：</p>
<blockquote>
<p>提示：这是什么意思？{错误信息}</p>
</blockquote>
<p>或者，假设你有代码，但存在逻辑错误。程序就是无法按照你的意图执行。在这种情况下，你可以将代码复制粘贴到提示中。然后包括这个：</p>
<blockquote>
<p>提示：该程序应该允许用户上传照片并在画廊中显示。然而，当执行时，照片没有出现。这个程序有什么问题？{代码}</p>
</blockquote>
<p>如果ChatGPT发现问题，它通常会建议解决方案。但如果没有，你可以将此指令添加到提示中。</p>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>文档是防止一切崩溃的粘合剂，但遗憾的是，它通常被搁置一旁。我们都见过——在没有指南的情况下编写代码就像在迷宫中徘徊，这很痛苦，尤其是对于新手或任何试图弄清楚事情的人。</p>
<p>良好的文档有助于防止猜测游戏，使每个人保持一致。Stack Overflow 的调查显示，68% 的开发人员每周都会遇到这些知识障碍。此外，GitHub 2021 年的报告显示，文档中的信息共享可以使团队的生产力提高多达 55%。</p>
<p>但这不仅仅是为了让开发者的生活更轻松。良好的文档是顺利开发过程的支柱。它就像一张地图，告诉你该去哪里以及需要注意什么。没有它，你往往是在盲目操作，这时就容易出现代价高昂的错误。</p>
<p>使用ChatGPT，您可以创建任何类型的文档，例如：</p>
<ul>
<li> 用户手册</li>
<li> 自述文件</li>
<li> API 文档</li>
<li> 常见问题解答</li>
<li> 故障排除指南</li>
</ul>
<p>在编写有效文档的提示时，需要考虑以下因素：</p>
<ul>
<li> 了解你的受众：考虑一下谁将使用您的文档。他们是希望快速入门的新手，还是需要详细信息的技术高手，比如 API 文档和代码片段？了解读者的需求是确保内容准确的关键。</li>
<li> 保持简单：没人喜欢翻阅需要解码器的行话或技术语言。保持你的语言简单明了。如果你的祖父母无法理解，你可能还没有达到那个水平。</li>
<li> 坚持计划：保持文档外观一致。使用相同的样式、标题、字体……你说的都可以。一致性是你的朋友。这就像歌曲中的良好节奏。这样更流畅。</li>
<li> 展示，而不仅仅是告诉：人们在看到实际操作时理解事物的速度更快。因此，加入现实生活中的例子或场景。如果你在和程序员交流，一些代码示例是非常宝贵的。对于其他人，截图或逐步演示可能会很有帮助。</li>
<li>一图胜千言：有时候，文字无法表达清楚。使用图表、截图或甚至视频来传达你的观点，特别是在处理复杂内容时。</li>
<li>为什么和怎么一样重要：不要只是列出步骤。告诉读者他们为什么要这样做。</li>
</ul>
<p>考虑到这一切，您可以使用以下提示：</p>
<blockquote>
<p>版本控制是管理文件变化的一种方法。它可以记录每次修改的内容，这样我们就可以随时查看之前的版本或恢复到以前的状态。版本控制的重要性在于它可以帮助我们跟踪和管理文件的历史，避免丢失重要信息，并且方便团队协作。可以使用时间轴图或分支图来展示不同版本之间的关系。</p>
</blockquote>
<p>  注意</p>
<blockquote>
<p>ChatGPT 具有深厚的语言翻译能力。您可以将其应用于您的文档或其他任何内容。</p>
</blockquote>
<p>微软正在开发一个名为 GitHub Copilot 的文档系统，适用于企业版。这不是一个普通的文档搜索工具。例如，搜索结果和响应基于用户的编码背景和经验。它还会更新 GitHub 上最新的代码库。它甚至允许您添加私有文档。基本上，这是一个高度复杂的知识库，可以大大提升您的编码能力。</p>
<h1 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h1><p>将代码审查视为代码在提交合并请求之前的试驾。确保一切运行顺利，恰到好处，并且在后续不会出问题。</p>
<p>但这个过程不仅仅是寻找笨重的部分或故障。大家聚在一起，互相交流想法，互相学习是很有帮助的。你会看到解决问题的不同方法，并更好地掌握整个项目。</p>
<p>与此同时，代码审查可以帮助执行组织的编码风格和指南。然后是安全检查。你看，自动化工具并不总是能捕捉到所有问题。有时候，需要人工来发现那些隐蔽的安全风险。</p>
<p>关于ChatGPT，它可以是这个过程的关键部分。以下是一个示例提示：</p>
<blockquote>
<p>代码审查：关注代码的可维护性、潜在安全问题和性能缺陷。{代码}</p>
</blockquote>
<p>我故意给ChatGPT写了一个糟糕的函数，但ChatGPT在审查中做得很好。它提出了许多改进建议，比如函数可以避免硬编码数据库连接。ChatGPT还检测到了由于在 SQL 查询中直接拼接用户 ID 以及缺乏用户输入验证而导致的 SQL 注入风险。然后它发现了 SQL 构建的性能问题。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试在某种程度上是对代码部分的 mini 评估，比如几个函数或方法。开发人员通常使用像 JUnit（Java）、NUnit（.NET）或 pytest（Python）这样的酷工具自己进行测试。这些工具帮助编写和运行测试，并告诉你结果。它们通常与您使用的其他软件工具兼容。</p>
<p>进行单元测试是有帮助的，因为它可以提高软件质量，减少恼人的错误，并使后期调整和修复问题变得更容易。每个测试只关注一件事，因此如果出现问题，您知道确切的查找位置。这些测试通常是自动化的，这意味着它们可以快速且频繁地运行。这对于保持一切顺畅和最新非常重要。</p>
<p>单元测试通常很简单编写。由于它们专注于代码的小部分，因此不应该太复杂。此外，它们就像是软件的指南。通过查看单元测试，其他开发人员可以了解某些部分应该如何工作。如果您更改代码，单元测试非常适合确保您没有搞乱之前正常工作的内容。</p>
<p>让我们看一个例子。假设你创建了一个小费计算器程序，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def tip_calculator(bill_amount, tip_percentage):</span><br><span class="line">    tip_amount = bill_amount * (tip_percentage / 100)</span><br><span class="line">    total_amount = bill_amount + tip_amount</span><br><span class="line">    return total_amount</span><br><span class="line">   </span><br><span class="line">bill_amount = float(input(&quot;Enter the bill amount: &quot;))</span><br><span class="line">tip_percentage = float(input(&quot;Enter the tip percentage (e.g., 20 for 20%): &quot;))</span><br><span class="line">total_amount = tip_calculator(bill_amount, tip_percentage)</span><br><span class="line">print(f&quot;Total amount including tip: &#123;total_amount:.2f&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>此函数计算包括小费在内的总账单金额，并接受两个参数， bill_amount 和 tip_percentage 。该函数将找到 total_amount 的值。</p>
<p>对于这样的代码，单元测试检查各种场景。例如，它们可以帮助验证函数是否正确计算包括小费在内的总金额，适用于一系列输入。这很重要，因为即使是一个小错误也可能导致显著的差异。单元测试可以覆盖典型案例，例如标准账单金额和小费百分比，以及边缘案例，如零或负账单金额或异常高的小费百分比。它们还帮助确保函数能够优雅地处理不规范的输入，例如非数字或空值。</p>
<p>这是一个示例提示：</p>
<blockquote>
<p>提示：针对这个程序，建议单元测试以正确计算总金额，检查典型和边缘情况，例如零和负账单金额以及高小费值。还要检查无效输入。对于单元测试，可以有控制台日志。</p>
</blockquote>
<p>图 9-1 显示了ChatGPT为单元测试创建的代码。</p>
<p>如果您想使用测试框架，以便采用更结构化和全面的方法，可以向ChatGPT请求此内容：</p>
<blockquote>
<p>创建使用测试框架的单元测试。</p>
</blockquote>
<p>ChatGPT 建议使用 unittest。它展示了如何设置，开发测试，并演示如何运行单元测试。</p>
<p>或者，如果您已经有一个包含单元测试的文件，您可以评估它们。这里有一个提示：</p>
<blockquote>
<p>提示：以下是一个程序的单元测试文件，该程序&lt;解释它的功能或指向代码&gt;。还有其他我应该有的测试吗？这里缺少什么？</p>
</blockquote>
<p>虽然ChatGPT或人工智能辅助编程工具在创建这些方面可能很有用，但这些工具远非万无一失。对于更高级的用例或更大的代码库，结果可能会不准确。</p>
<p>考虑以下来自大卫·李的建议，他是一位创始人、高级工程师和 AWS 认证解决方案架构师：</p>
<blockquote>
<p>然而，在处理涉及真实数据库交互和 Docker 的测试时，动态变化显著。这变成了一个ChatGPT 4.0 可能在某种程度上无法理解的复杂程度，您可能需要先手动编写一些测试，特别是数据库连接部分，以便它可以学习如何编写其他测试。</p>
</blockquote>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0901-20240829160530-wsr6uzm.png"></p>
<p> 图 9-1. ChatGPT 为小费计算器程序创建单元测试代码</p>
<h2 id="拉取请求"><a href="#拉取请求" class="headerlink" title="拉取请求"></a>拉取请求</h2><p>拉取请求，简称 PR，就像编码世界中的一张金票，特别是在与他人合作时。你完成代码，将其推送到像 GitHub 或 GitLab 这样的地方，然后发送 PR。这不仅仅是一个“请添加我的代码”的请求。它也是对你的团队成员的提醒，让他们查看你所做的工作，给个赞，或者提出一些建议以使其更好。这一切都是为了确保当你的代码加入项目的其他部分时，它是最好的。此外，PR 是一种很好的方式来跟踪谁在什么时候做了什么，这在大型项目中确实很有帮助。</p>
<p>毫无疑问，撰写一个扎实的 PR 描述确实很重要。你需要阐明你的更改的内容、原因和方法。首先简要介绍你要解决的问题。然后深入说明你的更改是如何解决这个问题的。别忘了添加一些细节，比如哪些文件进行了改造或你运行了哪些测试。如果有你不确定的具体内容或需要第二意见的地方，也请提及。</p>
<p>有效的 PR 描述是审阅者的救星。它加快了整个过程，并让每个人保持一致。此外，详细的 PR 描述就像未来信息的宝藏。</p>
<p>当然，ChatGPT可以成为你撰写 PR 描述的助手。需要启动草稿吗？告诉ChatGPT你做了什么，它会帮助你将其结构化为清晰且简明的内容。如果你已经写了描述，ChatGPT可以检查其清晰度和语法，并建议改进的方法。ChatGPT还可以帮助你找出最佳的 PR 布局方式，比如先写摘要，然后再深入细节。如果有需要简化的技术细节，它会帮助你让 PR 对团队中的每个人更易理解。</p>
<p>让我们看一些有用的提示：</p>
<blockquote>
<p>我向应用程序添加了一个新的搜索功能，可根据用户输入过滤结果。你能帮我写一个 PR 描述吗？</p>
<p>我修复了当用户在文本字段中输入特殊字符时应用程序崩溃的错误。我应该如何在 PR 中描述这一点？</p>
<p>重构了认证模块以提高性能和可读性。PR 描述中应包含什么？</p>
<p>我更新了用户界面，使导航更加直观，并添加了新图标。你能帮我起草一个 PR 描述吗？</p>
<p>在 PR 描述中如何表述这个比较好？</p>
<p>我为支付处理模块添加了新的单元测试。你能帮我写一个突出这些更改的 PR 描述吗？</p>
<p>我解决了由于主分支最近的更改而产生的合并冲突。在 PR 描述中我应该提到什么？</p>
</blockquote>
<p>请记住，微软在Copilot中添加了一个功能，可以创建 PR 描述。它被称为生成的提交消息。要使用它，您需要确保与 GitHub 上的仓库建立连接。然后您只需点击闪光按钮，如图 9-2 左侧面板所示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0902-20240829160531-bgpixvg.png"></p>
<p> 图 9-2. Copilot 可以根据加载到您项目中的仓库创建 PR 描述</p>
<p>Copilot 将编写有用的 PR 描述。</p>
<p>最后，有很多初创公司正在基于LLM技术创建自己的系统。其中一个叫做 What The Diff。根据公司的联合创始人兼首席执行官塞巴斯蒂安·施莱因的说法：</p>
<blockquote>
<p>What The Diff 有两个主要功能：1）通过将拉取请求总结成简单英语，使其更容易审查，并为审查者提供易于理解的关于 PR 中更改的概述。2）WTD 还可以编写完全非技术性的摘要，并发送给其他利益相关者，如没有 GitHub 访问权限的产品经理。这使他们能够轻松查看拉取请求中的更改是否符合他们的规格。</p>
</blockquote>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>你一直在努力开发软件，现在是时候发布了——大规模上线。这是一个激动人心的时刻。你将看到真实的人使用你的软件，告诉你哪些地方很好，哪些地方需要调整，甚至更多。这样的反馈？对开发者来说是无价的。</p>
<p>如果您从事软件销售业务，这是您一直等待的时刻——现金开始流入的时候。成功发布可以真正改变您的银行余额。</p>
<p>但让我们现实一点：部署软件就像屏住呼吸，希望一切顺利。总有一种偷偷的感觉，事情可能不会按计划进行。</p>
<p>你知道在测试环境中一切看起来都很完美，但在现实世界中却有些不稳定吗？可能是不同的硬件，一些奇怪的网络系统，或者只是一些奇怪的设置搞砸了。</p>
<p>安全也是一个大问题。一旦上线，您必须保持警惕，以防止坏人入侵，并遵守隐私规则。</p>
<p>此外，您的软件必须足够强大以应对人流。无论有多少人使用它，或者您的业务有多大，它都必须保持快速和流畅。</p>
<p>然后就是整个持续集成&#x2F;持续部署的事情。这都是为了让部署变得顺畅和自动化，以避免错误。听起来不错，但要让它运行起来并保持这种状态，确实有点麻烦。</p>
<p>那么该怎么办？你可以查看ChatGPT。以下是一些值得考虑的提示：</p>
<blockquote>
<p>请指导我为我的团队创建一个部署检查清单</p>
<p>获取 Docker 部署相关的学习资源有哪些？</p>
<p>零停机时间部署的最佳实践在 web 应用程序中是什么？</p>
<p>部署时遇到“服务器超时”错误。常见原因和解决方案有哪些？</p>
<p>你能帮我写一个用于自动部署我的 Python web 应用的 bash 脚本吗？</p>
<p>在生产环境中部署应用程序之前，我应该检查哪些基本配置设置？</p>
<p>如何在云环境中规划失败部署的回滚策略？</p>
<p>在部署金融应用程序时我应该考虑哪些安全措施？</p>
<p>如何优化已部署的 Node.js 应用程序的性能？</p>
</blockquote>
<p>虽然不完美，ChatGPT 在复杂的 DevOps 中可以提供帮助。以下是私人市场实验室的联合创始人兼首席产品官 Titus Capilnean 的一些想法：</p>
<blockquote>
<p>云日志并不是最容易处理的东西，特别是因为我不是运维工程师，但我们必须处理它们，因为我们定期在 AWS 和谷歌云上运行流程。</p>
<p>有一次，我需要为一个 SQS + Lambda 过程设置跟踪，基于大规模函数部署的输出。我的函数本质上是在日志中打印状态，我计划使用该状态生成该过程的报告——在我们的案例中，是处理存活状态。我让 ChatGPT 提供一个 AWS CloudWatch 查询脚本，并调整到我可以在每个过程结束时运行它以获取结果的程度。详细阅读文档完成这个任务可能需要 5-6 小时，所以我通过 GPT 的方式节省了很多时间。</p>
<p>同样，我需要在谷歌云中设置一些警报，我与ChatGPT合作创建了一个查询，排除了我们实际上不负责且不面向用户的一些系统级错误。这为我节省了数小时的阅读和工作时间，并为我提供了设置有用警报系统所需的自定义指标。</p>
</blockquote>
<h2 id="用户反馈"><a href="#用户反馈" class="headerlink" title="用户反馈"></a>用户反馈</h2><p>用户反馈是让您的软件出色的关键。当您的用户看到您在关注并根据他们的想法进行更改时，他们更有可能留下来并面带微笑。提前在他们的帮助下解决问题比在很多（越来越不满意的）用户使用您的应用后再去清理大麻烦要聪明得多。</p>
<p>即使经过所有测试，一些错误仍然很狡猾，只有在您的软件进入现实世界时才会显露出来。您的用户就像您个人的侦探，发现可能被您忽视的问题。</p>
<p>有时候，您的用户会非常有创意地使用您的软件，以您从未想到的方式。他们的奇思妙想可以激发新功能，甚至全新的产品。</p>
<p>当然，还有一整套工具来提升客户服务。一些工具包括 Zendesk、Freshdesk、Drift 和 Salesforce。它们可以处理从实时聊天让您与客户实时沟通到收集用户反馈的表单等所有内容。自动工单系统跟踪客户问题，确保没有遗漏。还有客户关系管理（CRM）系统，它将所有客户互动集中在一个地方。这些工具确实可以在提供高效、响应迅速的客户服务方面发挥作用。</p>
<p>生成式人工智能确实可以在此基础上增加价值。它特别擅长处理大量非结构化数据，例如用户反馈。</p>
<p>例如，假设您有一个包含大量电子邮件、即时消息和用户联系表信息的文件。您可以然后去ChatGPT并使用此提示：</p>
<blockquote>
<p>提示：识别常见主题和类别，例如可用性、性能、功能、错误和客户服务。同时，对该文件进行情感分析。根据提到的问题的频率和严重性，帮助优先确定首先修复哪些错误或考虑添加哪些功能。基于所有这些，创建一个包含图表的报告。</p>
</blockquote>
<p>另一种ChatGPT可以提供帮助的方式是响应草拟。如果您正在处理客户反馈，它可以帮助您写出更好的回复，例如为常见问题创建答案模板。这样，在与用户或客户聊天时，您始终保持专业和准确。</p>
<p>或者，您可以使用ChatGPT获得更个性化的回复。您可以复制粘贴用户邮箱并使用类似这样的提示：</p>
<blockquote>
<p>回复用户邮件，保持冷静和理解的语气。确保回复友好，并帮助缓解任何担忧，而不升级情况。</p>
</blockquote>
<p>在某些情况下，您可以创建自己的基于LLM的应用程序来处理用户反馈。这就是 Warp 所做的。该公司让一名开发人员花了不到一周的时间——兼职——来创建该应用程序。它是使用OpenAI API 构建的。</p>
<p>这个应用程序带来了巨大的变化，”Warp 的产品经理诺亚·兹韦本说。“之前，很难对 incoming 反馈进行分类和优先级排序。但生成式人工智能能够非常好地做到这一点。”</p>
<h2 id="营销"><a href="#营销" class="headerlink" title="营销"></a>营销</h2><p>在ChatGPT成为热门之前的几年，生成式人工智能已经对销售和营销等重要活动产生了影响。开创者是 Jasper。该公司以惊人的速度增长。不过，生成式人工智能非常适合快速生成引人注目和富有创意的内容。</p>
<p>但您不需要 Jasper 来发布您的软件。ChatGPT应该可以正常工作。首先，您可以开始制定一个出色的营销计划。以下是一个示例提示：</p>
<blockquote>
<p>营销计划：为帮助人们规划健康饮食的应用程序制定营销计划。该应用程序根据饮食偏好、健康目标和营养需求创建定制餐单。它还可以生成购物清单、提供食谱建议和跟踪营养摄入。由于公司是初创阶段，营销预算资源有限。</p>
</blockquote>
<p>ChatGPT 首先建议您确定目标受众。它建议主要用户是“注重健康的个人、健身爱好者、有特定饮食需求的人（例如，无麸质、素食者）、忙碌的专业人士等。”然后涵盖各种策略，例如利用社交媒体、内容营销、社区参与、电子邮件营销和合作伙伴关系。</p>
<p>这里有一些其他有用的ChatGPT提示：</p>
<blockquote>
<p>引言：我们很高兴地宣布推出全新的健康规划应用程序！这款应用程序旨在帮助用户更好地管理他们的健康和生活方式。它独特的功能包括个性化的健康目标设置、饮食和锻炼跟踪、以及智能提醒，让您时刻保持在最佳状态。无论您是想减肥、增加锻炼还是改善饮食习惯，这款应用都能为您提供量身定制的建议和支持。快来体验，让健康管理变得简单而有趣！</p>
<p>发布我们的新健康规划应用程序，专注于其用户友好的界面以及如何帮助管理健康目标。</p>
<p>产品公告邮件：我们健康规划应用程序现已上线，能够帮助用户跟踪和改善健康习惯。</p>
<p>主题：提升客户健康管理的最佳工具 亲爱的健身教练和健康教练， 您是否在寻找一种有效的方式来帮助您的客户更好地管理他们的健康和健身目标？我们推出了一款健康规划应用程序，专为像您这样的专业人士设计，旨在提升客户的健康体验。 我们的应用程序提供个性化的健康计划、饮食跟踪、锻炼记录和进度监测，帮助您的客户保持动力，实现他们的目标。通过使用我们的工具，您可以为客户提供更专业的指导，增强他们的参与感和满意度。 立即加入我们，让您的客户体验到更高效的健康管理方式！点击这里下载应用程序并开始免费试用。 期待您的反馈！ 最好的祝愿， [您的公司名称]</p>
<p>健康规划助手</p>
<p>提示：为推广我们的健康规划应用程序开发 Facebook 和 Instagram 广告文案，突出其易用性和个性化选项。</p>
<p>请求早期用户对我们健康规划应用的评价模板，用于营销材料。</p>
<p>邀请函：虚拟发布会邀请我们的健康规划应用，详细议程和特邀嘉宾。</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本章就像是软件开发中那些不总是受到关注的幕后花絮。当然，创建新软件令人兴奋，但真正决定应用程序成败的是调试、测试和文档等不那么引人注目的任务。我们已经讨论过像ChatGPT这样的人工智能工具如何使这些工作变得更加顺利。这些人工智能助手不是魔法修复，但它们在筛选大量数据、提供建议、生成内容、发现问题和加快整个过程方面非常出色。这意味着开发人员可以专注于真正棘手的事情。通过在每个步骤中引入生成式人工智能和一些智能策略，从修复错误到发布，开发人员可以构建更好的软件，真正满足用户需求，并且速度更快。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/16/aiassistedprogramming08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/16/aiassistedprogramming08/" class="post-title-link" itemprop="url">第8章  编码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-16 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-16T11:48:32+08:00">2024-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 11:55:46" itemprop="dateModified" datetime="2024-09-26T11:55:46+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在本章中，我们将深入一些实用的编码技巧。我们将从编码的基础开始——玩弄函数和类。然后，我们将进行一些重构，整理混乱的代码，使其运行得更顺畅。我们还将展示如何处理和创建数据。接着，我们将查看一些可以帮助创建精美前端的人工智能工具，轻松实现。</p>
<h1 id="现实检查"><a href="#现实检查" class="headerlink" title="现实检查"></a>现实检查</h1><p>人工智能辅助编程工具很酷，对吧？但我们不要自欺欺人。它们不是能解决我们所有编码问题的魔法棒。为什么？因为这些工具就像课堂上那些只从公开笔记中学习的学生。它们是在互联网上各种代码的混合上训练的，老实说，并不是所有的代码都是顶尖的。这对你意味着什么？有时候，你可能会得到比感恩节火鸡还要臃肿的代码，或者像纸牌屋一样难以维护。有时候代码就是错的，不能满足你的需求，甚至更糟的是，让黑客轻松进入你的前门或占用你的网络资源。</p>
<p>让我们看一个例子，其中ChatGPT生成了混乱的代码。图 8-1 显示了将两个已排序列表合并为一个单一已排序列表的代码。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0801-20240829151930-epotutb.png"></p>
<p>图 8-1. 在被要求合并两个已排序列表时，ChatGPT 创建了一些混乱的代码</p>
<p>这段人工智能生成的代码确实正确地合并了两个列表，但它采用了冗长的方法。它单独处理了空列表的情况，并使用两个额外的 while 循环来附加每个列表中的剩余元素。</p>
<p>这就是你的编码智慧真正发挥作用的地方。你必须了解基础知识。你需要知道该问什么问题，以及在出现问题时该去哪里查找。</p>
<p>图 8-2 显示了一种更好的方法。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0802-20240829151931-ybgf6ne.png"></p>
<p> 图 8-2. 在一些人工帮助下，我们实现了更好的排序列表合并方法</p>
<p>所以不要担心你可能听到的关于机器人取代开发者工作的悲观言论。诚然，这些人工智能模型一直在不断进步。它们在学习和成长。然而，它们距离编程的终极解决方案仍然很远。程序员仍然在这个领域中发挥着重要作用。人工智能辅助编程工具非常有帮助，但它们不会取代真正工程师的智慧和经验。</p>
<p>当你与这些系统协作时，请记住：这是一种合作，而不是交接。保持敏锐，保持好奇，别忘了仔细检查这些人工智能工具提供的所有内容。它们是助手，而不是英雄。</p>
<h1 id="判断决策"><a href="#判断决策" class="headerlink" title="判断决策"></a>判断决策</h1><p>有时候，自己编写代码比使用人工智能辅助编程工具更简单。毕竟，让人工智能理解你的需求可能需要多次尝试。但是随着你不断使用这些人工智能工具，你会逐渐掌握它们何时有用，何时自己独立完成更好。</p>
<p>以 Dmitrii Ivashchenko 的经验为例，他是 MY.GAMES 的首席软件工程师，这是一家总部位于阿姆斯特丹的游戏公司，全球注册用户超过 10 亿。根据他说：</p>
<blockquote>
<p>一个例子是提示“用 Python 编写一个方法为 datetime 对象添加默认时区。”但是，你应该准备好很多方面会被省略，你要么自己处理边缘情况，要么与ChatGPT进行长时间的沟通指出它的错误。这里主要是初步评估解释一个任务所需的时间与自己实现它所需的时间。</p>
</blockquote>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>使用类似ChatGPT的方式学习新语言、框架或库可以大有帮助。这可能比传统的方法如上课、无休止地谷歌搜索或观看一堆 YouTube 视频更快。</p>
<p>您可以使用ChatGPT获取所有基本知识和代码语法的详细信息。此外，如果您更喜欢通过实践学习，可以请求代码示例以查看所有内容如何结合在一起。如果您已经知道一种编程语言，ChatGPT可以通过比较两者来使学习新语言变得更容易。假设您擅长 Python 但刚开始学习 JavaScript；它可以用 Python 术语解释主要区别。如果您需要更多资源，ChatGPT可以在互联网上搜索并推荐一些可靠的学习材料给您。</p>
<p>以下是一些值得考虑的提示：</p>
<blockquote>
<p>对于不懂Python的人来说，我应该先学什么？</p>
<p>初学者可以尝试哪些项目来提高我在 React 中的技能？</p>
<p>请问您能推荐一些学习高级 SQL 查询的资源吗？</p>
<p>提示：如何用 Python 和 JavaScript 实现一个基本的“待办事项”应用程序，以突出它们的区别？</p>
<p>提示：我知道如何在 C++中使用循环。你能给我展示一下 Python 中的循环是如何工作的以便比较吗？</p>
<p>找到 5 个有用的 YouTube 视频，展示如何学习 Rust。</p>
</blockquote>
<p>让我们看看伊瓦申科是如何处理这个问题的：</p>
<blockquote>
<p>如果你想快速掌握一门新语言或框架，可以立即开始在该技术上创建一个新项目。假设你想学习 Django。我们选择一个将在此技术上实现的项目——一个在线商店。首先，问ChatGPT如何开始开发一个新的 Django 项目。它会告诉你需要安装哪些依赖项，如何设置项目的初始配置，以及你需要处理哪些相关技术。然后我们继续更具体的请求，比如“Django 中的模型是如何组织的？”“如何在管理面板中添加新部分？”以及“如何迁移数据库？”通过逐渐获得新知识并提出越来越详细的问题，你几乎可以实现任何在之前不熟悉的技术上的项目。这就是我通过一个周末的高效工作掌握 Django 的方法。</p>
</blockquote>
<p>您也可以让ChatGPT创建有用的学习指南。以下是一个示例提示：</p>
<blockquote>
<p>创建一个JavaScript 学习指南：初学者级别</p>
</blockquote>
<p>您可以随后跟进：</p>
<blockquote>
<p>请为我创建一个学习计划。我应该学习哪些主题？练习题或测验呢？编码问题？资源链接？</p>
</blockquote>
<p>ChatGPT 甚至可以帮助你记住新概念。一种方法是使用助记设备，例如首字母缩略词。例如，假设你想记住 DevOps 的关键要素，包括持续集成、持续交付、微服务和基础设施即代码。这是 ChatGPT 建议的：</p>
<blockquote>
<p>CI-CD-MI (pronounced “Ci-Ci-D-Mi”)</p>
</blockquote>
<p>最后，你可以使用ChatGPT来获取 LeetCode 的帮助。想象一下：你坐在面试室里，面前可能有一个白板或一台笔记本电脑，然后他们给你出一个脑筋急转弯的算法或数据结构问题。这不仅仅是编码。他们在评估你思考的速度、解释思路的能力以及解决问题的风格。</p>
<p>如果你想要提升自己，可以考虑注册 LeetCode。每月 35 美元。当然，ChatGPT 随时可以提供帮助。这是一个简单的提示：</p>
<blockquote>
<p>建议三个常见的 LeetCode 面试题。</p>
</blockquote>
<p>ChatGPT 然后出现了像两数之和、最长无重复子串和有效括号这样的挑战。你可以进一步深入，比如获取更长的解释或示例。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>当你在与截止日期赛跑时，很容易省略代码注释或完全放弃它们。但人工智能辅助工具可以支持你。你会发现代码建议中已经包含注释。</p>
<p>有趣的是，由于人工智能技术，拥有注释可能感觉有些过时。如果代码让你感到困惑，你可以直接让工具为你解析，不是吗？这确实是事实。</p>
<p>其他内容：写作提示正成为新的评论方式。毕竟，大多数工具在评论行中包含提示。</p>
<p>当然，如果你想给一些代码添加注释，可以使用简单的提示，比如：</p>
<blockquote>
<p>添加清晰且符合最佳编码实践的注释。</p>
</blockquote>
<p>是否注释由你决定。这里没有放之四海而皆准的规则。这完全取决于什么对你和你的团队有效。但有一点是肯定的——使用人工智能辅助工具在代码上添加注释非常简单。</p>
<h1 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h1><p>模块化编程是高效和有效软件开发的基石。通过模块化编程，代码更加有组织，更易于理解，也更容易跟上进度。这也使得与其他编码人员合作时减少了很多麻烦，因为大家不会互相干扰。此外，模块是可重用的；可重用性是巨大的时间节省，保持了一致性，并减少了出错的可能性。</p>
<p>模块化编程的价值确实适用于你如何使用人工智能辅助工具。它们不会从简单的提示中生成高级应用程序。它们不是魔法师。但如果你将任务分解成清晰、具体的部分，这些工具就会表现出色。否则，你可能会得到一堆偏离主题的代码混乱。</p>
<p>根据蒂图斯·卡皮尔尼安，私人市场实验室的联合创始人兼首席产品官：</p>
<blockquote>
<p>在我开始使用人工智能工具后，我可以专注于问题和我的解决方案方法，而不是我需要编写的实际代码的细节。当我遇到技术问题时，我会先将其分解成更小的部分，输入和输出清晰明了。这样做的原因是我使用的人工智能工具的上下文窗口可能不足以一次性提出一个好的解决方案。我发现如果我要求模型提供使用简单输入的代码，执行一个单一的任务并提供我可以验证的输出，调试和构建会更容易。如果我对中间输出不满意，我会向ChatGPT描述我的问题，并尝试运行它提供的更新代码。一旦我对解决方案满意，我可以添加额外的处理步骤，或者在现有函数内部，或者取前一步的输出进一步优化，使其更接近我想要的解决方案。</p>
<p>人工智能工具还提高了我的生产力，让我在将代码片段发送到编译器或部署云函数并消耗资源之前，先检查我构建的代码片段是否正确。我只需将代码的一部分粘贴到ChatGPT窗口中，并询问它是否正确，假设我初始化&#x2F;提供了代码片段运行所需的正确上下文（例如，导入、变量、常量、调用的自定义函数等）。这让我能够生成运行良好且更快的解决方案。</p>
</blockquote>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p>冷启动问题或空白页面问题</p>
<p>这里有一个场景：你盯着一个空屏幕，没有代码，没有数据，甚至没有明确的前进路径。毫无疑问，这听起来令人不知所措。第一个大难题是选择项目的架构、设计模式和使用什么技术。这些决定非常重要，因为你将长期与它们共存，所以你希望尽可能从一开始就做好。</p>
<p>不要忘记人员因素。让团队达成共识，找出有效沟通的方法，从零开始建立工作流程——这些可能和技术一样具有挑战性。这不仅仅是写下第一行代码，而是为接下来的所有内容打下坚实的基础。应对这个阶段需要聪明的规划、技术知识和扎实的团队合作。</p>
<p>人工智能辅助编程工具可以提供很大帮助。您可以使用它们来搭建应用程序的基本框架。您将找到一个与您的愿景相符的定制起点。这些工具让您免于繁琐的初始设置，直接进入项目中更有趣的部分。</p>
<p>您可以提出一个特定任务，然后提示LLM生成模板或启动代码。</p>
<p>这是一个示例提示：</p>
<blockquote>
<p>提示：生成一个网页应用的启动代码，该应用将用户的社交媒体动态从多个平台聚合到一个单一的仪表板界面。你建议我使用什么语言和框架？关于一般文件结构呢？</p>
</blockquote>
<p>使用此方法，ChatGPT 首先建议使用 React 创建流畅的单页面应用（SPA）。它还建议使用 Redux 来维护强类型和可重用的组件。接着建议使用 Node.js 运行应用程序，使用 Express.js 处理 API 端点。然后推荐使用 Passport.js 进行登录，使用 MongoDB 和 Mongoose 进行数据库和模型构建。至于文件结构，图 8-3 显示了布局。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0803-20240829151931-zusn8r6.png"></p>
<p> 图 8-3. ChatGPT 建议了一种新网页应用的文件结构</p>
<h1 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h1><p>你知道当你深陷编码区，设置时间单位的常量时，代码一行接一行重复吗？这时 GitHub Copilot 就派上用场了。你可以让它提供自动填充。</p>
<p>让我们举个例子。假设您正在创建一个希望实现响应式的应用程序。这意味着您需要为 CSS-in-JS 样式组件库设置断点常量。</p>
<p>您可以先写这个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">breakpoints = &#123;</span><br><span class="line">    &#x27;xs&#x27;: &#x27;320px&#x27;,  # Extra small devices</span><br></pre></td></tr></table></figure>

<p>然后在在线聊天中，您可以使用此提示：</p>
<blockquote>
<p>为其他屏幕尺寸创建常量。</p>
</blockquote>
<p>图 8-4 显示了结果。它提供了其他屏幕尺寸和具有类似样式的变量。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0804-20240829151931-gqya3zj.png"></p>
<p>图 8-4. 这是 Copilot 的输出，建议不同屏幕尺寸的常量</p>
<p>您可以进一步使用此功能。Copilot 可以通过查看您项目中的打开文件来帮助自动填充。</p>
<p> 根据卡皮尔尼安：</p>
<blockquote>
<p>我发现Copilot在处理数据结构时特别有用，如果你的代码中有相似的部分。如果你在另一个文件中定义了一个对象，而这个对象是你正在使用的代码库的一部分，那么当你尝试定义一个相似的对象时，它可以在你输入时可靠地为你预填充代码。例如，一个用于常见 API 调用的对象，比如 Sendgrid 电子邮件，在这里效果很好。</p>
<p>然而，如果不小心，这个自动补全可能会产生错误。例如，在导入时，它并不总是能正确获取文件夹结构，特别是如果你设计了自己的代码结构，或者你使用的框架比较新且文档不完善。在这种情况下，我必须手动检查组件来自哪里，以及Copilot建议的目录是否正确。</p>
</blockquote>
<h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>重构就像是代码的春季清理。它是关于整理、重组，有时还要美化。它不是添加新功能或修复错误。</p>
<p>重构保持代码库健康，减少杂乱，更加直观。这意味着当你或其他人稍后重新进入时，更容易理解发生了什么，从而减少头疼和对着屏幕咒骂。此外，干净的代码通常更高效且更少错误，因此对所有参与者来说都是双赢。</p>
<p>重构是人工智能辅助工具表现出色的领域之一。通过一两个提示，您可以简化代码的复杂性，精简冗余，并将代码重组为不仅功能齐全而且优雅的形式。有了人工智能的支持，重构变得不再是一项繁琐的工作，而是保持领先的秘密武器。</p>
<p>在本章的接下来的几个部分中，我们将查看一些重构的例子。</p>
<h2 id="忍者代码"><a href="#忍者代码" class="headerlink" title="忍者代码"></a>忍者代码</h2><p>把忍者代码想象成那些过于夸张的动作电影特技。它华丽而复杂，让你想，“哇，他们是怎么做到的？”但问题是：一旦惊叹感消退，弄清楚它就成了一件难事。想象一下，代码如此狡猾和纠结，以至于即使是写它的人在他们的“忍者”阶段过去后也无法理清头绪。当然，完成那个忍者动作在当下感觉很酷，但当你或其他人需要重新进入并进行更改时，就不再是“嗨呀！”而是“哦哦。”事实是，虽然忍者代码可能展示了一些严肃的编程技巧，但它往往违背了良好编码实践的原则，这些原则强调保持代码的整洁、简单和易懂。</p>
<p>无论如何，忍者代码是很常见的。但使用人工智能辅助工具重构可以帮助理清思路。以下是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log((function(n, a = 0, b = 1) &#123; while (--n) [a, b] = [b, a + b]; </span><br><span class="line">return a; &#125;)(10));</span><br></pre></td></tr></table></figure>

<p>让ChatGPT来完成工作：</p>
<blockquote>
<p>提示：你能一步一步解释这段代码吗？另外，你能用更简单、更易维护的方式写出来吗？</p>
</blockquote>
<p>ChatGPT 确定这是一个计算第 n 个斐波那契数的函数。接下来分六步描述，并提供简化版本，如图 8-5 所示：</p>
<blockquote>
<p>ChatGPT：在这个版本中，calculateFibonacci 函数清晰地展示了遍历斐波那契数列的过程。它更冗长，但更容易理解和维护，特别是对于将来可能阅读此代码的其他开发人员。</p>
</blockquote>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0805-20240829151932-t457xtm.png"></p>
<p> 图 8-5. ChatGPT 提供了一个更简单的版本的忍者代码</p>
<h2 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h2><p>当你有一个很长的方法或函数时，你可以应用提取方法。你会挑选出一段专注于某个任务的代码，比如数据检查或特定计算，然后将其转化为一个新方法。</p>
<p>这种方法不仅仅是让事情看起来整洁。它也是实用的。它帮助你保持代码易于阅读和理解。当你需要再次执行相同的任务时，你可以调用你的新方法，而不是重写代码。如果出现故障，当你的代码被很好地分割成这些专注的小块时，更容易解决。这是为了让你的生活更轻松，并保持代码的整洁和有序。</p>
<p>以下是提取方法的一些提示：</p>
<blockquote>
<p>提问：在函数式编程语言中提取方法时有哪些常见的陷阱需要避免？</p>
<p>提示：我附上了一段我的 C#代码。你能建议哪些部分适合提取方法重构吗？</p>
<p>提示：你能比较一下我的原始函数和提取方法后的重构版本吗？哪个更高效？</p>
</blockquote>
<h2 id="分解条件语句"><a href="#分解条件语句" class="headerlink" title="分解条件语句"></a>分解条件语句</h2><p>分解条件语句是将复杂的 if-then-else 语句拆分成更易于理解的内容。你知道那种——那些冗长、曲折的条件，让你盯着屏幕眯眼试图弄清楚发生了什么。</p>
<p>假设你有一个 if 语句，包含一个复杂的条件，检查多个变量，并可能调用其他函数。你可以将这个条件提取到一个方法中，方法名清楚地描述这个条件在检查什么。例如，像 <code>if (user.isActive() &amp;&amp; user.hasSubscription() &amp;&amp; !user.isBlocked())</code> 这样的条件可以重构为一个名为 <code>canUserAccessContent()</code> 的方法。这不仅使你的主方法更简洁，还能让代码立即自解释。</p>
<p>同样， then 和 else 块中的代码可以提取到不同的方法中。这使得程序的主流程更加易读。读者现在可以在高层次上理解流程：如果这个条件为真，就这样做；否则，就那样做。逻辑的每个部分都在自己命名整齐的方法中，使得单独测试和修改变得更容易。</p>
<p>这里有一些提示：</p>
<blockquote>
<p>提示：你能解释一下如何分解 Java 代码中的条件语句以提高可读性吗？</p>
<p>提示：我如何使用分解条件技术来拆分复杂的如果-那么-否则语句？</p>
</blockquote>
<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>重命名函数、变量和类可能看起来是一个小改动，但它对代码的可读性和可维护性有很大影响。这在代码随着时间演变而原始名称不再准确描述代码功能的情况下特别有用。例如，一个最初命名为 processData 的方法可能变得更加专业化。将其重命名为更具描述性的名称，如 filterInvalidEntries ，可以立即明确其功能。</p>
<p>编写重命名提示非常简单：</p>
<blockquote>
<p>提示：对于在我的 SQL 脚本中保存数据库中用户总数的变量来说，什么是一个好的名称？</p>
<p>提示：这是我的 JavaScript 代码片段。你能审查一下变量和方法名称并提出改进建议吗？</p>
<p>提示：我不确定我的 Java 类中的名称是否足够清晰。你能提议更清晰的名称吗？</p>
</blockquote>
<p>但你需要小心，比如在使用像Copilot这样的工具时。如果你更改了名称，这可能会破坏仍在使用旧名称的代码部分。</p>
<h2 id="死代码"><a href="#死代码" class="headerlink" title="死代码"></a>死代码</h2><p>死代码顾名思义是没有被使用的代码。这些是被遗忘的代码行，来自于被废弃的功能或使某些部分变得多余的更新。</p>
<p>清理项目中的无效代码使一切更加整洁和易于管理。对于任何新加入项目的人来说，这也减少了困惑。如果某些代码似乎没有任何作用，他们就不必费解为什么会存在这些代码。</p>
<p>这里有一些有用的提示：</p>
<blockquote>
<p>提示：你能帮我识别这段 JavaScript 代码中的潜在死代码吗？</p>
<p>提示：这是我的 Python 项目的一部分。你能指出任何看起来未使用或冗余的代码吗？</p>
<p>提示：请查看这些 SQL 过程，并确认是否有任何可以安全删除的</p>
</blockquote>
<p>注意，使用LLM可能存在风险。有时候，看起来像是旧的、尘封的代码角落实际上可能对那些罕见的、以防万一的场景很重要。然后还有连锁反应：移除一个部分可能会影响到依赖它的其他内容，特别是如果它是复杂逻辑或设置的一部分。所以要小心。</p>
<p>另一个问题是生成式人工智能可能无法真正理解关系。因此，在人工智能系统变得更加复杂之前，最好避免使用它们来清除死代码。</p>
<p>当涉及到处理死代码时，替代工具可能是更好的选择。一个例子是代码检查工具。可以把它看作是你代码的整理团队。如果你在使用 JavaScript，可以使用 ESLint。或者对于 Python 爱好者，可以使用 Pylint，Ruby 开发者可以使用 RuboCop。这些工具就像代码的语法检查器。它们擅长发现那些恼人的语法错误、潜在的 bug，当然，还有那些偷偷潜伏但没有任何作用的代码片段。</p>
<p>你还有重型检查工具：静态代码分析工具。顶级供应商有 SonarQube、Code Climate 和 Coverity。这些工具就像侦探。它们在不运行代码的情况下深入分析你的代码，嗅探可能在后续出现问题的复杂模式，包括死代码。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是编码的基础，在任何类型的软件程序中都发挥着重要作用，无论使用什么编程语言。它们是代码块，有助于保持程序整洁和易读，因为它们让你可以轻松重用代码——对任何开发者来说都是救命稻草。它们还可以将一个大任务拆分成更小、更易管理的部分。这使得处理复杂软件变得容易得多，特别是在需要修复错误、进行更新或只是想理解代码在做什么时。</p>
<p>从一开始就要准确实现函数。使它们工作是一回事，但你还需要确保它们与其他代码良好配合。你希望你的函数清晰、易于维护且高效。你需要考虑给每个函数命名，使其有意义，如何设置它，如何处理进出的数据，以及如何处理任何问题。</p>
<p>以下是一些需要牢记的指导原则：</p>
<ul>
<li>单一职责原则：你的功能需要专注于一项工作——就是这样。这使得弄清楚它在做什么、检查它是否正常工作以及在不正常时修复它变得简单得多。</li>
<li>清楚命名：给你的函数起一个名字，让它准确地告诉你它的作用。如果它计算总价，则将其称为calculateTotalPrice。这使您的代码更具可读性。</li>
<li>简洁明了：一个好的经验法则是，你应该能够在屏幕上看到整个函数而无需滚动。短函数更容易处理，出错的可能性更小。</li>
<li>参数是关键：使用参数作为输入，返回值作为输出。这使得您的函数可预测且自包含。</li>
<li>保持一致：遵循您语言或项目的编码规范和风格指南。这有助于保持代码的一致性，便于他人阅读。</li>
</ul>
<p>当你记住这些提示时，你可以快速生成一些非常有效的函数提示，ChatGPT可以提供帮助。查看这些示例提示：</p>
<blockquote>
<p><em>Prompt:</em> Write a Python function named calculate_area that takes two integers as parameters, length and width, and returns the area of a rectangle. Include a docstring explaining the function’s purpose and ensure the function handles non-integer inputs by raising a TypeError.</p>
<p><em>Prompt:</em> 我需要一个名为filterAndTransform 的JavaScript 函数。它应该将对象数组作为输入。每个对象都有属性名称（字符串）和年龄（数字）。该函数应返回一个新数组，其中包含 18 岁或以上人员的姓名（已转换为大写）。包括解释逻辑的注释。</p>
<p><em>Prompt:</em> Create a C++ function named efficientSort that sorts an array of integers in ascending order. The function should be optimized for time complexity. Provide comments within the function explaining the choice of sorting algorithm and its time complexity.</p>
<p><em>Prompt:</em> 您能否生成一个名为 safeDivide 的 Java 函数，它接受两个双参数（分子和分母）并返回它们的除法？该函数应通过返回自定义错误消息来处理除零。包括解释该函数及其错误处理的 Javadoc 注释</p>
</blockquote>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程，简称 OOP，是一种使用“对象”来表示数据和方法的计算机程序编写方式。可以把它想象成创建一堆小的自包含盒子，每个盒子都有自己的一套工具和信息。这些盒子称为类，类似于创建不同对象的蓝图。类定义了对象的结构和行为——类似于模板。然后从这个类中，可以创建单个对象，每个对象都有自己特定的细节，但遵循相同的基本结构。</p>
<p>深入了解面向对象编程的世界可能会让你感觉像是走进了一个复杂概念的迷宫，比如抽象、继承、封装和多态。它们可能让人觉得像是用外星语言写成的。</p>
<p>这就是ChatGPT可以成为您的翻译器的地方。它将这些复杂的想法分解成易于消化的简明解释。对封装的真正含义感到困惑？只需问一下，您将得到一个实际上有意义的答案，去掉技术术语。</p>
<p>这里有一些提示：</p>
<blockquote>
<p>你能用&lt;你喜欢的编程语言&gt;创建一个简单的类来演示封装吗？</p>
<p>封装在编程中的一些现实世界示例是什么？</p>
<p>用日常生活中的类比来解释 OOP 中的抽象。</p>
<p>提示：你能给我一个编程场景中继承的例子吗？</p>
<p>继承如何促进面向对象编程中的代码重用？</p>
<p>多态如何增强程序的灵活性？</p>
<p>多态性在什么场景中特别有用，您能提供一些例子吗？</p>
</blockquote>
<p>人工智能辅助编程工具也可以帮助生成类的初始结构。以下是一些示例提示：</p>
<ul>
<li><em>Prompt:</em> Design an Employee class with properties like employeeName, employeeID, and department. Implement a method that displays the employee’s details. Also, include a constructor to set these properties.</li>
<li><em>Prompt:</em> I need a BankAccount class in Java. It should have private properties like balance and accountNumber. Can you add methods for deposit(), withdraw(), and checkBalance() that modify or access these properties safely?</li>
<li><em>Prompt:</em> Could you show me how to create a Vehicle class in C# and then a Truck class that inherits from it? Make sure to include properties like wheels and fuelType and demonstrate the use of different access modifiers.</li>
<li><em>Prompt:</em> In C++, how would I write a FileHandler class that opens a file in its constructor and closes it in its destructor? Also, include methods for writeToFile() and readFromFile().</li>
</ul>
<h1 id="框架和库"><a href="#框架和库" class="headerlink" title="框架和库"></a>框架和库</h1><p>在没有框架和库的情况下进行软件开发就像尝试从头开始烘焙一个精美的蛋糕而没有食谱或预混合的材料。这是可能的，但要困难得多，并且需要更多时间。框架和库是让开发者生活更轻松的秘密武器。你不需要每次都重新发明轮子，只需利用现有的资源。</p>
<p>人工智能辅助编程工具确实可以提供帮助。首先，它们可以用于学习基本特性和工作流程。它们还可以告诉你何时最好使用框架或库。</p>
<p>但对他们的帮助要保持谨慎。以下是 Capilnean 的说法：</p>
<blockquote>
<p>鉴于 React 以及其他框架和库的更新数量庞大，并且我们使用特定版本的框架，我不得不将这些作为系统提示提供给我的ChatGPT实例，以优化我的结果。有时，GPT 提供的解决方案更偏向学术而非生产级，因此我倾向于依赖我们的高级开发人员来处理更复杂的问题。对于 React，我发现自己更多是在请 GPT 检查我的语法和处理特定数据类型的方法，而不是实际为我构建完整的功能。</p>
<p>同样适用于 NodeJS。在我去ChatGPT请求某个功能的代码片段之前，我必须考虑我们的内部 API 和处理数据的方法。一旦我能够将我们某个函数的输出描述为我正在构建的功能的输入，它通常能够提供给我稳定的代码。如果输出不好或者出现错误，我在这里使用相同的过程。我提供问题并请求朝正确方向的代码更新。</p>
</blockquote>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>数据是每个应用程序的命脉，确实如此。它是让应用程序生存和运作的关键。就像血液携带氧气和营养物质以维持我们身体的功能，数据在应用程序中流动，为其提供所需的信息和洞察力，使其发挥作用。</p>
<p>但是创建示例数据可能会很繁琐。想象一下：你很兴奋地想测试你崭新的应用程序，但首先，你需要一堆数据来看看它在现实世界中是如何工作的。你开始输入一行又一行的数据——名字、日期、数字，随便什么都行。但是，然后，它就一直在继续。一直在继续。</p>
<p>此外，您必须注意使其足够真实，以便您的测试有效，但又不能详细到为每个条目写小说。如果您需要一个大型数据集？算了吧：您基本上是在报名参加一场复制粘贴、调整和仔细检查的马拉松。</p>
<p>一个人工智能辅助编程工具可以派上用场。但首先，你需要选择一个数据库并创建模式和表。还需要提供表之间的关系。然后你需要进行配置和设置。然后人工智能可以开始提供帮助。</p>
<p>以下是一些提示，以帮助评估数据库：</p>
<blockquote>
<p>提示：哪种类型的数据库最适合处理&lt;特定数据类型或功能，例如用户交互、产品库存等&gt;?</p>
<p>提示：对于预期&lt;高&#x2F;低&gt;流量的应用程序，使用&lt;数据类型，例如：图像、文本、实时数据&gt;，我应该考虑哪个数据库？</p>
<p>提示：我预算有限。你能推荐一个适合小型本地配送服务应用的经济实惠的数据库解决方案吗？</p>
<p>提示：我对数据库管理比较陌生。哪些数据库对初学者友好且易于维护？</p>
</blockquote>
<p>以下是一些请求数据库模式帮助的提示：</p>
<blockquote>
<p>提示：你能帮我设计一个基本的数据库模式用于&lt;应用类型，例如：在线商店，博客&gt;? 我需要知道我应该创建哪些表以及它们之间的主要关系。</p>
<p>提示：在关系数据库中管理&lt;特定类型的数据，例如客户订单，库存&gt;的高效表结构是什么？我应该包含哪些字段和数据类型？</p>
<p>提示：我应该如何定义关系数据库中表之间的关系，以便处理&lt;描述应用程序的功能，例如事件管理、课程注册&gt;? 具体来说，我需要帮助理解外键和连接表。</p>
<p>提示：我正在为&lt;描述项目&gt;设计关系数据库模式。您能指导我如何有效设置主键和外键以确保数据完整性吗？</p>
<p>提示：请问您推荐什么样的规范化策略用于处理&lt;数据类型或应用功能&gt;的数据库？我该如何避免数据冗余并确保数据完整性？</p>
<p>提示：我正在为一个&lt;项目类型，例如社交媒体应用&gt;使用 NoSQL 数据库。我应该如何设计文档结构来存储&lt;特定数据类型，例如用户资料、帖子、评论&gt;?</p>
<p>提示：在设计我的数据库模式时，我应该考虑哪些索引策略来优化查询性能，特别是针对&lt;查询或操作类型，例如，全文搜索，频繁更新&gt;?</p>
<p>提示：我需要将现有数据库迁移到新架构。重新设计数据库结构时需要考虑的关键因素和步骤是什么，以确保数据完整性不丢失？</p>
</blockquote>
<p>以下是设置初始数据库环境的一些提示：</p>
<blockquote>
<p>提示：您能提供在&lt;特定操作系统，例如：Windows，Linux&gt;上安装&lt;特定数据库服务器，例如：MySQL，PostgreSQL&gt;的逐步说明吗？</p>
<p>提示：安装&lt;数据库名称&gt;后，我应该初始设置哪些基本配置以优化性能？</p>
<p>提示：保护&lt;特定数据库&gt;服务器的最佳实践是什么？我特别感兴趣的是用户身份验证和保护敏感数据。</p>
<p>提示：如何优化&lt;特定数据库&gt;的性能，以支持处理&lt;描述数据性质和预期负载，例如，大型数据集，高交易量&gt;的应用程序？</p>
</blockquote>
<p>现在，让我们看看如何使用人工智能创建示例数据。以下是一些示例提示：</p>
<blockquote>
<p>生成 100 个 ID 和邮箱数据的演示数据，并将其保存到 CSV 文件中。</p>
<p>生成 50 个产品的演示数据，包括产品 ID、名称、价格和类别。</p>
<p>创建一个包含 150 条订单记录的演示数据集，每条记录包括订单 ID、客户 ID、订单日期和总金额。</p>
<p>生成 100 名员工的示例数据，包括员工 ID、全名、部门和电子邮件地址。</p>
<p>生成 80 条客户反馈条目的示例数据，包括反馈 ID、客户 ID、评论。</p>
</blockquote>
<p>使用这些数据，您可以为其创建 SQL 语句。您可以使用类似于以下内容的方式来处理客户反馈条目：</p>
<blockquote>
<p>生成一个 SQL 插入语句，将数据填充到反馈表中。</p>
</blockquote>
<p>ChatGPT 在数据转换的细节任务中可以成为救星。如果你是开发者，你知道在不同格式之间转换数据，如 XML、SQL、JSON、CSV 和 TOML 是很常见的。但说实话，这可能是一个乏味且有时容易出错的过程。这就是 ChatGPT 的用武之地。</p>
<p>这里有一些示例提示：</p>
<blockquote>
<p><em>Prompt:</em> Here’s a CSV row: ‘John Doe, 35, New York’. Can you convert this into an XML format for me?</p>
<p><em>Prompt:</em> I have a JSON array like this: [{‘name’: ‘Alice’, ‘job’: ‘Engineer’}, {‘name’: ‘Bob’, ‘job’: ‘Designer’}]. How would I represent this in a SQL table format?</p>
<p><em>Prompt:</em> I need to convert this TOML configuration: ‘title &#x3D; “My Project” owner &#x3D; “Sara”’ into an equivalent YAML format. How would you convert this?</p>
</blockquote>
<h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><p>前端开发涉及使网站看起来美观并顺畅导航。其核心使用 HTML 来设置网页的基本结构，使用 CSS 来美化和布局，使用 JavaScript 来实现交互。如今，前端开发人员通常使用像 React 和 Vue 这样的框架。这些框架提供了可重用组件和实时数据更新的方式，使得构建动态和引人入胜的网站和应用成为可能。</p>
<p>前端开发可能很具挑战性，即使对于经验丰富的开发者也是如此。首先，网页浏览器和用户交互的不可预测性。你需要处理不同的浏览器、设备、屏幕尺寸和用户偏好。这就像试图制作一件适合所有人的 T 恤，且看起来都很好。接下来，前端世界变化很快。框架更新频繁出现。</p>
<p>前端开发还有一点是，它不仅仅是编码。它还涉及良好的用户体验（UX）和用户界面（UI）设计。这是一种许多程序员没有的独特技能组合。UX 和 UI 设计涉及理解人们如何与技术互动，什么使设计在视觉上具有吸引力，以及如何在应用程序或网站中创建流畅、合乎逻辑的流程。这就像既是艺术家又是心理学家。对于很多传统程序员来说，他们可能在算法和数据结构方面很有天赋，但色彩、布局和用户旅程的世界可能是陌生的领域。</p>
<p>无论如何，人工智能辅助编程工具可以提供帮助。我们将在接下来的几个部分中查看其中的一些。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>为网站编写 CSS 可能很棘手，尤其是在处理大型复杂网站时。确保在不同浏览器和设备上看起来都不错是一个挑战。你必须了解所有奇怪的浏览器特定问题。还很容易不小心搞乱某些东西，以至于你样式的一个部分踩到了另一个部分的脚，导致效果看起来很奇怪。此外，传统 CSS 不允许使用变量或函数，这意味着你在代码中会大量重复自己（尽管像 SASS 和 LESS 这样的工具可以帮助解决这个问题）。即使是像居中一个 <div> 这样简单的事情也可能是一场苦战。</p>
<p>以下是一些常见 CSS 任务的提示：</p>
<blockquote>
<p>提示：你能给我提供一个响应式导航栏的 CSS 代码片段，在移动设备上折叠成汉堡菜单吗？</p>
<p>提示：我在 CSS 的弹性盒布局中遇到问题，项目没有正确对齐。你能建议可能出错的地方吗？</p>
<p>提示：我需要为我网站上的按钮添加悬停效果。你能给我一个 CSS 示例，让按钮在悬停时改变颜色吗？</p>
<p>提示：我想在我网站的首页添加一个淡入动画。你能提供一个 CSS 代码片段吗？</p>
</blockquote>
<h2 id="创建图形"><a href="#创建图形" class="headerlink" title="创建图形"></a>创建图形</h2><p>创建专业的网站或应用程序图形需要丰富的设计背景，以及对像 Photoshop 这样的复杂工具的理解。但有很多强大的文本生成图像的人工智能系统可以帮助你创建出色的图像。其中一些系统包括：</p>
<ul>
<li> Canva</li>
<li>Stable Diffusion</li>
<li>DALL·E 3（内置于ChatGPT）</li>
<li> Adobe’s FireFly</li>
<li> Midjourney</li>
</ul>
<p>使用这些系统，您可以创建多种类型的资产，包括主图像、按钮和徽标。</p>
<p>让我们看一个例子。我们将让ChatGPT创建一个徽标：</p>
<blockquote>
<p><em>Prompt:</em> I’m creating a website for my home bakery business named “Sweet Whisk.” I want a logo that’s warm and inviting. The main products are cakes and cookies, so maybe those could be incorporated into the design. I like pastel colors, especially light pink and mint green. The style should be simple and modern, with a touch of <strong>playfulness</strong>.</p>
</blockquote>
<p>图 8-6 显示了ChatGPT创建的内容。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0806-20240829151932-b2xksvc.png"></p>
<p> 图 8-6. ChatGPT 在给定一些指导方针时创建了一个徽标</p>
<p>如果您想对输出进行更改，可以继续提示ChatGPT。其他人工智能图像工具，如 Firefly，具有比ChatGPT更多的图像设计功能，但ChatGPT仍然可以创建引人注目的图像——无需太多工作。</p>
<h2 id="人工智能工具"><a href="#人工智能工具" class="headerlink" title="人工智能工具"></a>人工智能工具</h2><p>有一些优秀的人工智能工具可以根据提示或您想要的前端外观图片快速生成网站。它们会为您处理所有编码。这甚至包括转换为 React、Angular 和 Vue 等框架。此外，人工智能工具通常还能够导入线框，例如来自 Figma 的线框。</p>
<p>代码创建后，您可以进入并调整内容以达到最佳效果。使用人工智能是加快整个网站构建过程的有效捷径。</p>
<p>以下是一些可用的人工智能工具：</p>
<ul>
<li> TeleportHQ</li>
<li> Anima</li>
<li>Locofy</li>
<li> v0 by Vercel</li>
</ul>
<p>让我们仔细看看 Vercel 的 v0，它易于使用。实际上，界面类似于 ChatGPT，如图 8-7 所示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0807-20240829151933-go70zoc.png"></p>
<p> 图 8-7. 这是 Vercel 的 v0 接口</p>
<p>您可以输入您希望系统创建的接口类型的提示或上传一张图片。对于这个例子，我将使用一个提示：</p>
<blockquote>
<p>电子商务仪表板，带侧边导航和最近订单表格。</p>
</blockquote>
<p>这将带您进入设计工作室，类似于图 8-8。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0808-20240829151933-068po2k.png"></p>
<p> 图 8-8. 当你输入提示时，Vercel 提供的 v0 设计工作室</p>
<p>人工智能将创建三个仪表板版本。您也可以创建其他版本。然后，通过提示，您可以进行更改，例如文本大小、颜色等。</p>
<p>完成后，您可以点击右上角的代码。您将看到基于 shadcn&#x2F;ui 和 Tailwind CSS 的干净 React 代码列表。</p>
<p>还有几个使用人工智能生成前端的开源系统。考虑截图转代码。该项目的创建者是 Abi Raja，他是 Pico 的首席执行官和创始人。他之前的创业公司于 2013 年被雅虎收购。</p>
<p>拉贾花了六个月时间创建 Screenshot to Code 的初始代码库。“前端开发人员通常将设计和模型转换为代码，”拉贾说。“这项工作大部分是重复的。但我的软件可以帮助自动化这个过程，完成大约 90%的任务。”</p>
<p>目前，截图转代码支持导出到 React、Bootstrap 和 HTML&#x2F;Tailwind CSS。该项目在 GitHub 上拥有超过 31,000 个星标。</p>
<p>使用ChatGPT，您还可以将图像转换为代码。假设您想创建一个计算器应用程序，并希望它看起来像 iPhone 上的版本。图 8-9 显示了该图像。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0809-20240829151933-sm5dma8.png"></p>
<p> 图 8-9 您可以将 iPhone 计算器应用的图像输入ChatGPT以生成代码</p>
<p>首先，我们将请求ChatGPT识别图像，它会正确识别。然后我们可以使用这个提示：</p>
<blockquote>
<p>提示：为此图像建议代码</p>
</blockquote>
<p>图 8-10 显示了计算器。</p>
<p>ChatGPT 创建了 Python 代码。没错，样式有些不对，但这仍然相当不错。当然，如果你想让它看起来更像 iPhone 版本，你可以在提示中更具体，比如告诉 ChatGPT 使用类似 React 的东西。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0810-20240829151934-9sofry9.png"> 图 8-10. ChatGPT 根据苹果 iPhone 应用的图像创建计算器代码</p>
<h1 id="API-接口"><a href="#API-接口" class="headerlink" title="API 接口"></a>API 接口</h1><p>掌握一个新的 API 可能是个挑战。首先，你得浏览文档，这些文档可能很复杂且技术性强。而且这些文档的质量参差不齐——有些清晰易懂，而有些则不然。然后就是登录和获取访问权限的问题，比如使用 API 密钥或 OAuth 令牌。此外，试图弄清楚 API 返回的数据结构和响应格式可能会让人不知所措。还有错误处理，以及需要跟上 API 的任何更新或更改。</p>
<p>幸运的是，使用ChatGPT可以让应对这些挑战变得简单一些。</p>
<p>查看一下，举个简单的例子。假设你想使用 API 获取天气信息。你可以向ChatGPT请求 API 建议：</p>
<blockquote>
<p>好的天气 API 有哪些？</p>
</blockquote>
<p>一个推荐的是开放天气 API。接下来，问以下问题：</p>
<blockquote>
<p>如何开始使用 OpenWeather API？</p>
</blockquote>
<p>ChatGPT描述了主要步骤。</p>
<p>您可以让它展示如何发出请求：</p>
<blockquote>
<p>如何使用 OpenWeather API 创建请求？我该如何使用 Python 做到这一点？</p>
</blockquote>
<p>ChatGPT 将经过该过程，提供这些步骤的详细信息：</p>
<ul>
<li>导入 requests 库。</li>
<li> 定义 API 密钥。</li>
<li>创建 API 请求 URL 并使用当前天气数据端点。</li>
<li>执行请求并处理响应。</li>
<li>检查请求是否成功。</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本章中，我们深入探讨了模块化编程、函数和面向对象编程。我们还研究了如何使用人工智能快速学习新语言和框架，以及如何利用它更高效地处理数据。然后我们看到了如何创建引人注目的前端。</p>
<p>但重要的是要重复：人工智能辅助编程工具远非完美。因此，保持警惕并仔细检查所有内容是很重要的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/13/aiassistedprogramming07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/aiassistedprogramming07/" class="post-title-link" itemprop="url">第7章  想法、规划和需求</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-13T11:48:32+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 11:55:46" itemprop="dateModified" datetime="2024-09-26T11:55:46+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在本章中，我们将深入探讨软件开发的重要早期阶段。这是所有酷炫想法变为现实的地方，也是我们规划它们以便准备就绪的地方。我们将使用ChatGPT有效地头脑风暴，并将事情规划到最后的细节。我们将查看市场调研，关注趋势，并检查竞争对手。我们还会讨论白板，这是一种有趣的可视化方式来交流想法并使其更好。此外，我们将深入研究如何规划您的项目，查看敏捷和 Scrum 等方法，以及如何调整它们以适应您的软件项目。</p>
<h1 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h1><p>每天都有成千上万的软件产品出现，因此制作一些真正出色并脱颖而出的东西并不是一件容易的事。但是有了LLM像ChatGPT，你可以进行一些头脑风暴。</p>
<p>首先，您可以让它提供不同的方法。这里有一个提示：</p>
<blockquote>
<p>头脑风暴新产品创意的技巧是什么？使用互联网研究这个问题。</p>
</blockquote>
<p>ChatGPT 提供了 10 种有用的方法——以下是其中的一些：</p>
<blockquote>
<p>5 个为什么：你从一个问题开始，不断问“为什么”会发生。它有助于回顾并找出哪里出错。</p>
<p>糟糕的主意：故意想出一堆糟糕的主意。讨论它们为什么这么糟糕实际上可以激发聪明的解决方案。</p>
<p>星爆法：这是关于问题，而不是答案。你使用星形图表，并用问题来打击它，比如：谁，什么，什么时候，在哪里，为什么和如何。</p>
</blockquote>
<p>假设您想使用星爆法。您可以通过以下提示了解更多信息：</p>
<blockquote>
<p>星爆法：你将如何使用星爆法来提出一个新的软件产品创意？</p>
</blockquote>
<p>ChatGPT 对该主题应用的星爆练习进行了简单明了的分解：</p>
<blockquote>
<p>谁：考虑一下谁将使用你的软件。</p>
<p>什么：了解您的软件解决了什么问题。它与现有的有什么不同？</p>
<p>何时：找出使用您的软件、启动它以及进行更新或修复的最佳时间。</p>
<p>在哪里：人们可以在什么平台或设备上使用该软件？</p>
<p>为什么：深入探讨为什么您的软件是必备的。为什么人们应该选择它而不是其他软件？</p>
<p>如何：考虑您的软件将如何工作，您将如何构建和销售它，以及当用户需要帮助时您将如何照顾他们。</p>
</blockquote>
<p>通过这个过程可以更清晰地了解您的新软件产品想法。</p>
<p>现在，假设你想列出一些想法。最好集中在一个特定类别，了解你的目标对象，并明白你想解决什么问题。以下是一些提示，帮助你开始：</p>
<blockquote>
<p>我想开发一款老年人健康追踪应用。问题在于他们在监测慢性病和用药时间表方面面临的困难。可以包含哪些功能以使应用更适合老年人并更有效地帮助管理他们的健康？</p>
<p>预算应用应该包含哪些功能，以帮助大学生跟踪支出、节省资金并轻松理解财务规划？</p>
<p>我想创建一个语言学习应用程序，针对忙碌的专业人士，他们很难找到时间上常规课程。你能建议一些适合他们紧张日程的功能，并提供快速有效的语言学习课程吗？</p>
</blockquote>
<p>ChatGPT产生的想法有多好？好吧，一些沃顿商学院的教授在他们的 MBA 创新课程中进行了测试。他们让学生提出十几个产品或服务的想法。然后，他们对ChatGPT做了同样的事情，利用 GPT-4 模型。提出的想法包括适合宿舍的厨师工具包和适合那些硬课堂座椅的舒适垫子。</p>
<p>为了测试这些想法，教授们使用了一项在线购买意向调查。问题是：“如果这个概念对你可用，你购买的可能性有多大？”</p>
<p>平均而言，大约 40%的学生想法相当扎实，而ChatGPT稍微高一些，达到了 49%。但教授们并没有就此止步。他们专注于前 10%的想法。这些才是真正有潜力成为游戏规则改变者的想法。你猜怎么着？在 40 个顶尖想法中，只有 5 个来自学生。</p>
<h1 id="市场调研"><a href="#市场调研" class="headerlink" title="市场调研"></a>市场调研</h1><p>在开始一个软件项目之前，问几个关键问题是明智的：这个工具真的有必要吗？客户愿意为此支付现金吗？这个市场有多大？</p>
<p>这就是进行市场调研。当然，这不是水晶球，但它确实有助于降低将时间和精力投入到可能不会成功的事情上的风险。</p>
<p>事实上，很多新产品都失败了。哈佛教授、畅销书作者克莱顿·克里斯滕森对此进行了大量研究，发现大约 80%的新产品都不成功。</p>
<p>表 7-1 列出了一些最 notable 的例子。</p>
<p>表 7-1. 失败的软件应用程序</p>
<table>
<thead>
<tr>
<th>产品&#x2F;服务</th>
<th>启动年份</th>
<th>失败原因</th>
</tr>
</thead>
<tbody><tr>
<td>Friendster</td>
<td>2002</td>
<td>技术问题，扩展性问题，被 Facebook 超越</td>
</tr>
<tr>
<td>Microsoft Zune</td>
<td>2006</td>
<td>未能与 iPod 竞争，改变音乐市场动态</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>高系统要求，兼容性问题，安全提示</td>
</tr>
<tr>
<td>Google Wave</td>
<td>2009</td>
<td>复杂的界面，不明确的目的，缺乏用户采用</td>
</tr>
<tr>
<td>谷歌+</td>
<td>2011</td>
<td>大量错误，不准确的数据，导航能力差</td>
</tr>
<tr>
<td>Vine</td>
<td>2013</td>
<td>被 Instagram 和 Snapchat 等竞争对手 overshadowed</td>
</tr>
<tr>
<td>Amazon Fire Phone</td>
<td>2014</td>
<td>高价格，应用选择有限，功能不吸引人</td>
</tr>
<tr>
<td>Quibi</td>
<td>2020</td>
<td>短视频内容格式未被接受，竞争激烈，COVID-19 影响</td>
</tr>
</tbody></table>
<p>史蒂文·斯皮尔伯格 1982 年电影《外星人 E.T.》的视频游戏是最惨痛的失败之一。雅达利花费了 2100 万美元购买环球影业的版权，又花了 500 万美元进行推广。</p>
<p>这款游戏真的失败了。它非常 confusing，也不好玩。那么，发生了什么？雅达利只卖出了约 150 万台。剩下的 250 万台最终被丢弃在新墨西哥的垃圾填埋场。</p>
<p>让我们深入探讨如何使用ChatGPT进行市场调研。首先，我们需要确定目标受众。想想谁会从这款软件中获得最大的收益。让我们开始头脑风暴一下这些用户可能是谁。考虑这个提示：</p>
<blockquote>
<p>项目管理软件程序的潜在目标人群是什么？</p>
</blockquote>
<p>您可以让ChatGPT承担一个对了解您的营销很重要的任务：创建详细的用户画像。将这些画像视为角色，它们为您提供可能使用您产品的不同类型人群的快照。细节通常包括他们的年龄、兴趣、职业和生活方式。通过绘制这些画像，您开始了解您的客户是谁以及他们在寻找什么。</p>
<p>我向ChatGPT请求了一些管理软件的用户画像，您可以在图 7-1 中看到它的一些响应。</p>
<p>ChatGPT 还可以用于编写调查和问卷以收集特定数据。</p>
<blockquote>
<p>调查问卷：您能否创建一份调查，重点了解买家在项目管理软件中寻找什么？调查应包括帮助识别关键功能、可用性偏好、特定行业需求以及买家希望通过此类软件解决的任何特定挑战的问题。此外，请包括评估成本、支持、可扩展性和集成能力等因素重要性的问题。</p>
</blockquote>
<p>让我们看看在评估软件市场时需要考虑的一些其他因素。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0701-20240829144157-at3ii9v.png"></p>
<p> 图 7-1. ChatGPT 为管理软件创建的用户角色</p>
<h2 id="市场趋势"><a href="#市场趋势" class="headerlink" title="市场趋势"></a>市场趋势</h2><p>在推出新软件时，深入市场调研可以带来很大差异。这就像获取用户真正想要的内部信息，同时也让你了解竞争对手的动态。把它看作你的秘密手册。你可以在趋势爆发之前发现它们，以及其他人可能错过的机会。此外，这也是一个很好的安全网。它减少了猜测，帮助你做出更有可能成功的明智选择。还有，别忘了营销。深入了解你的受众意味着你可以创建与他们产生共鸣的广告和促销，而不是随便发布内容希望能引起关注。</p>
<p>ChatGPT 可以成为您市场调研的好助手。当然，该模型仅训练到某个日期，但有一个变通方法：您可以在提示中告诉它“研究互联网”。</p>
<p>这里有一些例子：</p>
<blockquote>
<p>研究互联网以查找截至&lt;年份&gt;的&lt;特定软件类别，例如移动游戏、教育技术&gt;的当前趋势。</p>
<p>研究互联网以提供&lt;年份&gt;软件行业新兴技术的概述</p>
<p>研究互联网以寻找当前影响软件市场的消费者行为趋势，特别是在&lt;目标人群或应用类型&gt;。</p>
<p>研究互联网以寻找&lt;年份&gt;软件应用程序用户界面和用户体验（UI&#x2F;UX）设计的最新趋势。</p>
<p>研究互联网，列出在&lt;特定领域&gt;中最优秀的软件应用程序，并解释它们在当前市场上成功的原因。</a></p>
</blockquote>
<h2 id="可寻址市场总量"><a href="#可寻址市场总量" class="headerlink" title="可寻址市场总量"></a>可寻址市场总量</h2><p>可寻址市场总量，简称 TAM，是对如果所有可以使用您的产品的人都实际使用它时您可能赚取的最大金额的估计。这有助于您确定精力集中在哪里，如何在市场中定位您的产品，以及您的增长计划应该是什么。这是一个现实检查，帮助您设定可实现的目标，了解您可以占据市场的份额和可以带来的现金。</p>
<p>风险投资者（VC）在考虑投资时非常重视市场总量（TAM），因为这显示了增长潜力。他们总是在寻找投资能够起飞的地方，而较大的市场总量意味着有一个巨大的市场等待开发。</p>
<p>通常，风险投资公司寻找超过十亿美元的市场总量——理想情况下远远超过这个数字。毕竟，即使一家公司只占据了这样一个巨大市场的一小部分，利润也可能相当可观。</p>
<p>估算总可寻址市场规模的不同方法有哪些？</p>
<blockquote>
<ul>
<li>自上而下的方法：您收集行业数据和市场研究，以了解整个市场规模。然后，您稍微缩小范围，例如专注于您目标市场的部分。</li>
<li>自下而上的方法：你估算可能购买你产品的人或企业数量，猜测其中有多少人会实际购买（你的转化率），然后考虑每个客户能带来多少收益。这种方法需要更多的工作，但可以给你一个更清晰、更量身定制的图景。</li>
</ul>
</blockquote>
<p>让我们举个例子。假设你有一个医疗技术类别的初创公司：</p>
<blockquote>
<p>银连健康是一家专注于远程医疗服务的健康科技初创公司。目标市场在美国，重点关注城市地区的老年人群体。银连健康目前的远程医疗服务市场规模是多少？预计未来 5-10 年该市场细分的增长率是多少？</p>
</blockquote>
<p>ChatGPT 搜索互联网并得出一些有用的事实：</p>
<blockquote>
<ul>
<li>2022 年市场规模：美国远程医疗市场在 2022 年的估值超过 350 亿美元。另一个估计将远程医疗市场规模定为 912 亿美元。</li>
<li>预计增长率：有一个估计表明 2023 年至 2032 年的年均复合增长率（CAGR）为 12.5%。另一个来源预测 2023 年至 2030 年的 CAGR 为 22.9%。</li>
</ul>
</blockquote>
<h1 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h1><p>竞争分析有几个关键好处。首先，它让你提前了解市场。你可以看到已经存在的产品，哪些有效，哪些无效。这帮助你发现你的软件可以填补的空白，确保你带来一些新鲜的东西。</p>
<p>然后，从竞争对手那里学习——无论是他们的胜利还是失误时刻。这真的可以提升你的水平。</p>
<p>此外，当你知道是什么让你的软件与众不同时，你可以更具体地进行营销，更有效地触及正确的人群。</p>
<p>关于ChatGPT，它可以帮助进行竞争分析。以下是一些提示：</p>
<blockquote>
<p>列出&lt;您的软件类型&gt;在&lt;特定行业或市场&gt;的主要竞争对手。</p>
<p>比较&lt;你的软件&gt;与其前三大竞争对手的功能。</p>
<p>竞争对手在市场上使用的&lt;你的软件&gt;定价模型是什么？</p>
<p>领先竞争对手如何在&lt;软件类型&gt;市场中定位自己？</p>
<p>识别&lt;竞争对手名称&gt;软件的优缺点。</p>
<p>总结&lt;竞争对手软件名称&gt;的客户评价，重点关注用户满意度和痛点。</p>
</blockquote>
<p>您也可以让ChatGPT将分析放入表格中，这样可以更清晰：</p>
<blockquote>
<p><em>Prompt:</em> Can you provide a summary in bullet points of the key players in the customer relationship management (CRM) software market as of 2023? Put the results in a table.</p>
</blockquote>
<p>图 7-2 显示了响应。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0702-20240829144157-h1q4f9s.png"></p>
<p>图 7-2. ChatGPT 提供了 CRM 市场的竞争分析并以表格格式呈现</p>
<p>ChatGPT 甚至可以进行 SWOT（优势、劣势、机会和威胁）分析。这有助于你突出自己的强项，修复或规避弱点，把握出现的机会，躲避任何意外情况。各种类型的企业都在使用它，甚至对个人职业发展也很有帮助。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>需求文档对软件开发至关重要。以下是它们的一些好处：</p>
<ul>
<li> 给你指引：这些文档明确了软件应该做什么。每个人，从开发人员到客户，都了解计划是什么，这使事情保持在正轨上。</li>
<li>让每个人保持一致：他们确保所有相关人员，比如你的团队和客户，理解预期的内容。这样，混淆或错误的可能性就会减少。</li>
<li> 帮助规划：需要弄清楚事情需要多长时间或花费多少吗？这些文档是您规划工作、时间和所需资金的首选。</li>
<li> 改善沟通：它们非常适合清晰沟通，特别是在大型团队或人员分布在不同地理位置时。</li>
<li> 降低风险：及早发现潜在问题？这就是这些文档帮助您做到的，以便您可以避免延误并控制成本。</li>
</ul>
<p>当然，提出软件需求并不容易，主要原因是软件开发可能会变得复杂。然后还有协调工作和考虑许多团队成员的挑战，他们可能在其他国家和时区。每个小组都有自己的想法和需求，有时这些并不完全匹配或不够清晰。</p>
<p>另一个头疼的问题是，人们对软件的需求可能会不断变化。尤其是在快速发展的行业中，这一点尤为明显。因此，你经常需要在不断变化的目标上进行调整，这使得很难确定一个稳定的方案。同时，你还必须确保这些需求是可行的，并且能够验证它们是否得到了满足。</p>
<p>当需求不准确时，结果可能会很糟糕。以下是一些例子：</p>
<ul>
<li>丹佛国际机场自动行李系统（1995）：需求复杂得令人头痛，目标过于雄心勃勃。这导致了 16 个月的延迟和成本飙升。最后，机场决定放弃整个系统。</li>
<li>联邦调查局虚拟案件档案系统（2000–2005）：联邦调查局对自己想要什么只有模糊的概念。因此，系统最终并没有太大用处。最后，该机构在这个项目上投入了超过 1.7 亿美元，却最终放弃了。下一个项目，名为哨兵，具有更具体的要求，当然也更成功。</li>
<li>医疗保健.gov 上线（2013）：联邦政府没有确定所需内容，也没有进行足够的测试，因此在启动时无法处理流量，运行不正常。启动失败，很多人不得不投入更多的工作和资金来修复并使其顺利运行。</li>
</ul>
<p>在软件开发的世界中，有一系列不同的需求，每个需求都有其独特的目的。你有功能性需求，列出了软件应该做什么，比如它应该执行的任务或需要的功能。然后是非功能性需求，这些是关于软件应该如何运行的，比如性能速度、安全性和可用性。</p>
<p>探索生成式人工智能如何提供帮助，我们将重点关注两种重要文档：产品需求文档（PRD）和软件需求规格说明（SRS）。</p>
<h2 id="产品需求文档"><a href="#产品需求文档" class="headerlink" title="产品需求文档"></a>产品需求文档</h2><p>产品需求文档（PRD）规定了您的软件将是什么以及将做什么。可以将其视为一个故事，概述应用程序应该是什么样子、应该如何表现、谁将使用它以及它将解决什么问题。它通常很详细，涵盖从必备功能到用户体验的所有内容。</p>
<p>PRD 的受众是多样化的。它面向开发人员、设计师、项目经理和质量保证团队。对于需要理解产品愿景和目标的高管或其他利益相关者也至关重要。此外，它对营销团队了解如何定位产品也很有用。基本上，它是为任何参与将产品推向市场并确保其满足预期用户需求的人准备的。</p>
<p>如果您还没有看到 PRD，ChatGPT可以提供帮助：</p>
<blockquote>
<p>产品需求文档主要部分是什么？创建一个 Word 文档作为模板。</p>
</blockquote>
<p>图 7-3 显示生成的文档ChatGPT。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0703-20240829144158-le0lw22.png"></p>
<p> 图 7-3. ChatGPT 创建了一个 PRD 示例大纲</p>
<h2 id="软件需求规格说明书"><a href="#软件需求规格说明书" class="headerlink" title="软件需求规格说明书"></a>软件需求规格说明书</h2><p>SRS 与 PRD 有什么不同？SRS 就像软件项目的详细技术手册。与从最终用户或客户的角度出发、关注他们需要什么以及为什么的 PRD 不同，SRS 深入探讨软件需要做什么以及如何做到这一点，侧重于技术方面。</p>
<p>如果你有一个简单的应用程序，软件需求规格说明书可能只有几页。但对于更复杂的项目，比如企业软件实施，它可能会达到数百页。</p>
<p>让我们看一些提示：</p>
<ul>
<li>Prompt: What are the essential elements and best practices to consider when drafting an effective SRS?</li>
<li>Prompt: Outline the process for developing an SRS, emphasizing the steps involved in gathering and analyzing requirements, stakeholder collaboration, and documentation methodologies.</li>
<li>Prompt: Create a detailed SRS for a software project, including sections like Project Overview, Stakeholder Analysis, Functional and Non-functional Requirements, Assumptions, and Constraints. <Add the details you want for each.></li>
</ul>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>语音识别软件已经存在几十年，但大多数时候，它更像是一种新奇事物，而不是实用工具。通常，它在日常使用或专业环境中并不实用，因为它无法可靠地理解自然的对话语音。</p>
<p>然而，在过去几年中，语音识别取得了飞跃式发展，这得益于人工智能的进步。现代系统由复杂的人工智能算法驱动，不仅更擅长理解各种口音和方言，还能把握口语的上下文和细微差别。这些系统随着时间的推移不断学习和适应，持续提高其准确性。</p>
<p>一个有帮助的方法是在您经常进行的面试中整理需求文档。</p>
<p>例如，通过语音识别软件，您可以改善以下内容：</p>
<ul>
<li> 准确性和回放：虽然转录准确率通常很好，但您可以使用回放进行更正。</li>
<li> 说话人识别：语音识别可以区分会议中的发言者。这可以帮助明确需求。</li>
<li>关键主题识别：语音识别软件可以在 transcripts 中突出显示频繁的关键词，使识别和关注主要主题或需求变得更容易。</li>
<li> 关键点摘要：语音识别软件可以生成关键点摘要并建议行动项，帮助开发人员确定关键需求并将其转换为具体项目任务。</li>
</ul>
<p>一些顶尖的语音识别软件系统包括：</p>
<ul>
<li> Otter AI</li>
<li> Fathom</li>
<li> Rev</li>
<li> Sonix</li>
<li> Notta</li>
</ul>
<h2 id="白板协作"><a href="#白板协作" class="headerlink" title="白板协作"></a>白板协作</h2><p>白板是整理软件项目需求时常见的做法。它可以帮助头脑风暴过程，让每个人都能参与进来。它允许收集很多不同的想法和观点，这对于明确软件应该做什么至关重要。它也是动手的——你可以在讨论期间绘制流程图或图表，使复杂的内容更容易理解。</p>
<p>好吧，ChatGPT可以帮助解决这个问题。怎么做？它可以解读您上传到系统的图像。</p>
<p>例如，假设您勾勒出一个登录系统，如图 7-4 所示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0704-20240829144200-gjh6sln.png"></p>
<p>图 7-4. 登录系统的示意图</p>
<p>如您所见，我的 handwriting 有点乱。我还使用缩写，例如“pw”表示“密码”。</p>
<p>让我们看看ChatGPT能否弄明白。我使用了这个提示：</p>
<blockquote>
<p>Prompt：分析图表。</p>
<p>ChatGPT：您上传的图表似乎是与用户账户管理相关的流程图，特别是网站或应用程序的登录过程。</p>
</blockquote>
<p>然后列出了整个过程（图 7-5）。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0705-20240829144201-8lr8765.png"></p>
<p> 图 7-5. ChatGPT 分析了登录系统的图示图像，将其转换为易于阅读的工作流程细分</p>
<h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h2><p>编写有效的 PRD 和 SRS 是一门艺术。重要的是要把握正确的风格。这些文档应该清晰、简洁和专业。</p>
<p>让我们分析一下写作风格为何重要：</p>
<ul>
<li> 清晰明了：这些文档就像你项目的圣杯。你希望一切都准确无误，以便每个人都能了解发生了什么。这样，你就可以避免那些恼人的沟通错误和开发失误。</li>
<li> 坚持事实：PRD 和 SRS 不是个人风格展示的地方。你需要像新闻记者一样——只需事实。保持简洁和中立确保你专注于产品真正需要的内容。</li>
<li> 一致性是关键：您希望始终保持相同的语气。把它当作遵循食谱。如果您在中途开始更改内容，最终会变得一团糟。一致性使这些通常较长的文档更易于理解。</li>
<li>保持对产品的关注：请记住，产品及其预期功能才是这里的主角。保持直接的语气可以确保您不偏离主要内容——即功能和需求。</li>
</ul>
<p>当涉及到LLM像ChatGPT时，写作是它的强项之一。它真的可以提升你的水平。是的，你可以指示LLM把握正确的语气，就像这个提示：</p>
<blockquote>
<p><em>Prompt:</em> Please draft a comprehensive list of technical requirements for a mobile banking app, ensuring the writing is clear, well structured, and professional.</p>
</blockquote>
<p>市场上有很多人工智能写作工具，每个工具都有其独特的功能，以适应您所需的写作类型。例如，Jasper 和 Writer 非常适合生成内容并保持品牌声音的一致性。然后是 Grammarly，它是确保语法正确和提升写作风格的首选工具。AI21 和 Copy.ai 也在其中，使内容创作变得轻而易举。</p>
<p>考虑吉亚萨·格罗弗，她在项目中使用 Grammarly。作为机器学习专家，她写了一本关于该主题的书，名为《为机器学习雕刻数据》（2021）。根据她的说法：</p>
<blockquote>
<p>Grammarly 是另一个帮助我撰写技术设计文档的工具。我利用它进行校对、语法、标点和风格建议。它与许多网页浏览器和文字处理软件无缝集成。语言表达清晰简洁，甚至根据目标受众和文档目的定制建议。</p>
</blockquote>
<h1 id="项目规划方法"><a href="#项目规划方法" class="headerlink" title="项目规划方法"></a>项目规划方法</h1><p>在整理完需求后，下一步是规划如何进行项目。这是关于制定团队如何处理软件创建过程的计划。涉及设定明确的目标，弄清楚需要做什么，谁在做什么，何时进行，以及如何进行。主要目标是保持事情顺利进行，确保每个人都高效，并最终拥有一个能够按预期工作并让所有人，特别是客户，满意的产品。</p>
<p>现在，软件开发的世界确实很复杂，因此团队可以有很多不同的方式来规划他们的项目。它们各自有不同的策略，每个策略都有自己的规则和步骤，以帮助人们处理任务，应对任何变化，保持质量，并向客户交付出色的成果。因此，无论您的团队需要详细说明所有内容，还是更喜欢一种可以随时更改的灵活计划，总有一种方法适合您。</p>
<p>一些常见的项目规划方法包括瀑布模型、敏捷、Scrum、看板和极限编程（XP）。选择正确的方法很重要，因为这可能决定你的项目成败。你的选择取决于很多因素，比如项目的规模和复杂性、客户的需求、团队的协作方式，以及项目环境中事情的确定性或不确定性。有些团队可能坚持一种方法，但其他团队可能会混合搭配，以找到最适合他们项目的方法。</p>
<p>关于提示，我们举个例子。假设你正在构建一个“待办事项”应用。你已经为它创建了一份单页需求文档，现在你问ChatGPT：</p>
<blockquote>
<p>该应用的最佳项目规划方法是什么？</p>
</blockquote>
<p>ChatGPT 建议敏捷方法作为最佳选择并提供理由（图 7-6）。</p>
<p>这里有一些你可能会使用的其他提示：</p>
<blockquote>
<p>团队如何有效选择和定制适合其特定软件项目的项目规划方法？</p>
<p>讨论将项目规划方法与软件项目的目标和复杂性对齐的重要性。</p>
<p>瀑布模型在软件项目管理中的顺序阶段解释。</p>
<p>敏捷开发方法的核心原则</p>
<p>敏捷方法如何促进项目的灵活性和客户参与？</p>
<p>概述 Scrum 框架中的角色和仪式。</p>
<p>比较和对比 Scrum 与传统项目管理方法。</p>
<p>极限编程的关键实践及其对客户满意度的贡献。</p>
<p>讨论作为极限编程一部分的测试驱动开发的好处和挑战。</p>
</blockquote>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0706-20240829144202-82jigj1.png"><br> 图 7-6. ChatGPT 解释了为什么敏捷是某个应用程序开发的最佳方法</p>
<h2 id="测试驱动开发（TDD）"><a href="#测试驱动开发（TDD）" class="headerlink" title="测试驱动开发（TDD）"></a>测试驱动开发（TDD）</h2><p>在开始编码之前，最聪明的做法之一是列出你的测试用例。记住老话“量两次，切一次”？这是个好建议。在深入之前，你需要做好准备。一种常见的方法是测试驱动开发（TDD）。</p>
<p>这里是关键：当你坐下来思考你的代码需要通过的所有测试时，你会更好地理解你需要构建的内容。在开始构建之前，你仔细查看了蓝图。这样，你就确切知道你的代码应该做什么，这可以让你避免后续很多困惑。</p>
<p>更重要的是，先规划测试意味着你从一开始就考虑到将使用你软件的用户。你不仅仅是在代码中迷失。你专注于制作对用户有用的东西。提前发现潜在的问题总比后来为修复错误而抓狂要好。</p>
<p>在测试驱动开发中，这种方法是整个过程的核心。你在编码之前编写测试，这意味着你始终关注代码需要实现的目标。这种方法导致代码更简洁、更直接，因为你总是带着目的进行编码。</p>
<p>通过测试驱动开发（TDD），我们有工具包用于编写测试的不同方式：</p>
<ul>
<li> 给定-何时-然后(GWT)：给定是设置场景，比如在行动开始之前一切都在哪里。然后进入何时阶段，主要事件开始推动事情发展。最后以然后结束，说明在尘埃落定后你期望发生的事情。这就像讲述你的代码将执行的故事。</li>
<li> 安排-执行-断言（AAA）：这类似于 GWT。但 GWT 更倾向于叙述和以用户为中心，使其非常适合开发人员、测试人员和非技术利益相关者之间的协作。而 AAA 则更多地关注测试本身的技术执行。</li>
<li>设置-执行-验证-拆除（SEVT）：这是您在集成和系统测试中必备的工具。您从设置开始，准备测试环境。然后，进入执行阶段，运行系统进行测试。之后，您进入验证阶段，在这里您扮演侦探确认一切正常。最后别忘了拆解。这是清理步骤，对于下次保持一切整洁至关重要。</li>
</ul>
<p>这是一个使用 GWT 的 TDD 提示示例：</p>
<blockquote>
<p>提示：使用给GWT方法制定关键功能的测试方法。具体要求包括：</p>
<ul>
<li>开发一个精品酒店连锁的在线预订系统。</li>
<li>系统必须从每个酒店的内部管理软件中提取房间可用性数据。</li>
<li>应该允许用户按日期、价格和设施筛选房间。</li>
<li>界面需要直观，并兼容桌面和移动浏览器。</li>
<li>系统应使用基于云的解决方案构建，以确保可靠性和可扩展性。</li>
</ul>
</blockquote>
<p>TDD 通常还关注需要测试的特定场景或用例。以下是几种可能有用的提示类型：</p>
<blockquote>
<p>编写测试以允许用户通过电子邮件验证重置密码的功能。</p>
<p>创建测试以验证数据库连接失败时系统的响应。</p>
<p>开发测试以确保在正常负载条件下搜索功能在 2 秒内返回结果。</p>
<p>编写测试以检查所有用户数据在存储时是否被加密。</p>
<p>设计测试以验证支付网关与订单处理系统之间的集成。</p>
</blockquote>
<h2 id="网页设计规划"><a href="#网页设计规划" class="headerlink" title="网页设计规划"></a>网页设计规划</h2><p>规划网站或网络应用程序可能很复杂，并涉及多个步骤。首先，您需要了解网站的目标和目标用户。然后，您将勾勒出网站的蓝图，并计划用户的移动方式。这通常被称为原型或线框。</p>
<p>之后就是通过选择颜色、字体和炫酷的图形来美化它，展示品牌的本质。当然，你需要一些吸引人的文字和酷炫的图片或视频来讲述你的故事。接下来是技术部分，你需要使用 HTML、CSS 和 JavaScript 等语言将这些想法转化为一个真实的、可运行的网站。</p>
<p>当然，像ChatGPT这样的工具在您进行规划阶段时可以提供帮助。以下是一些提示：</p>
<blockquote>
<p>提示：我正在为&lt; a certain category&gt;开发一个网站。建议一些目标或目的。目标受众是谁？</p>
<p>提示：在线商店基本布局需要哪些页面？</p>
<p>提示：我正在制作博客主页的线框图。你能建议一些重要的元素吗？</p>
<p>提示：我正在为移动应用的登录页面草拟线框。应该确保包含哪些基本部分？</p>
<p>提示：关于&lt; a certain category&gt;的网站，需要内容的好点子，比如博客文章、视频和信息图表？</p>
<p>提示：您将如何构建网站的导航，以使其对您的受众直观且用户友好？</p>
<p>提示：列出您将实施的关键 SEO 策略，以提高您网站在搜索引擎中的可见性。</p>
<p>提示：您为我的网站关于&lt; *a particular category*&gt;设想什么颜色调色板？</p>
<p>提示：为您的网站选择字体样式，关于&lt; *a particular category*&gt;。考虑可读性和品牌一致性，以及字体如何为网站的整体美感做出贡献。</p>
</blockquote>
<p>还有各种使用人工智能来帮助创建线框的工具。其中一个是 Uizard。类似于 Figma 这样的系统，它具有设计功能，例如拖放按钮和表单等元素的能力。它还可以被团队用于协作。</p>
<p>人工智能功能位于仪表板左侧的工具栏上。按钮称为魔法。点击它，您将看到人工智能功能列表。</p>
<p>要创建线框，选择自动设计器，这将弹出一个向导，如图 7-7 所示。</p>
<p>首先，您将选择要设计的设备：手机、平板电脑或网页。然后，您将描述项目。您可以只提供一句话或两句话。以下是一个示例：</p>
<blockquote>
<p>一个连接自由职业厨师与举办晚宴或特殊活动的人的网站。</p>
</blockquote>
<p>接下来，您将提出设计风格，例如：</p>
<blockquote>
<p>时尚现代的设计，生动的视觉效果和直观的布局，突出诱人的美食摄影和用户友好的预订功能。</p>
</blockquote>
<p>图 7-8 显示了线框。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0707-20240829144202-7fcfnrl.png"></p>
<p> 图 7-7. Uizard 有一个人工智能向导来帮助创建移动应用或网站的线框图</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0708-20240829144203-zbx5c8b.png"> 图 7-8. 根据给定的提示，Uizard 生成了这个网站的线框图</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本章中，我们探讨了如何使用ChatGPT启动软件开发项目。我们从头脑风暴开始，然后深入市场调研。接着，我们深入到需求草拟的细节，重点介绍了 PRD 和 SRS 如何帮助明确项目目标和技术细节。我们查看了不同的规划风格，从灵活的敏捷到结构化的瀑布。我们还研究了白板和测试驱动开发技术。通过将像ChatGPT这样强大的工具与经过验证的方法结合起来，您可以为项目构建一个坚实的基础。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/11/aiassistedprogramming06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/aiassistedprogramming06/" class="post-title-link" itemprop="url">第6章 ChatGPT 和其他通用 LLMs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-11T11:48:32+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 11:55:47" itemprop="dateModified" datetime="2024-09-26T11:55:47+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在本章中，我们将深入探讨一些广泛使用的通用大型语言模型，这些模型可以生成代码。当然，它们可能没有专门用于编码的模型那样的所有功能，比如与 IDE 的集成、复杂的安全性或用于训练模型的代码类型的保护措施，但它们仍然令人印象深刻。此外，它们不仅仅用于编码；它们在规划和头脑风暴方面也很出色。</p>
<p>我们将查看一些知名聊天机器人，如ChatGPT、Gemini和Claude。我将介绍如何设置它们、它们的费用、它们的酷炫功能以及如何充分利用它们。</p>
<h1 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h1><p>ChatGPT，于 2022 年 11 月 30 日突然出现。开发该应用的团队并没有在营销上花费很多。结果，他们并不需要这样做。该应用迅速火爆并自行传播。</p>
<p>仅仅五天，这款应用就吸引了百万用户，几个月内，用户数量飙升至 1 亿。它成为互联网历史上增长最快的平台。</p>
<p>桑迪尼·阿加瓦尔，帮助制定OpenAI政策的人，指出：“我认为人们开始使用它的程度确实让我们所有人感到惊讶。我们在这些模型上工作了很多，常常忘记它们有时对外界来说是多么令人惊讶。”</p>
<p>热度不断上升。到九月份，ChatGPT的访问量超过了 15 亿，收入飙升至 12 亿美元，较 2022 年的 2800 万美元大幅跃升。但这并不仅仅是关于ChatGPT本身。还有与OpenAI的 API 相关的蓬勃业务。</p>
<p>让我们快速了解一下OpenAI的背景。它于 2015 年启动，得到了硅谷一些大牌的支持，如埃隆·马斯克、山姆·阿尔特曼、格雷格·布罗克曼、伊利亚·苏茨凯弗、约翰·舒尔曼和沃伊切赫·扎伦巴。他们准备投入高达 10 亿美元来推动项目进展。</p>
<p>OpenAI 作为一个非营利组织启动，主要由数据科学和人工智能领域的博士组成，具有更多的学术氛围。其使命是实现人工通用智能（AGI），这种技术可以在大多数重要任务上超越人类。这个目标有一个利他主义的组成部分：利用 AGI 造福社会，避免任何可能伤害人们或过度赋予少数人权力的用途。</p>
<p>在早期，OpenAI 专注于研究并与他人分享其发现。该组织公开了其专利和代码，与其他机构密切合作。但创建尖端生成式人工智能系统的成本很高。</p>
<p>为了实现其宏伟梦想并吸引合适的人才，OpenAI在 2019 年创建了一家“capped”营利公司。这意味着他们现在可以合法地从风险投资基金和战略投资者那里获得现金，并且可以给员工分红。同年，微软投资了 10 亿美元。几轮投资后，微软总共投入了约 30 亿美元。快进到 2023 年 4 月，这家科技巨头全力以赴，投入了高达 100 亿美元。</p>
<h1 id="GPT-4"><a href="#GPT-4" class="headerlink" title="GPT-4"></a>GPT-4</h1><p>OpenAI的 GPT-4 模型在代码生成方面表现出色，得益于其多样化的训练数据，涵盖了广泛的来源。这种广泛的训练使其在多个专业和学术基准上达到了人类水平的表现，GPT-4 在大多数编程语言中始终优于 GPT-3 和 GPT-3.5。这在很大程度上归功于其增强的能力，能够遵循用自然语言表达的复杂指令，并生成更深度的技术或创意作品。另一个关键因素是 32K 上下文窗口。</p>
<p>有趣的是，在特定的代码生成基准测试中，集成了 Reflexion 的增强版 GPT-4——一个基于LLMs创建复杂代理的框架——在 HumanEval 上取得了 88%的通过率。这个分数明显高于基础版 GPT-4 的 67%通过率。这表明，通过某些改进，GPT-4 可以在代码生成任务中达到最先进的性能。</p>
<p>在 Codeforces 平台的竞赛编程场景中，GPT-4 的评分为 392 分，超过了 GPT-3.5 的 260 分。然而，GPT-4 在竞赛编程领域仍然是个新手，这些分数位于底部 5%。尽管 GPT-4 已经取得了很大进步，但在应对困难编码挑战方面，它仍然有很多追赶的空间，以匹配人类的技能。</p>
<h1 id="导航-ChatGPT"><a href="#导航-ChatGPT" class="headerlink" title="导航 ChatGPT"></a>导航 ChatGPT</h1><p>对于本章，我将使用ChatGPT，ChatGPT Plus 的高级版本。每月订阅费用为 20 美元。</p>
<p>这里是你获得的酷炫内容：</p>
<ul>
<li> 始终在线: 即使在大家都在使用ChatGPT时，付费订阅用户在高峰时段仍然享有优先访问权限。</li>
<li> 快速回复: 使用ChatGPT Plus，事情进展更快。您可以更快地获得答案，使聊天更加顺畅和有趣。</li>
<li>优先获取新产品: 如果有新的闪亮功能或升级，Plus 会员可以在其他人之前尝试。</li>
<li> 最新型号: 您可以访问它。</li>
</ul>
<p>图 6-1 显示了ChatGPT的接口。</p>
<p>左上角可以悬停在下拉菜单上选择您想要的模型或访问插件商店。在屏幕左侧，您可以点击按钮创建新的聊天会话。在底部，您将看到您的用户个人资料，您可以获取有关您的ChatGPT计划的信息，修改设置，并添加自定义说明。您还可以更改用户界面的主题：选项包括系统、黑暗和明亮。然后在底部，有输入框可以输入提示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0601-20240829141401-3g5m8za.png"></p>
<p> 图 6-1. ChatGPT系统的接口允许您选择所需的 GPT 模型并输入提示</p>
<p>让我们试试一些功能。假设您想创建代码。您输入这个到ChatGPT：</p>
<blockquote>
<p>编写一个计算数字阶乘的 Python 代码片段。</p>
</blockquote>
<p>图 6-2 显示了响应。</p>
<p>假设您想看看是否还有其他方法来创建代码。您可以问：</p>
<blockquote>
<p>提示：还有什么其他方法可以创建这段代码？</p>
</blockquote>
<p>ChatGPT提供了另一个代码建议，称为迭代方法。但假设你不知道这是什么？你可以继续聊天。在这样做的过程中，聊天会话会记录在屏幕左上角，如图 6-3 所示。ChatGPT将聊天标记为“Python 中的阶乘计算。”如果你愿意，可以通过点击旁边的图标重命名它。还有一个删除图标。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0602-20240829141402-u3t5lan.png"></p>
<p>图 6-2. ChatGPT 创建了一个 Python 代码片段作为响应</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0603-20240829141402-wju0my8.png"></p>
<p>图 6-3. ChatGPT 在屏幕左上角记录聊天会话</p>
<p>想创建一个新会话？点击顶部的铅笔图标。您将看到一个空白屏幕。</p>
<p>请记住，每个会话都是独立的。因此，如果您在后面的会话中询问ChatGPT关于它为阶乘计算创建的代码，它将不知道您指的是什么。</p>
<p>聊天会话的上下文窗口是另一个需要考虑的因素。这很重要，因为它决定了模型可以“记住”多少之前的对话或文本，并用来生成连贯且上下文相关的响应。对于 GPT-3.5，上下文窗口为 16K，而对于 GPT-4，则为 32K。</p>
<p>  注意</p>
<blockquote>
<p>如果您想删除所有聊天记录，请点击屏幕左下角的个人资料，然后选择设置和测试版。然后点击清除按钮。</p>
</blockquote>
<p>当您选择您的个人资料，然后点击设置和测试版，您会找到其他选项用于您的ChatGPT数据：</p>
<ul>
<li>关闭聊天记录和模型训练: 如果您关闭聊天记录，您的新聊天将不会用于训练人工智能，也不会出现在侧边栏的历史记录中。但是OpenAI仍会保留所有聊天记录 30 天，之后将永久删除，主要出于法律目的。</li>
<li> 共享聊天记录: 有趣的帖子？你可以将其转换为链接并与他人分享。</li>
<li>下载您的聊天数据: 选择此项，您将收到一封包含您所有ChatGPT对话的电子邮件。</li>
</ul>
<p>  注意</p>
<blockquote>
<p>有时候，ChatGPT可能会在生成文本的过程中停止。这时，通常会出现一个继续按钮。点击该按钮以继续生成文本。如果没有按钮，请在提示中输入“继续输出”。如果它没有给你想要的内容，请点击停止生成按钮以暂停。</p>
</blockquote>
<h2 id="移动应用程序"><a href="#移动应用程序" class="headerlink" title="移动应用程序"></a>移动应用程序</h2><p>ChatGPT在 iOS 和 Android 设备上都能为你提供支持。应用程序与网页版相似，不过，至少目前，它们没有插件等功能。</p>
<p>您可以在手机上与ChatGPT进行语音聊天。如果您不喜欢在小屏幕上打字，这很方便。只需前往设置中的新功能部分并选择启用即可开始。一旦您开启此功能，请点击主屏幕右上角的耳机图标与ChatGPT开始对话。您可以选择五种不同的声音让ChatGPT回复您。该语音系统得益于一个名为 Whisper 的生成式人工智能文本转语音模型。</p>
<p>移动版ChatGPT通过让您与助手分享图片，使聊天变得更加有趣。您可以拍摄任何东西的照片，比如物体、地标，甚至一些代码，然后与ChatGPT进行相关聊天。应用中还有一个方便的绘图工具，因此您可以在讨论时突出显示图像的特定部分。</p>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>通过在ChatGPT中设置自定义指令，您可以调整响应的输出以满足您的需求。此功能可以节省时间，因为您不必每次与机器人聊天时都不断调整响应或想出新的提示。您可以在个人资料中开启自定义指令。</p>
<p>当您设置自定义指令时，您需要回答这两个问题：</p>
<blockquote>
<p>ChatGPT：您希望ChatGPT了解您什么，以提供更好的回复？</p>
<p>ChatGPT：您希望ChatGPT如何回应？</p>
</blockquote>
<p>我们举个例子：</p>
<blockquote>
<p>ChatGPT：您希望ChatGPT了解您什么，以提供更好的回复？</p>
<p>开发者：我是一名程序员，和一个遵循 PEP 8 风格指南的团队一起工作。我们重视干净、可读的代码，并遵循最佳实践。我通常从事数据处理和分析任务，常常需要帮助编写高效且结构良好的代码。</p>
<p>ChatGPT：您希望ChatGPT如何回应？</p>
<p>开发者：我希望ChatGPT提供符合 PEP 8 风格指南的 Python 代码片段。它应该优先考虑可读性和编码最佳实践。在建议解决方案时，我更喜欢解释为什么推荐特定的方法以及它如何符合 PEP 8 标准。如果ChatGPT能指出与当前任务相关的常见陷阱或错误，并提供避免它们的技巧，我也会很感激。</p>
</blockquote>
<h1 id="使用必应浏览"><a href="#使用必应浏览" class="headerlink" title="使用必应浏览"></a>使用必应浏览</h1><p>ChatGPT的训练截止于 2023 年 4 月。这可能会对开发者造成问题。由于库、框架和工具变化如此之快，自那时以来可能出现了许多新特性或功能，而ChatGPT不会对此保持最新。</p>
<p>但是ChatGPT有一个秘密武器：使用必应浏览。它允许你进行实时网页搜索以找到答案。</p>
<p>假设您正在查看一个新的框架，比如 LangChain。它自 2022 年底以来就出现了，并且发展了很多。它还旨在使应用程序开发与LLMs更加顺畅，因此您可能会喜欢使用它。</p>
<p>要激活使用必应浏览并增强ChatGPT对 LangChain 当前状态的理解，请在您的提示中添加类似“使用互联网获取此响应”的内容。以下是一些旨在获取有关 LangChain 的一般信息的提示示例：</p>
<blockquote>
<p><em>Prompt:</em> Tell me about the LangChain framework and its primary features. Use the internet for the response.</p>
<p><em>Prompt:</em> Check the internet for introductory resources or documentation for getting started with LangChain.</p>
<p><em>Prompt:</em> Browse the internet for examples of applications that have been built using the LangChain framework.</p>
<p><em>Prompt:</em> Look up any recent updates or releases related to the LangChain framework. Use the internet for the response.</p>
</blockquote>
<p>在回应这些提示时，ChatGPT确实提供了相当有用的答案。例如，对于第一个提示，ChatGPT提出了 LangChain 的五个主要特征，您可以在图 6-4 中看到。</p>
<p>您也可以更改此内容的格式。尝试这个提示：</p>
<blockquote>
<p>提示：将此转换为表格。</p>
</blockquote>
<p>图 6-5 显示了结果。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0604-20240829141404-0iq80he.png"></p>
<p> 图 6-4. 使用必应浏览功能帮助ChatGPT研究 LangChain 框架的主要特性</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0605-20240829141406-82y60of.png"></p>
<p> 图 6-5. 当被提示时，ChatGPT可以将其输出放入表格中</p>
<p>使用必应浏览时，ChatGPT 可能需要几秒钟甚至一分钟或更长时间才能响应。有时 ChatGPT 可能会卡住并输出错误。您可能需要尝试几次才能得到答案。ChatGPT 有时可能会不稳定。</p>
<p>使用必应浏览时，输出内容通常会有信息来源的网页链接。点击它以验证内容是个好主意。毕竟，您必须对ChatGPT生成的所有内容持保留态度。有时响应可能来自社交媒体帖子，例如，这并不总是最可靠的来源。</p>
<p>幸运的是，您可以指示ChatGPT专注于某些类型的来源。表 6-1 提供了一些建议。</p>
<p>表 6-1. 指示ChatGPT使用某些信息来源的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>域名限制</td>
<td>使用站点操作符将搜索限制在信誉良好的域名，如.edu 或.gov，或特定的信誉良好的组织。</td>
</tr>
<tr>
<td>学术关键词的使用</td>
<td>同行评审，期刊，研究，研究。</td>
</tr>
<tr>
<td>使用发布日期过滤器</td>
<td>按最近出版日期过滤搜索，以获取当前和相关的信息。</td>
</tr>
<tr>
<td>专业或学术协会</td>
<td>指定专业或学术协会以寻求权威出版物或报告。</td>
</tr>
</tbody></table>
<p>那么ChatGPT在为 LangChain 创建代码方面表现如何呢？让我们看看。这是一个简单程序的提示：</p>
<blockquote>
<p>提示：我想编写一个使用 LangChain 框架的 Python 程序。它将具有以下功能：</p>
<p>获取用户关于某个主题的输入。</p>
<p>选择要创建的内容类型：博客或社交媒体帖子。</p>
<p>使用 LangChain 访问OpenAI API，根据主题创建博客或社交媒体帖子。</p>
</blockquote>
<p>当我在ChatGPT中尝试这个时，结果嘛，挺一般的。确实，它掌握了用户输入的基本 Python 代码结构——这并不意外，因为ChatGPT在 Python 方面很厉害。但对于 LangChain 代码？完全不对。它搞错了 LangChain 库的导入，还漏掉了一些其他内容。此外，它对如何调用OpenAI API 毫无头绪。</p>
<p>底线：使用必应浏览器主要适用于日常的一般问题——至少目前是这样。</p>
<h1 id="繁琐任务"><a href="#繁琐任务" class="headerlink" title="繁琐任务"></a>繁琐任务</h1><p>软件开发很容易变得复杂，有很多步骤。你需要规划、编码和测试，仅举几例。一个真正让人头疼的部分是重复编码。这很无聊，耗费大量时间。开发人员经常陷入编写相同的例程代码、修复错误和审查代码中。确实，这些都很重要，但这并不是制作软件时有趣和创造性的部分。此外，跟上新的编程语言、框架和工具可能会让人不知所措。</p>
<p>像ChatGPT这样的人工智能工具可以减轻软件开发中那些无聊的部分。在接下来的几个部分中，我们将深入探讨这些领域。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式，或称 regex，是处理文本的巧妙工具。可以把它们看作一种强大的查找和替换功能，能够识别字符串中的模式。但问题是：正则表达式就像学习一种全新的符号和命令语言。这可能会让人感到困惑！试着记住那些奇怪的反斜杠、点、括号以及其他谁知道的组合，足以让你头晕。有时候，感觉就像需要一个秘密解码器才能理解这一切。</p>
<p>例如，取一个正则表达式模式：</p>
<blockquote>
<p><code>^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])[A-Za-z\d@$!%*?&amp;]&#123;8,&#125;$</code></p>
</blockquote>
<p>这将用于验证强密码，确保密码至少包含八个字符，包括一个大写字母、一个小写字母、一个数字和一个特殊字符。</p>
<p>你可能不喜欢写这个，但ChatGPT可以创建正则表达式。以下是一些常见示例：</p>
<blockquote>
<p><em>Prompt:</em> Create a regex pattern to validate standard email addresses. The email should start with alphanumeric characters, followed by optional dots, hyphens, or underscores. Then, there should be an “@” symbol, followed by more alphanumeric characters, a dot, and finally, a domain name that is 2 to 6 characters long.</p>
<p><em>Regex pattern:</em> ^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,6}$</p>
<p> <em>Prompt</em> : Provide me with a regex pattern to validate URLs. The URL may start with “http” or “https”, followed by “:&#x2F;&#x2F;”, then a domain name which can include alphanumeric characters and dots. After the domain, there can be an optional path that starts with a “&#x2F;” and can include alphanumeric characters, slashes, dots, or hyphens. The URL may end with an optional “&#x2F;”.</p>
<p><em>Regex pattern:</em> ^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]*)*/?$</p>
<p> <em>Prompt</em> : Create a regex pattern to validate dates in the MM&#x2F;DD&#x2F;YYYY format. The month should be between 01 and 12, the day should be between 01 and 31, and the year should be either in the 1900s or 2000s.</p>
<p><em>Regex pattern:</em> ^(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/(19|20)\d\d$</p>
<p><em>Prompt:</em> I’m looking for a regex pattern to validate IPv4 addresses. Each octet should be a number between 0 and 255, and the octets should be separated by dots. Create a regex pattern for this.</p>
<p><em>Regex pattern:</em> ^(25[0-5]|2[0-4]\d|[0-1]?\d\d?).((25[0-5]|2[0-4]\d|[0-1]?\d\d?).){2}(25[0-5]|2[0-4]\d|[0-1]?\d\d?)$</p>
</blockquote>
<p>ChatGPT 还可以帮助您解读正则表达式模式。以下是一个示例提示：</p>
<blockquote>
<p><em>Prompt:</em> What is this regex? ^((\d{3})\s?|\d{3}[-.])\d{3}[-.]\d{4}$</p>
</blockquote>
<p>响应是为了匹配北美电话号码格式。</p>
<h2 id="启动代码"><a href="#启动代码" class="headerlink" title="启动代码"></a>启动代码</h2><p>启动代码是初始代码片段或模板，可以让你快速入门。毫无疑问，它可以节省大量时间。但启动代码也可以作为学习工具。如果你是编程新手，浏览一些启动代码可以帮助你了解事物是如何运作的。此外，启动代码有助于保持一致性，特别是在需要每个人都在同一页面的大团队中。</p>
<p> 这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line">const port = 3000;</span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line"> res.send(&#x27;Hello, World!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line"> console.log(`Server running at http://localhost:$&#123;port&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这是一个使用 Express.js 创建的基本 web 服务器的简洁明了的示例，Express.js 是一个流行的 Node.js web 框架。由于其简单性和核心元素的使用，它是一个很好的入门代码。表 6-2 显示了一些入门代码的提示。</p>
<p>表 6-2. 启动代码提示</p>
<table>
<thead>
<tr>
<th>编程语言&#x2F;框架</th>
<th>提示</th>
</tr>
</thead>
<tbody><tr>
<td>Node.js&#x2F;Express.js</td>
<td>提供一个基本的 Express.js 服务器示例。</td>
</tr>
<tr>
<td>React（JavaScript）</td>
<td>如何创建一个简单的 React 组件？</td>
</tr>
<tr>
<td>JavaScript</td>
<td>你能告诉我如何在 JavaScript 中定义一个简单的函数吗？</td>
</tr>
<tr>
<td>安卓（Java）</td>
<td>基本安卓活动的启动代码是什么？</td>
</tr>
<tr>
<td>Python&#x2F;Flask</td>
<td>你能给我一个基本的 Flask 应用示例吗？</td>
</tr>
<tr>
<td>Vue.js（JavaScript）</td>
<td>告诉我如何设置一个基本的 Vue 实例。</td>
</tr>
<tr>
<td>django（Python）</td>
<td>如何开始一个新的 Django 项目并创建一个简单的视图？</td>
</tr>
<tr>
<td>Swift（iOS）</td>
<td>简单的 Swift UIViewController 的启动代码是什么？</td>
</tr>
</tbody></table>
<h2 id="GitHub-读我文件"><a href="#GitHub-读我文件" class="headerlink" title="GitHub 读我文件"></a>GitHub 读我文件</h2><p>GitHub 读取我文件本质上是一个仓库的欢迎垫。它是你了解项目的全部内容的地方——它的目的、它的功能以及如何使用它。通常称为 README.md，它是用 Markdown 编写的，旨在使内容美观且易于阅读。你将在仓库的主页上看到 README。</p>
<p>良好的自述文件很重要，因为它使任何查看您项目的人都能更顺利地进行。它设定了基调，并帮助使项目更清晰，无论用户是想使用该项目还是想为其贡献。自述文件还将列出规则和预期内容。</p>
<p>编写 README 并不总是一件轻松的事。你必须找到提供所有重要细节和保持简洁之间的平衡。专注于编码的开发者可能会忽略重要部分，没意识到对他们来说显而易见的事情对其他人并不明显。</p>
<p>编写良好 README 确实需要一些写作技巧。但这不一定是开发者的强项。此外，随着项目的增长和变化，保持 README 的更新也是一项独立的工作。是的，这可能是一项 juggling 技能。</p>
<p>但是有了ChatGPT的帮助，编写 README 可以变得轻而易举，内容应该相当扎实。我们来举个例子。假设你刚刚开发了这个很棒的食谱挖掘应用。这里有一个提示来开始：</p>
<blockquote>
<p><em>Prompt:</em> Write a GitHub readme for my project named “Recipe Finder.” This project is developed using Vue.js and helps users find recipes based on the ingredients they have. Users need to input the ingredients they have, and the app will return a list of recipes they can cook with those ingredients. To kickstart, simply clone the repository, run npm install, insert your API key into the .env file, and execute npm start to launch the app.</p>
</blockquote>
<p>ChatGPT 创建项目介绍，然后包括功能、入门、使用、贡献、许可证和致谢等部分。</p>
<p>对于 README 的某些部分，ChatGPT做出了假设。例如，它指定该项目使用 MIT 许可证。但您可以继续提示ChatGPT提供有关该项目的更多细节。</p>
<p>  注意</p>
<blockquote>
<p>如果您不知道使用什么开源许可证，请查看选择许可证（<a target="_blank" rel="noopener" href="https://choosealicense.com),它提供了相关帮助./">https://choosealicense.com），它提供了相关帮助。</a></p>
</blockquote>
<h1 id="跨浏览器兼容性"><a href="#跨浏览器兼容性" class="headerlink" title="跨浏览器兼容性"></a>跨浏览器兼容性</h1><p>跨浏览器兼容性是确保您的网站或网络应用在不同浏览器上正常工作。这很重要，因为您的用户可能使用各种浏览器访问您的网站或应用，如 Chrome、Firefox、Safari 和 Edge，这些浏览器都有不同的版本。</p>
<p>让我们展示一下ChatGPT如何帮助您应对这个挑战。表 6-3 显示了一些有用的提示。</p>
<p>表 6-3. 浏览器兼容性提示</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>提示</th>
</tr>
</thead>
<tbody><tr>
<td>HTML5 和 CSS3 特性</td>
<td>我想在输入字段中使用占位符属性，但在旧版本的 Internet Explorer 中不起作用。<br />我该如何创建备用方案？<br /></td>
</tr>
<tr>
<td>CSS 前缀</td>
<td>我想在我的 CSS 中使用过渡属性，但我想确保它在所有浏览器中兼容。我应该怎么写？</td>
</tr>
<tr>
<td>JavaScript 功能</td>
<td>我在使用 JavaScript 中的 fetch 函数进行 HTTP 请求，但在 Internet Explorer 中不支持。<br />我该怎么办？<br /></td>
</tr>
</tbody></table>
<h1 id="bash-命令"><a href="#bash-命令" class="headerlink" title="bash 命令"></a>bash 命令</h1><p>在终端中输入的与计算机系统交互的指令称为 bash 命令。它们可以让你执行多种任务，比如在文件中移动、监控计算机的操作以及操作文件。</p>
<p>掌握 bash 命令可能很困难，尤其是对于新接触 Unix&#x2F;Linux 世界的人来说。有些命令的写法可能很晦涩，刚开始时很难理解。真正掌握它需要相当多的时间和练习。此外，还有很多命令，每个命令都有自己的一堆选项和变体。当然，互联网上有资源可以帮助。但是即使是专业人士也可能很难记住他们不常用或最近才学会的命令。</p>
<p>然而，您可以使用ChatGPT作为您的虚拟助手来处理 bash 命令。以下是一些示例提示：</p>
<blockquote>
<p>我如何使用 bash 命令列出按修改时间排序的目录中的所有文件？</p>
<p>统计文件行数的 bash 命令是什么？</p>
<p>创建目录并进入该目录的单个命令是什么？</p>
<p>如何将命令的输出重定向到文件？</p>
<p>查找我系统上运行的特定进程的命令是什么？</p>
<p>如何使用 bash 将目录压缩成 ZIP 文件？</p>
<p>我应该使用什么命令来更改 bash 中文件的权限？</p>
</blockquote>
<h1 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h1><p>GitHub Actions 是一个内置于 GitHub 的持续集成和持续部署 (CI&#x2F;CD) 工具。它允许开发者直接在他们的代码库中设置、定制和运行软件开发工作流。基本上，GitHub Actions 工作流是一组您在工作流文件中定义的自动化过程。这些过程由作业组成，每个作业执行不同的操作，如运行命令、设置流程或运行操作。它们采用 YAML 语法编写，并在某些操作发生时启动，例如推送代码、创建新问题或安排时间。使用 GitHub Actions，开发者可以直接从 GitHub 构建、测试和部署他们的代码，使他们的软件开发过程更加顺畅和自动化。您可以共享、重用或甚至调整其他开发者的操作，这对于团队合作和在自动化软件开发领域共享经验非常有帮助。</p>
<p>ChatGPT 可以帮助你创建 GitHub Actions。以下是一些提示：</p>
<blockquote>
<p>提示：创建一个 GitHub Actions 工作流模板，使用 Hugo 构建和部署静态网站，并部署到 GitHub Pages。</p>
<p>提示：生成一个用于 Java 项目的 GitHub Actions 工作流模板，包含编译代码、运行测试和打包应用程序的步骤。</p>
<p>提示：创建一个用于 Docker 化应用程序的 GitHub Actions 工作流模板，包括构建 Docker 镜像、推送到 Docker Hub 和部署到 Kubernetes 集群的步骤。</p>
<p>提示：生成一个用于 React Native 移动应用程序的 GitHub Actions 工作流模板，包括安装依赖项、构建应用程序和将 APK 上传到指定 Google Drive 文件夹的步骤。</p>
</blockquote>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>ChatGPT 插件是利用 OpenAI LLM 功能的迷你应用程序。它们为使用外部数据库和应用程序打开了大门。这就像拥有自己的 iOS 或 Google Play 小应用商店。</p>
<p>要使用插件，您首先需要确保已激活该功能。前往您的个人资料，选择设置，然后选择测试功能。</p>
<p>您可以通过将鼠标悬停在 GPT-4 图标上（在屏幕顶部）然后选择插件来找到插件。点击此处，您将看到图 6-6 所示的屏幕。</p>
<p>在顶部，您可以导航插件。您可以筛选热门、新增、所有和已安装的应用。还有一个搜索框。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0606-20240829141407-aw3vtqo.png"></p>
<p> 图 6-6. ChatGPT 插件商店让您访问使用 OpenAI LLM 功能的迷你应用程序</p>
<h2 id="Codecademy-插件"><a href="#Codecademy-插件" class="headerlink" title="Codecademy 插件"></a>Codecademy 插件</h2><p>让我们试试 Codecademy 的插件。首先，按安装按钮。要激活它，请到屏幕顶部点击下箭头。然后点击 Codecademy 图标。</p>
<p>该插件有两个主要功能。一个是允许用户根据他们的目标和经验水平找到特定的课程或路径。例如，对人工智能和ChatGPT感兴趣的用户可以向插件请求课程推荐，它将提供相关课程的列表，包括描述和课程是否免费或付费的信息。</p>
<p>接下来，插件作为技术文档的快速参考工具，提供指向更详细信息的文档和文章的链接。</p>
<p>我们将测试这部分：</p>
<blockquote>
<p>最佳文档或文章用于解释 JavaScript 中的数组是什么？</p>
</blockquote>
<p>ChatGPT提供如图 6-7 所示的响应。</p>
<p>顶部的图标显示系统正在访问 Codecademy 插件。下面的文本表明该主题有很多资源可用。然而，插件随后通过提供三个文档的链接来缩小范围。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0607-20240829141408-7wsbfly.png">#</p>
<p> 图 6-7. Codecademy 插件响应关于 JavaScript 数组的资源请求</p>
<h2 id="AskYourDatabase插件"><a href="#AskYourDatabase插件" class="headerlink" title="AskYourDatabase插件"></a>AskYourDatabase插件</h2><p>谢尔顿·牛提出了这个插件的想法，因为他经常使用ChatGPT来编写 SQL 语句，这很麻烦。他每次都得解释整个数据库架构，然后还要复制粘贴输出在终端运行。他想，“嘿，如果ChatGPT可以直接与数据库聊天呢？”这就是他开始创建 AskYourDatabase 的原因。</p>
<p>使用这个工具，您可以轻松地使用ChatGPT原型设计数据库模式。然后，查询数据变得非常简单。更好的是，您可以跳过那些通常需要大量设置的传统商业智能（BI）工具。</p>
<h2 id="Recombinant-AI-插件"><a href="#Recombinant-AI-插件" class="headerlink" title="Recombinant AI 插件"></a>Recombinant AI 插件</h2><p>马克·扎姆是一名开发者，他创办了自己的人工智能咨询公司。他创建了Recombinant AI插件，以便让开发者在使用他们的 GitHub 和 Gitlab 代码库时更轻松。该工具可以让ChatGPT了解整个程序的要点，并筛选出细节。这样，用户可以很好地掌握他们的代码，这在调整、分析或将自己的想法融入软件时很有帮助。马克称其为“对话式集成开发环境”，这是一种很不错的说法。</p>
<p>以下是它的一些应用：</p>
<ul>
<li>执行传统任务，如存储代码片段或提示</li>
<li>使用项目和文件系统创建复杂的任务列表和思维链提示</li>
<li>保存有关最新编程库的重要信息</li>
</ul>
<h1 id="GPTs"><a href="#GPTs" class="headerlink" title="GPTs"></a>GPTs</h1><p>您可以创建自己的自定义ChatGPT。它被称为 GPT，组装起来非常简单—通常只需几分钟。</p>
<p>让我们看一个例子。我们将创建一个软件开发风格指南的 GPT。这包含了很多基本的指导原则，比如如何命名变量以便让每个人都能理解，代码的正确缩进方式，以及团队遵循的特定编程模式或实践。这是你代码的着装规范。</p>
<p>这个想法是使一切统一和整洁。这使得每个人都更容易阅读和理解代码库，这在大型项目中可以节省时间。</p>
<p>但这里有个问题：如果你是新手，这可能会有点让人不知所措。你可能习惯了某种编码方式，突然间你需要适应新的标准。</p>
<p>这是 GPT 可以帮助的地方。让我们创建一个。首先，在ChatGPT的首页——左上角——选择探索，然后选择创建 GPT。您将看到一个包含两个面板的屏幕，如图 6-8 所示。</p>
<p>左侧面板是构建 GPT 的地方，右侧面板是预览区域。要使其与开发风格指南一起工作，您的提示应该如下所示：</p>
<blockquote>
<p>创建一个强制执行软件开发风格指南的系统。</p>
</blockquote>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0608-20240829141409-lhe9kfc.png"></p>
<p> 图 6-8. GPT 构建器允许您创建自定义 GPT</p>
<p>ChatGPT 将开始为 GPT 创建指令。这个提示有点模糊，但 ChatGPT 会问一些问题以获取更多信息。它首先会建议一个 GPT 的名称——它建议“代码风格师”。</p>
<p>然后它将使用 DALL·E 3 为 GPT 创建一个头像图片。但你可以上传自己的图片。</p>
<p>然后它会询问一些细节，比如语言或语言、实践、指南、规则、应该避免的事项等等。比如你告诉它语言是 Python，并给出一些其他要求。</p>
<p>接下来，在面板顶部选择配置选项卡。然后您可以上传您的样式指南。</p>
<p>您可以然后去右侧面板实验 GPT。如果您让它写代码，它将自动使用 Python 并遵循您的规则。</p>
<p>您可以通过点击右上角的图标保存此 GPT。然后它会出现在您的主屏幕上。要使用它，只需点击 GPT 图标。</p>
<p>OpenAI还创建了一个 GPT 应用商店。您可以通过在ChatGPT屏幕左上角选择探索 GPT 来访问。</p>
<p>一个关于编程的分类。以下是一些可用的 GPT 示例：</p>
<ul>
<li>GPTavern 是一个创新平台，旨在通过一种称为“提示编程”的独特方法教授编码。它提供超过 20 个快捷键以简化编码过程，并提供 75 个入门项目的集合用于学习代码。该平台是互动式的，允许用户提问、上传照片，并访问命令菜单和自述文件以获取指导。</li>
<li>DesignerGPT 由皮耶特罗·希拉诺创建，专注于创建和托管美观的网站。</li>
<li>截图转代码（Screenshot To Code） GPT，由 godofprompt.ai 提供，提供一个功能，允许用户上传网站截图，然后转换为干净的 HTML、Tailwind 和 JavaScript 代码。</li>
<li>思维导图&#x2F;图表&#x2F;图表—专业构建器，由 pyxl.ai 提供，帮助可视化代码和数据库。它使用户能够使用用户友好的拖放编辑器创建流程图、图表和序列，帮助理解和组织复杂的数据结构。</li>
<li>代码大师（Code Guru）由瑞安·J·托普斯开发，提供包括代码审查、编写拉取请求、生成和优化函数、编写测试以及对现有代码进行注释等一系列服务。</li>
</ul>
<p>  注意</p>
<blockquote>
<p>您可以在您的 GPT 中包含第三方 API。您可以通过选择操作来实现。</p>
</blockquote>
<h1 id="Gemini"><a href="#Gemini" class="headerlink" title="Gemini"></a>Gemini</h1><p>当ChatGPT出现时，谷歌措手不及。尽管在人工智能方面进行了早期布局和巨额投资，谷歌仍未准备好迎接生成式人工智能浪潮。谷歌对跳入这种新技术持谨慎态度——担心其准确性及对公司盈利广告业务的影响。但在 2023 年初，谷歌的股票下跌，这引发了变动。公司决定采取行动，推出了 Bard，这是其对生成式人工智能的尝试，算是一种对ChatGPT的回应。Bard 在开始时遇到了一些问题，但逐渐改善，融入了不同的谷歌应用，并帮助公司的股票回升。</p>
<p>在 2024 年 2 月，谷歌将 Bard 平台更名为 Gemini。除了免费版，现在还有一个高级版 Gemini Advanced，初始两个月免费，之后每月收费 19.99 美元。它使用谷歌最先进的LLM，称为 Ultra 1.0。谷歌表示：“它可以帮助您处理更高级的编码场景，充当创意的讨论平台，并帮助您评估不同的编码方法。”</p>
<p>谷歌还推出了适用于 Android 和 iOS 的 Gemini 移动版本。通过该应用，您可以输入文字、语音或使用图像与LLM进行互动。图 6-9 显示了 Gemini 的界面。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0609-20240829141410-mfxws8w.png"></p>
<p> 图 6-9. Gemini 的用户界面允许您管理聊天会话并输入文本提示、图像和语音转文本输入</p>
<p>就像ChatGPT一样，在屏幕左侧，你会看到聊天会话列表。如果你想隐藏列表，只需点击上方的汉堡图标。对于任何聊天，你可以点击右侧的小图标来更改名称或删除它。然后还有这个很酷的功能：你可以固定你想要随时使用的聊天。</p>
<p>如果您想清除所有或部分项目——根据发生的时间——请前往左下角点击活动。在这里，您还可以告诉Gemini是否希望保留您的提示或直接放弃。</p>
<p>在屏幕中间，您会找到一些关于如何使用Gemini的提示，以及一些安全提醒。底部是您输入提示的地方。右侧是您上传图片的位置。Gemini可以提取文本，识别物体和场景，回答有关图片的问题，甚至生成一些创意文本格式。</p>
<p>输入框右侧也有一个麦克风图标。这允许您使用语音转文本为Gemini生成文本。</p>
<p>那么插件呢？Gemini有自己的版本吗？有，它们被称为扩展。目前，它们仅适用于谷歌应用程序，如航班、酒店、地图、工作区和 YouTube；没有第三方扩展。</p>
<p>最后，Gemini可以实时访问互联网。它的回答将包含引用，以便您验证来源。</p>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>生产力应用程序如 Excel 和 Google Sheets 不仅仅用于电子表格。它们有自己的编程语言来增强它们的功能。以 Excel 为例。它有应用程序视觉基本（VBA），这是一个强大的编程系统，让你可以编写自己的脚本和程序。它非常适合自动化重复的任务、创建特殊函数和分析数据。Excel 还配备了许多现成的函数，如数据透视表和 Power Query，并且与 Power BI 很好地配合，提供一流的数据可视化和分析。</p>
<p>Google 表格，另一方面，使用 Google Apps 脚本，这类似于 JavaScript 的表亲。它允许您执行类似于 Excel 中可以执行的任务。此外，还有与 Google 应用程序如云端硬盘和 Gmail 的顺畅集成。Google 表格还配备了一整套现成的函数，您可以通过 Google 工作区市场中的不同插件来增强它。完全基于云使其非常适合与他人协作，并且是 Web 应用程序和小组项目的不错选择。</p>
<p>那么Gemini可以帮忙吗？当然可以。例如，你可以用它来解释一个公式。毫无疑问，公式可能会变得相当复杂。这里有一个例子：</p>
<blockquote>
<p><em>Prompt:</em> Explain the following Excel formula: &#x3D;SUM(OFFSET(A1,1,0,COUNT(A:A),1))</p>
</blockquote>
<p>对于Gemini来说，理解这一点毫无问题。</p>
<p>另一个用例是创建 VBA 脚本。以下是一些示例提示：</p>
<blockquote>
<p>提示：如何使用 VBA 在 Excel 中创建自定义表单以输入用户登录信息？</p>
<p>提示：你能帮我写一个 VBA 脚本来保护 Excel 中特定数据的密码吗？</p>
<p>提示：我需要 VBA 代码来验证我的 Excel 用户登录表中的电子邮件地址和日期格式。你能帮忙吗？</p>
<p>提示：是否可以使用 VBA 从 Excel 发送自动电子邮件通知，以获取用户登录信息的更新？</p>
</blockquote>
<p>虽然这一切都很好，但在处理电子表格时，理解数据、公式和脚本之间的关系是很重要的。了解它们如何协同工作可以帮助你构建强大的模型，并避免出现错误。毕竟，如果你修改了数据中的某些内容，这个变化可能会影响你的公式，并干扰你的脚本输出，结果是你的最终结果可能会发生完全的变化。</p>
<p>但是Gemini可以加载和分析 Excel 电子表格。然后你可以询问它们，例如获取逐步理解或突出显示数据或逻辑的某个区域。</p>
<p>让我们举个例子。假设你有一个包含图书销售数据的 Excel 电子表格。以下是一些示例提示：</p>
<blockquote>
<p>你能告诉我如何在 Excel 中找到作者获得的最高版权费金额吗？</p>
<p>我想在 Excel 中计算每本书的库存周转率。我应该使用什么公式？</p>
<p>在 Excel 中创建库存短缺警报，指示何时根据 reorder level 订购更多</p>
<p>如何在 Excel 中计算书籍的好评百分比（评分 4 或更高）？</p>
</blockquote>
<h2 id="Gemini编程"><a href="#Gemini编程" class="headerlink" title="Gemini编程"></a>Gemini编程</h2><p>Gemini理解超过 20 种计算机编程语言。我们来试试这个提示：</p>
<blockquote>
<p>生成一个将摄氏温度转换为华氏温度的 TypeScript 函数。</p>
</blockquote>
<p>图 6-10 显示了Gemini的响应。</p>
<p>右上角有一个显示草稿的选项。如果您点击此选项，您会找到三个版本的Gemini响应。这可以为您的编码任务提供更好的想法。</p>
<p>与ChatGPT一样，响应包含代码列表，您可以复制。Gemini还提供了解释。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0610-20240829141411-t5ahp8l.png"></p>
<p>图 6-10. Gemini 响应创建 TypeScript 函数的请求</p>
<p>图 6-11 显示了几种处理响应的方法。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0611-20240829141411-ys90xvu.png"></p>
<p> 图 6-11. 点击底部的图标以对Gemini的响应采取不同的操作选项</p>
<p> 您的选项包括：</p>
<p> 评估您可以点击点赞或点踩来反馈回复。</p>
<p> 修改此响应您可以点击过滤器图标访问选项，以使响应更短、更长、更简单、更随意或更专业。</p>
<p> 分享您可以将响应分享为公共链接。您还可以将其导出到 Google Docs 或用于 Gmail 草稿。</p>
<p>再次检查响应当您点击谷歌 logo 时，Gemini将审核响应的准确性。它可能会提供支持链接。</p>
<h1 id="Claude"><a href="#Claude" class="headerlink" title="Claude"></a>Claude</h1><p>在 2021 年，兄妹团队达里奥和丹妮拉·阿莫代伊启动了他们自己的初创公司Anthropic。他们曾是OpenAI的高管，但他们有了创建一种不同类型生成式人工智能平台的想法。他们的愿景是专注于提高人工智能的安全性，例如通过最小化偏见。这被称为宪法人工智能。</p>
<p>Anthropic LLM 具有强大的编码技能。它在 Codex HumanEval 上的得分为 71.2%，这是一个 Python 编码测试。</p>
<p>Claude的一个主要优点是其上下文窗口，大小为 100,000 个令牌。这意味着它可以处理大型代码列表。您还可以上传 PDF 等文件。</p>
<p>图 6-12 显示了Claude的初始屏幕。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0612-20240829141412-uweuuiu.png"></p>
<p> 图 6-12. Claude 聊天机器人主屏幕列出了您的先前活动，并允许您输入提示和上传文件</p>
<p>在顶部，您可以输入提示并上传最多五个文件。下面是您之前活动的列表，按发生的天数分组。</p>
<p>假设我们输入这个：</p>
<blockquote>
<p>提示：你能写一个反转字符串的 JavaScript 函数吗？</p>
</blockquote>
<p>图 6-13 显示了Claude的响应。</p>
<p>像ChatGPT一样，Claude提供免费套餐。但您也可以每月支付 20 美元获得高级版本。升级后，您将获得五倍的使用容量、高峰期优先访问权限以及新功能的提前访问权限。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0613-20240829141413-sle7s14.png"></p>
<p> 图 6-13. Claude 响应 JavaScript 函数请求</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本章中，我们参观了一些大型LLMs，如ChatGPT、Gemini和Claude。我们查看了它们的酷炫功能——代码生成、插件、实时浏览网页以及处理大量信息。当然，它们可能无法与专业编码工具相媲美，但在加速软件开发时，它们仍然有很多可提供的功能。随着这些LLMs不断改进，它们正准备带来更多令人惊叹的人工智能驱动的编程突破。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/09/aiassistedprogramming05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/09/aiassistedprogramming05/" class="post-title-link" itemprop="url">第5章 其他人工智能辅助编程工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-09 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-09T11:48:32+08:00">2024-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 11:55:47" itemprop="dateModified" datetime="2024-09-26T11:55:47+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>虽然 GitHub Copilot 在人工智能辅助编程方面是大佬，但还有很多其他优秀的工具可用。开发者在日常编码中混合使用这些工具是很常见的。好的一点是，这些工具大多数都遵循 GitHub Copilot 的模式，因此掌握它们并不太难。你可以使用评论来启动命令，并使用便捷的快捷方式获取快速建议，它们还具有方便的聊天功能。</p>
<p>在本章中，我们将深入探讨不同的人工智能编程工具。我们将查看来自大公司的工具，如亚马逊，以及一些初创公司的不错发现。此外，我们也不会忽略开源选项——比如 Meta 的 Code Llama——因为它们绝对值得一看。</p>
<h1 id="亚马逊-CodeWhisperer"><a href="#亚马逊-CodeWhisperer" class="headerlink" title="亚马逊 CodeWhisperer"></a>亚马逊 CodeWhisperer</h1><p>亚马逊CodeWhisperer是一个类似于瑞士军刀的 IDE 扩展，适用于 VS Code、PyCharm 和 AWS Lambda。它由一个LLM驱动，经过大量代码训练，理解 15 种编程语言。亚马逊在添加新语言时非常谨慎，专注于准确性和安全性，而不是市场速度。CodeWhisperer有两个版本：</p>
<ul>
<li>个人版免费—只需使用您的 AWS Builder ID 或亚马逊登录即可。它提供代码建议，跟踪开源代码来源，并进行安全检查。</li>
<li>CodeWhisperer 专业版每位用户每月 19 美元。它拥有个人版的所有功能，以及一些对大公司有用的额外功能。还有一个管理系统来管理谁可以访问什么，您甚至可以控制使用的开源数据类型。<br>专业版的酷炫之处在于自定义功能。公司可以调整代码提示工具，以根据自己的库、API 和框架提供更相关的代码建议。这意味着更好的质量和更少的时间浪费在过时的代码上。您可以设置多达八个不同的自定义选项。</li>
</ul>
<p>让我们深入了解 CodeWhisperer 的两个功能：</p>
<ul>
<li>参考跟踪器监控您的代码与开源列表的比较，显示开源代码用于分发的许可证类型。这对于遵守法律和知识产权（IP）权利非常有用。参考跟踪显示项目的代码库、文件引用和许可证信息的注释。这有助于根据您组织的合规要求决定是否使用建议。</li>
<li>安全扫描在您的 IDE 中运行，检查漏洞，包括前 10 个开放 Web 应用程序安全项目（OWASP）威胁和常见弱点枚举（CWE）列表。它甚至遵循加密库的最佳实践。如果安全扫描发现漏洞，它会提供一些修复建议。这加快了进程并降低了开发成本。考虑到生成的代码可能出现的怪癖，拥有这个内置安全功能是一个巨大的优势。</li>
</ul>
<p>CodeWhisperer 的一个优点是它与 AWS 服务的结合。这意味着开发人员不需要成为 AWS 大师或翻阅大量文档即可使用 AWS。以下是一些您可以提示它执行的示例：</p>
<blockquote>
<p>编写一个 Python 函数将文件上传到 S3 存储桶。</p>
<p>构建一个 Python Lambda 处理程序来处理 Kinesis 数据流中的记录。</p>
<p>编写一个 Java 方法，通过排序键查询 DynamoDB 表中的项目。</p>
<p>编写一个 bash 脚本，通过实例 ID 使用 AWS CLI 停止 EC2 实例。</p>
<p>使用 AWS CDK 和 TypeScript 创建一个 PostgreSQL 引擎的 RDS 实例。</p>
</blockquote>
<p>亚马逊对使用代码提示工具的客户进行了研究，发现平均而言，开发人员成功完成任务的可能性提高了 27%，完成速度比未使用该工具的开发人员快 58%。</p>
<p>以埃森哲的经验为例。使用代码提示助手进行人工智能项目的开发时间减少了多达 30%。数据预处理等通常耗时且繁琐的任务变得更快更高效。通过简单使用以下提示，开发人员显著提高了他们的生产力：</p>
<blockquote>
<p>创建一个机器学习数据的预处理数据类脚本</p>
</blockquote>
<p>考虑持久系统，一家全球数字工程公司。通常，新开发人员需要至少四个月的培训才能准备好项目。然而，使用 CodeWhisperer，他们将这个时间缩短到仅一个月。</p>
<h1 id="谷歌开发者的Duet-AI"><a href="#谷歌开发者的Duet-AI" class="headerlink" title="谷歌开发者的Duet AI"></a>谷歌开发者的Duet AI</h1><p>谷歌是Duet AI的幕后推手。这个巧妙的人工智能编程工具支持 VS Code、IntelliJ、PyCharm、GoLand、WebStorm、云工作站和云终端编辑器等 IDE。此外，它支持超过 20 种编程语言。它还基于 Gemini，这是谷歌的顶级LLM。</p>
<p>Duet AI 具有您通常会在人工智能辅助编程系统中看到的功能，例如聊天。还有一些快捷方式，称为智能操作，这是用于代码解释和单元测试等的单击魔法技巧。</p>
<p>Duet AI 也非常重视安全。它拥有您所需的所有强大保护和安全措施，例如私有端点（私有 Google 访问）、VPC 服务控制和企业级访问控制。</p>
<p>并且不要忘记治理规则。当你将代码投入 Duet AI 时，可以放心，它不会被用于训练任何共享模型或构建产品。你对数据和知识产权拥有完全控制权。它还会标记出 Duet AI 认为某些代码可能是从某个代码库复制的情况。</p>
<p>谷歌与 Duet 的战略很大一部分是建立一个广泛的合作伙伴生态系统。例如，一些合作伙伴为谷歌云上的特定环境提供开发者支持。这可以提供更好的代码建议以及文档和知识来源。以下是一些示例：</p>
<p> 弹性这是搜索分析领域的高手。它的 Duet AI 集成允许开发者在不离开开发环境的情况下获取关于如何查询、测试和处理 Elastic 数据的详细信息。</p>
<p> 哈希公司这是一个云基础设施自动化软件的顶级提供商。它构建了一个系统，使得使用 Terraform 编写基于 HashiCorp 配置语言（HCL）的配置和自动化变得简单。</p>
<p>MongoDB这是 NoSQL 数据库的领导者。使用 Duet AI，您可以获取最佳实践并获得构建应用程序的帮助。</p>
<p>Neo4j这是图数据库的一个重要特性。您可以使用 Duet AI 获取有关 Cypher 查询语言等方面的建议。这可以使发掘复杂数据集中的隐藏关系和模式成为可能。</p>
<p>Duet AI 有一个巧妙的技巧。它已将Duet AI 集成到 Google Cloud 控制台中。要使用它，请点击控制台主屏幕右上角的激活按钮。然后会弹出一个聊天面板，如图 5-1 所示。您可以输入创建脚本、理解日志或深入 JSON 等任务的提示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0501-20240829123909-v0x63j9.png"></p>
<p>图 5-1. 点击激活后，Google Cloud 中的 AI Duet 聊天面板出现在右侧</p>
<p>聊天功能甚至可以在 Google 日志浏览器中使用。如果您发现一个有问题的日志，请突出显示它并点击解释此日志按钮。日志将直接弹入聊天面板，从那里您可以请求解释，甚至获得一些修复建议。</p>
<p>Duet 人工智能的费用是每个用户每月 19 美元。还有一个前期年度承诺。如果您是新的 Google Cloud 客户，您将获得 300 美元的免费信用。</p>
<p>  注意</p>
<blockquote>
<p>图灵人工智能是一家人工智能技术服务公司，一直在使用Duet人工智能。它已经能够实现开发团队生产力提升 33%。</p>
</blockquote>
<h1 id="Tabnine"><a href="#Tabnine" class="headerlink" title="Tabnine"></a>Tabnine</h1><p>Tabnine 是人工智能辅助编程工具的先驱。它始于 2013 年，当时 Dror Weiss 和 Eran Yahav 成立了公司。他们自 1990 年代以来一直从事软件行业，专注于代码分析和模拟。但正是他们在开发复杂性方面的实践经验让他们产生了一个灵感：如果人工智能可以成为解决方案呢？</p>
<p>确实，它确实有帮助。然而，这是在transformer模型时代之前。面对没有其他选择的情况，创始人们卷起袖子，构建了自己的模型。这段旅程帮助他们深入理解了人工智能在软件开发中的作用。快进到最近几年，Tabnine 已经采用了transformer模型。</p>
<p>公司在安全系统上进行了大量投资。它的工作原理是：当你在编写代码时，每个字符都会被标记化并加密，然后发送到 Tabnine 的推理服务器，该服务器可以是基于云的或本地的。Tabnine 明确表示不存储你的数据，且没有员工可以读取这些数据。此外，Tabnine 提供 SOC-2 合规性。</p>
<p>为了训练其模型，该公司使用了具有宽松许可证的开源代码，如 MIT、Apache 和 BSD。这对于希望保护其知识产权的组织非常重要。Tabnine 还重视其用于训练的代码的透明度。它甚至为开发者提供了选择退出可能用于 Tabnine 训练数据集的代码库的方法。这显示了该公司在训练生成模型时对许可证的谨慎态度。</p>
<p>Tabnine 的定价结构包括三个层级：</p>
<ul>
<li>入门计划是免费的，面向个人用户，提供基本功能，如短代码补全和社区支持。</li>
<li>专业版计划每月每位用户 12 美元。它专为专业开发人员和小型团队设计，包含高级功能，如整行和完整函数代码补全，以及自然语言到代码的补全，并提供标准支持。</li>
<li>企业版计划旨在为寻求全面安全、控制和定制的大型组织提供服务。它提供无限用户、私有和自定义的人工智能模型、私有部署选项以及高级支持。定价可根据请求提供。</li>
</ul>
<p>Tabnine 拥有大量用户基础，每月超过一百万用户，每天有数十万用户与之互动。值得注意的是，一些知名客户包括谷歌、亚马逊、奈飞和 Atlassian。</p>
<h1 id="Replit"><a href="#Replit" class="headerlink" title="Replit"></a>Replit</h1><p>Replit 是一个多功能的基于网页的 IDE，支持多种编程语言，并允许托管应用程序，称为 repls。它丰富的协作功能类似于 Google Docs 中的功能。为了扩展其覆盖范围，Replit 还开发了桌面版本，适用于 macOS、Windows、Linux、Android 和 iOS。该平台拥有大约 2300 万开发者的庞大社区。</p>
<p>Replit 成立于 2016 年，由 Amjad Masad、Faris Masad 和 Haya Odeh 创办。Replit 的概念是在成立前十多年由 Amjad 构思的。在此期间，Amjad 在雅虎和 Facebook 担任工程师，专注于开发工具的构建。他还在 Codecademy 的创立中发挥了重要作用，进一步展示了他对创新技术和编码教育的承诺。</p>
<p>Replit 提供三个订阅层级：</p>
<ul>
<li>免费套餐提供无限制的公共代码片段和 10GB 存储空间。</li>
<li>黑客计划每月每用户 7 美元，提供无限制的私有重启。它提供不同级别的内存和存储以满足不同需求。</li>
<li>专业版每月每用户 20 美元，包含黑客版的所有内容。此外，虽然基础代码开发系统在两个较低级别中都可用，但专业用户可以独享最强大的人工智能模型以及高级功能，提供更强大的代码开发体验。</li>
</ul>
<p>Replit 是一个一体化的软件创建平台，”Replit 的市场营销和设计副总裁 David Hoang 说道。“产品体验旨在减少软件开发过程中的摩擦：开发环境、代码编写和部署到生产环境。因此，Replit 能够在代码生成之外集成人工智能。我们的代码补全模型也由我们自己的语言模型驱动。”</p>
<p>Replit 的LLM经过一万亿个令牌的训练，能够理解 30 种编程语言。在使用 Replit 时，您在公共 repl 中编写的代码，包括按键，可能会用于进一步训练 Replit AI。如果您希望将您的工作保持私密并不参与训练池，您可以选择将您的 repl 设置为私有。重要的是要注意，使用 Replit AI 时您对代码的权利不会改变。公共 repl 中的代码自动根据 MIT 许可证授权，如 Replit 的许可信息中所述。</p>
<p>图 5-2 显示了 IDE。左上角是文件树和搜索框。中间是编辑器，输出（例如控制台）显示在屏幕右侧。左下角是可用工具。如果选择 AI，聊天功能会出现在右侧面板。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0502-20240829123910-81m1o96.png"></p>
<p>图 5-2. Replit 的用户界面包括文件树和搜索框、选择工具的图标、编辑器框和输出面板</p>
<p>如果您突出显示代码并按右键，您将获得这些选项：</p>
<ul>
<li><p>解释: Replit 提供了一个功能，可以对您的代码给出有帮助的解释。如果解释不太准确，您可以简单地点击重试，让 Replit 再试一次。此外，如果您有具体问题，可以从解释框顶部的下拉菜单中选择询问聊天选项。Replit 还提供其他有用的功能，例如询问 Replit 文档、编辑代码和生成代码，以帮助您编写代码。</p>
</li>
<li><p>修改（Ctrl+I）: 在 Replit 中，您可以通过提示修改代码。例如，如果您已突出显示二分查找的代码部分，您可以写一个提示请求将该 Python 代码转换为 JavaScript 函数。或者，您可以请求将代码更改为使用递归方法。修改功能提供了一种灵活和互动的方式来实验和优化您的代码。</p>
</li>
</ul>
<p>为了展示这个工具是多么用户友好和强大，我们来看看一些有趣的故事：</p>
<ul>
<li><p>糖尿病应用程序: 当位于伦敦的 iOS 开发者马尔万·埃尔瓦拉基得知他弟弟被诊断为糖尿病时，他决心创建一个监测血糖水平的应用程序。他和他的妻子萨尔瓦·阿拉米想要合作创建一些有用且独特的东西。“在飞机上，我通过将小部件应用程序与血糖追踪器的 API 连接，原型化了一个锁屏小部件，并能够看到我弟弟的血糖，”马尔万说。“这比打开应用程序查看最新读数要好得多。”</p>
<p>他们添加了发送消息的按钮，并改善了短信功能。然后他们将其发布为 iOS App Store 上的公共应用。</p>
<p>虽然马尔万是一名经验丰富的移动前端开发人员，但他在 Python 或后端开发方面经验不多，而萨尔瓦是一名没有编码经验的产品经理。起初，他们使用ChatGPT，但 Replit AI 会带来很大变化。“这些人工智能工具帮助生成或至少对我应用程序编写的几乎所有后端进行双重检查，”马尔万说。“我听说过开发人员生产力大幅提高的故事，我可以诚实地证明在我这里也是如此。”</p>
</li>
<li><p>黑客马拉松到创业: Priyaa Kalyanaraman 在微软、Snapchat 和 Waymo 担任产品经理的经历令人印象深刻，尽管她没有技术背景，但并没有让这成为障碍。她参加了 Craft Ventures 人工智能黑客马拉松，利用 Replit AI 开发了一款旨在简化和增加内容创作乐趣的应用。她的努力得到了丰厚的回报，赢得了 1 万美元的大奖。凭借她的产品管理专业知识，她精心准备了详细的规格，并逻辑性地构建了应用。这个获奖应用后来成为了她的初创公司 Lica 的基础，该公司成功获得了种子前投资轮。</p>
</li>
</ul>
<h1 id="CodeGPT"><a href="#CodeGPT" class="headerlink" title="CodeGPT"></a>CodeGPT</h1><p>CodeGPT，针对 VS Code 设计的扩展，提供多种定价选项。这些选项从免费计划到每用户每月 49.99 美元的高级套餐不等。对于想在订阅之前测试服务的用户，还有 10 天的免费试用。</p>
<p>设置 CodeGPT 扩展，首先点击文件。然后导航到偏好设置并选择设置。这将打开设置窗口。在左侧，点击扩展，然后选择 CodeGPT。</p>
<p>CodeGPT 有趣之处在于它能够与多种 LLMs 集成。这包括来自 OpenAI、Cohere、AI21 和 Anthropic 等模型。与 Hugging Face 设置 API 账户可以访问广泛的开源平台，进一步扩展工具的多功能性。</p>
<p>一旦选择了模型，就可以根据以下因素进行配置：</p>
<ul>
<li>最大令牌数用于提示和响应</li>
<li> 温度</li>
<li>窗口内存（聊天中过去线程的数量）</li>
</ul>
<p>另一个有趣的功能是 CodeGPT 的 API，它方便用于聊天机器人、虚拟助手或任何其他需要理解和生成类人文本的系统。其 RESTful API 设计确保了广泛的兼容性和与各种平台的简单集成。此外，CodeGPT 还提供了 Python 和 JavaScript 的 SDK，增加了实现的灵活性。该 API 是一个更广泛的倡议的一部分，旨在改进编码过程，旨在使复杂的人工智能工具可用于各种开发项目。</p>
<h1 id="Cody"><a href="#Cody" class="headerlink" title="Cody"></a>Cody</h1><p>2013 年，Quinn Slack 和刘北洋共同创立了 Sourcegraph，旨在开发代码搜索工具。刘北洋受到他在谷歌的经历启发，他亲眼见证了公司内部代码智能和洞察平台的优势，这对于处理大型代码库特别有利。</p>
<p>Sourcegraph 的主要目标是创建先进工具来处理“大代码”。复杂性水平是该领域的一大挑战。Sourcegraph 的一项调查突出了这个问题：约 77%的开发者报告他们的代码库在三年内增加了五倍。此外，72%的人表示担心不断增长的大代码规模可能对他们公司的创新能力和竞争力构成真正威胁。</p>
<p>人工智能在 Sourcegraph 的战略中发挥着关键作用，公司开发了一种名为 Cody 的人工智能驱动代码生成系统。Cody 依赖于LLMs来自Anthropic和OpenAI。还使用了 Starcoder。</p>
<p>“我们利用了我们的搜索能力来开发这个工具，”刘说。“请记住，开发者 80%的时间是用来阅读和理解代码，而不是创建代码。因此，Cody 会扫描整个代码库。但我们也让引入其他库和框架变得简单。我们看到的结果更好。”</p>
<p>以下是您可以在此平台上使用的一些提示：</p>
<blockquote>
<p>提示：这个代码库是如何结构化的？</p>
<p>提示：这个文件有什么作用？</p>
<p>提示：X 组件定义在哪里？</p>
</blockquote>
<p>在定价方面，Sourcegraph 提供免费产品和两个付费层级：</p>
<ul>
<li><p>免费套餐包括代码自动补全、聊天和上下文感知等各种功能。</p>
</li>
<li><p>专业版每位用户每月 9 美元。使用专业版，您将获得：</p>
<ul>
<li>无限制自动完成、消息和命令</li>
<li>大规模代码库的个性化</li>
<li>多个LLM聊天选项</li>
<li>更高级别的支持</li>
</ul>
</li>
<li><p>企业版针对大型组织的需求量身定制。每位用户每月费用为 19 美元，提供：</p>
<ul>
<li> 用户管理</li>
<li> 单租户部署</li>
<li> 审计日志</li>
<li>汇总组织使用情况</li>
<li>测试阶段每日限额</li>
<li> 网页和 API 访问</li>
<li> 可配置 LLMs</li>
</ul>
</li>
</ul>
<p>为了了解 Cody 的潜力，让我们考虑一下全栈开发者和 Cody 的开源贡献者 Deepak Kumar 的看法：“对我来说，突出的功能是聊天和命令。我使用聊天来回答任何与编码相关的问题、项目的启动想法或修复 bug。命令是预定义的自定义提示，这很有帮助，因为它们帮助我完成临时任务，比如编写文档和添加测试。”</p>
<p>2021 年 7 月，Sourcegraph 宣布完成 1.25 亿美元的 D 轮融资，估值 26.25 亿美元。投资者包括安德森·霍洛维茨、Insight Partners 和 Geodesic Capital。</p>
<h1 id="CodeWP"><a href="#CodeWP" class="headerlink" title="CodeWP"></a>CodeWP</h1><p>WordPress 是一个非常流行的开源内容管理系统（CMS），以其简单性和多功能性以及丰富的主题和插件选择而闻名。最初作为一个博客平台推出，它已经扩展到适应各种类型的网站，包括优化用于电子商务、作品展示和一般业务的网站。它的吸引力在于用户友好的界面和可定制的选项。网络上很大一部分依赖于 WordPress；W3Techs 报告称，约 45.8%的互联网网站由该平台提供支持。</p>
<p>人工智能辅助编程为 WordPress 开发提供了重要机会，CodeWP 抓住了这一潜力。该公司由詹姆斯·勒佩奇创立，他在高中时期创建了一个 WordPress 代理机构。尽管业务快速增长，但人力密集。引入人工智能辅助编程技术显著提高了生产力。一个关键好处是詹姆斯对 WordPress 开发中常见用例的深刻理解，这进一步增强了人工智能的有效性。</p>
<p>CodeWP 提供一个基于网页的平台，包含免费版本和两个高级选项。两个高级计划均提供高达 33%的年度订阅折扣：</p>
<ul>
<li>专业版计划，价格为每月每用户 18 美元，提供额外的人工智能交易、项目和支持。</li>
<li>对于大规模需求，代理计划每用户每月 48 美元。该计划适用于专业的网页开发和营销公司，提供无限项目和协作功能。</li>
</ul>
<p>访问 CodeWP 网站创建账户。点击创建新内容，然后选择新代码片段以创建代码或新聊天如果您只是有问题。</p>
<p>屏幕左侧有存储代码片段的选项，以及跟踪对话和列出项目的选项。中间是编辑器，显示您正在处理的文件内容。如果您想创建新文件，可以点击新建文件。右侧是聊天功能。</p>
<p>这里有一些示例提示：</p>
<blockquote>
<p>注册一个自定义文章类型，名称为“书籍”，标签为“Books”。</p>
<p>创建一个名为“我的小部件”的 WordPress 小部件，使用 WP_Widget 类。</p>
<p>创建自定义插件激活钩子用于 register_activation_hook 函数。</p>
</blockquote>
<p>CodeWP 扩展了对 WordPress 生态系统中各种关键组件的支持。这包括与主要工具的兼容性，如 WooCommerce、WPSimplePay、Gravity Forms、SearchWP 和 Contact Form 7 等。</p>
<p>CodeWP 具有实时预览选项，可以即时查看您的代码将执行的内容，使测试和调试变得轻而易举。此外，在处理 WordPress 项目时，CodeWP 简化了部署过程。其集成工具允许您轻松将代码转移到 WordPress 网站，使在实际环境中应用和测试代码的任务变得更加高效。</p>
<h1 id="Warp"><a href="#Warp" class="headerlink" title="Warp"></a>Warp</h1><p>命令行界面始于 1960 年代，伴随着 Multics 和 Unix 等早期操作系统的发展。尽管多年来出现了华丽的图形界面，但命令行界面基本上保持了其本源。它的核心就是保持简单：你以纯文本输入命令，得到的只是你需要的内容，没有多余的装饰。</p>
<p>命令行界面非常普遍，尽管它们很简单。它们对于管理云系统、处理计算机上的文件和程序以及设置顺畅的工作流程至关重要。它们擅长自动化任务、处理数据、管理网络和开发软件。</p>
<p>掌握命令行界面可以大大加快速度并提高精确度。一个显著的好处是可以组合不同的命令来处理复杂任务。此外，由于可以编写这些命令行，您有更多空间根据自己的喜好进行调整和自动化任务。这意味着开发人员可以根据需要设置，优化整个工作流程，使其更加顺畅和高效。</p>
<p>虽然命令行界面很强大，但并不完美。一个大问题是它们不适合协作，因此可能会影响生产力和团队合作。当你关闭终端会话时，你会失去所有内容。命令行通常也局限于一台机器，这使得在设备之间切换变得麻烦。此外，终端可能让人感到畏惧，尤其是对于复杂的任务。还有一点不能忘记：熟练掌握命令行命令及其语法对很多人来说并不是一件容易的事。</p>
<p>所以是的，这个领域有创新的空间。一个正在引领潮流的初创公司是 Warp。</p>
<p>扎克·劳埃德，创始人兼首席执行官，于 2020 年创办了公司。在此之前，他在谷歌担任 Google Sheets 的首席工程师。“我已经做了超过 20 年的开发者，”劳埃德说。“虽然命令行界面很强大且非常有用，但仍有很多改进的空间。”</p>
<p>Warp 是用 Rust 构建的，这是一种以快速和高效著称的编程语言。Warp 利用 Rust 的优势运行，几乎像你在计算机上安装的应用程序，但它就在你的浏览器中。这种巧妙的 Rust 应用意味着使用 Warp 的用户可以获得更流畅和更快速的体验，使整个应用交互变得更好。</p>
<p>将 Warp 视为增强版终端。它拥有高级文本输入功能，如选择、光标定位和补全菜单，使用户能够无缝浏览命令历史。这消除了滚动长文本的麻烦。此外，Warp 通过简单点击轻松复制输出。</p>
<p>在 Warp 中，每个命令及其输出形成一个独立的块。您可以轻松悬停在这些块上以回顾过去的命令。选择一个块可以使用 Warp AI，通过右键菜单访问，提供错误的解释和解决方案。这与传统命令行界面形成鲜明对比，后者提供的指导有限，并且在很大程度上依赖用户的专业知识来解读错误消息和故障排除。</p>
<p>扭曲人工智能还带有聊天功能。您可以通过以 # 开头来使用此功能。例如，假设您想知道以下内容：</p>
<blockquote>
<p>提示：# 如何使用 grep 在递归搜索中排除目录？</p>
</blockquote>
<p>Warp 将提供这个问题的答案，您可以将其复制到终端。</p>
<p>现在请记住，劳埃德是Copilot的热心用户，用于他自己的开发。“我在使用这个工具的同时也使用 Warp，”他说。“它们配合得很好。”</p>
<p>Warp 的忠实粉丝是 Instagram 的联合创始人迈克·克里格。他说：“我每天在工作中都在使用 Warp。我最喜欢的就是速度：无论是它的工作速度还是使用时的感觉速度，尤其是出色的预输入和搜索。Warp 将终端带入现代，我迫不及待想看看他们将 Warp 带到哪里。”</p>
<p>Warp 可在 Mac、Linux 和 Windows 上使用。也有网页版。Warp 的定价分为三个等级：</p>
<ul>
<li>免费版每天提供最多 20 个 AI 请求。</li>
<li>团队版，每个用户每月 12 美元，提供每天最多 100 个 AI 请求。</li>
<li>大型组织有特定需求时，建议考虑企业版，定制的定价根据客户需求量身定制。</li>
</ul>
<h1 id="Bito-AI"><a href="#Bito-AI" class="headerlink" title="Bito AI"></a>Bito AI</h1><p>2006 年，Amar Goel 和 Anand Das 创办了 PubMatic，一家在线广告公司，并于 2020 年上市。他们在 PubMatic 的旅程使他们认识到人工智能提升编码生产力的潜力，从而激发了 Bito AI 的想法。Mukesh Agarwal 凭借在微软和安永的产品负责人经验加入他们，成为创始团队的一部分。</p>
<p>Bito拥有多语言能力，支持 20 种语言，包括独特的混合语言，如印英混合语，这是印地语和英语的结合。</p>
<p>该工具配备了几个显著的功能。其中一个功能允许您为常用编码结构创建自定义提示模板，从而简化开发过程。此外，该平台包括安全性和性能检查，提供优化建议，以提高代码的安全性和效率。</p>
<p>Bito 拥有大约 240,000 个令牌的上下文窗口，增强了其理解和分析能力。此外，它使用本地于用户机器的向量数据库。这使得系统能够有效处理大型代码库，确保生成更相关和准确的结果。这一能力显著提高了该工具在管理大型编码项目中的效率和有效性。</p>
<p>它在处理内存泄漏方面也表现良好。这种情况发生在程序占用了一些计算机的 RAM 后忘记释放。如果这种情况持续发生，可能会导致真正的麻烦。随着程序的运行，它不断泄漏内存，这会占用你可用的总内存。这可能会导致系统变慢，因为你的系统开始使用交换空间，因为剩余的物理内存不足。如果泄漏情况非常严重，内存泄漏甚至可能导致程序或整个计算机崩溃，因为内存耗尽。</p>
<p>内存泄漏可能很难发现和修复。它们通常不会立即导致问题，可能只有在程序运行一段时间后才会开始出现。这种延迟使得识别和解决它们变得更加困难。但 Bito 可以嗅探潜在的内存泄漏。您只需使用 IDE 中插入选定代码的选项，并输入类似这样的提示：</p>
<blockquote>
<p>提示：识别代码中的任何问题。</p>
</blockquote>
<p>而且你猜怎么着？它不仅标记问题，还提供了一些建议的修复方法。</p>
<p>在隐私方面，Bito 确保不存储您的实际代码。然而，它会保留在此过程中生成的元数据。</p>
<p>有两个版本可用：</p>
<ul>
<li>个人用户有免费版本。</li>
<li>每位用户每月 15 美元的付费选项。包括无限制的人工智能代码补全和访问广泛的 240,000 令牌上下文窗口，增强整体编码体验。</li>
</ul>
<p>  注意</p>
<p>根据比特内部分析，工具用户报告生产力提高了 31%。他们每月使用该工具近 200 次。目前，该平台拥有大约 100,000 名用户。</p>
<h1 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h1><p>Anysphere 是 Cursor 的开发者。该公司对其确实有一个大胆的愿景：</p>
<blockquote>
<p>在接下来的几年里，我们希望构建一个比世界上任何时候都更有帮助、更愉悦和有趣的代码编辑器。光标应该是一个不可能写出 bug 的地方。一个可以用 50 行伪代码快速生成 2000 行 PR 的编辑器。一个可以即时回答任何代码库问题的工具。也许甚至是一个源代码本身开始融化的界面……</p>
</blockquote>
<p>与此同时，Cursor 仍然非常强大。它还吸引了像 OpenAI 这样的投资者的兴趣。2023 年 10 月，该公司成功筹集了 800 万美元的资金，使其总筹资额达到 1100 万美元。</p>
<p>Cursor 提供在 GPT-4 和 GPT-3.5 之间的选择，但它还通过专有模型增强其能力。这些模型包括 14 亿个向量和访问 15 万个代码库。此外，该平台还结合了先进的人工智能技术，如默克尔树，进一步提升其有效性。</p>
<p>Cursor 是 VS Code 的一个分支，兼容 Windows、Mac 和 Linux。这是一个很大的优点，因为它免去了你学习新 IDE 的麻烦。当你下载 Cursor 时，它方便地让你导入现有的 VS Code 扩展。你可以在命令行界面中利用它的人工智能功能，将高级能力无缝集成到你熟悉的编码环境中。</p>
<p>例如，在聊天区域，您可以轻松导入文档并向其提问。以下是一个示例提示：</p>
<blockquote>
<p> 提示：@python 文档</p>
</blockquote>
<p>或者你可以使用@来处理特定文件。你可以输入类似于：</p>
<blockquote>
<p>提示：@the_app.ts 的作用是什么？</p>
</blockquote>
<p>光标提供直接在终端调试的能力。它的人工智能会筛选您的文件，并进行逻辑处理以定位并尝试解决问题，从而简化故障排除体验。</p>
<p>杰弗里·拜尔斯，全栈网页开发者，是 Cursor 的早期用户。他说：</p>
<blockquote>
<p>我真的很喜欢能够通过按键快速加载应用程序上下文到人工智能中。这在回答问题、记忆语法、重构小段代码和编写模板时效果很好。然而，当被要求理解分散在多个文件中的大型数据模型时，它达到了极限。不过，随着模型的改进，比如更大的上下文窗口，这只会变得更好。</p>
</blockquote>
<p>托什·维拉加是 Cursor 的另一位用户。他是一名软件工程师，也是多个人工智能公司的创始人，如 Typeblock 和 STBL，制作Stable Diffusion。据他说：</p>
<blockquote>
<p>我非常喜欢的一个功能是 Command+L 快捷键来询问代码相关的问题。当我在一个我没有经验的后端语言的新代码库中时，这非常有用。这个功能帮助我更快地熟悉代码。还有一个我认为是好处的地方是你可以带上自己的 API 密钥，这样可以节省成本并在 GPT-3.5 和 GPT-4 之间切换。</p>
</blockquote>
<h1 id="Code-Llama"><a href="#Code-Llama" class="headerlink" title="Code Llama"></a>Code Llama</h1><p>越来越多的开源项目专注于人工智能辅助开发，这在学术界也是一个热门话题。这个领域的知名名字之一是 Meta。其 Code Llama 系统自 2023 年 8 月推出以来引起了广泛关注。</p>
<p>Code Llama基于 LLaMA 2 LLM，训练了惊人的 2 万亿个标记，上下文长度为 4096 个标记。它包括经过微调的模型，这些模型经过超过一百万个人工注释的训练，使其更加有效和可靠。</p>
<p>LLaMA 2 有特殊版本，如 LLaMA 2-Chat，专为聊天应用程序量身定制，在关键基准测试中优于其他开源聊天模型，特别是在有用性和安全性方面。此外，它与 Hugging Face 等平台集成，并与微软和亚马逊等公司在云服务部署方面建立了主要合作关系。</p>
<p>Code Llama是多功能的，支持大多数主流语言，如 Python、C++、Java、PHP、JavaScript、C#和 Bash。它有三种模型大小，分别为 70 亿、130 亿和 340 亿参数。它们都是在 5000 亿个代码令牌上训练的。7B 和 13B 模型的有趣之处在于它们具备填充中间的能力，因此可以将代码插入现有脚本中。这使得它们在代码补全等任务中非常有用。7B 模型只需在单个 GPU 上运行，通常速度更快。但正如你所期待的，34B 模型在性能上更强大。</p>
<p>Code Llama超越了 LLaMA 2 基础模型的功能。它的所有模型都可以处理多达 100,000 个上下文令牌。这对于编写较长程序的代码非常有用。更大的上下文窗口也使其在调试方面表现出色。</p>
<p>有几个专门版本的Code Llama。首先是 Python 版本，它通过使用大量的 1000 亿个代码令牌进行了优化。然后是指令版本。这个版本在自然语言方面进行了额外训练，以提高自然语言应用的结果。</p>
<p>Code Llama 34B 表现出色。在 HumanEval 上得分为 53.7%，在 MBPP（主要基础 Python 编程）上得分为 56.2%。这些分数优于其他开源项目，Code Llama的表现与ChatGPT相当。此外，Code Llama经过了安全测试。Meta 指出，它的响应甚至比ChatGPT更安全。</p>
<h1 id="其他开源模型"><a href="#其他开源模型" class="headerlink" title="其他开源模型"></a>其他开源模型</h1><p>在开源代码生成方面出现了一些很酷的创新。让我们来看看一些突出的平台。</p>
<h2 id="StableCode"><a href="#StableCode" class="headerlink" title="StableCode"></a>StableCode</h2><p>Stability人工智能，开发了流行的文本生成图像系统Stable Diffusion，推出了 StableCode。StableCode 是在开源项目 BigCode 上训练的，该项目是 Hugging Face 和 ServiceNow Research 的合资企业。BigCode 整理了一个名为 The Stack 的数据集，这是一个庞大的 6.4TB 独特、可自由使用的 GitHub 代码集合，非常适合用于训练人工智能模型。</p>
<p>StableCode 拥有独特的技术，使用旋转位置嵌入（RoPE）而不是 ALiBi（带线性偏置的注意力）方法。StableCode 经过了显著的微调，包括清理数据。它非常灵活，支持 Python、Go、Java、JavaScript、C、Markdown 和 C++等语言。</p>
<p>有三个版本的稳定代码可以查看：</p>
<p>StableCode-Completion-Alpha-3B-4k: 这是一个仅解码器模型，拥有 30 亿参数，非常适合处理多种语言和 4000 个令牌的上下文长度。</p>
<p>StableCode-Instruct-Alpha-3B: 也是一个 30 亿参数的模型，这个版本经过指令调优。</p>
<p>StableCode-Completion-Alpha-3B: 该版本也拥有 30 亿个参数，擅长进行广泛的代码补全，处理最多 16,000 个令牌。</p>
<h2 id="AlphaCode"><a href="#AlphaCode" class="headerlink" title="AlphaCode"></a>AlphaCode</h2><p>深度学习公司（DeepMind）是谷歌的一部分，开发了 AlphaCode 人工智能系统。它在代码竞赛中表现良好，在 Codeforces 网站的竞赛中排名前 54%。AlphaCode 能够处理需要批判性思维、逻辑、算法、编码技能和自然语言理解的各种困难任务。该系统甚至在《科学》杂志中得到了认可。</p>
<p>代码竞赛通常涉及棘手的算法和令人费解的理论问题，这与日常编程任务有些不同。以 AlphaCode 需要解决的一个测试为例，一个名为退格的难题。竞争者必须处理两个字符串 s 和 t，并使用退格将 s 转换为 t。成功不仅仅是正确解决复杂问题，还需要提出智能算法。这展示了竞争编程所需的高级问题解决技能。</p>
<p>深度学习公司旨在使用 AlphaCode 实现代码生成的完全自动化，标志着人工智能驱动编码的重大进展。</p>
<h2 id="PolyCoder"><a href="#PolyCoder" class="headerlink" title="PolyCoder"></a>PolyCoder</h2><p>PolyCoder 特别擅长加速 C 语言编程，因此该系统吸引了游戏开发者。PolyCoder 在多种语言中总结代码方面也很出色。由于在多样化的数据集上进行训练，它擅长识别多种编程语言中的常见模式和结构，如 C、C++、Java、Python 和 JavaScript。</p>
<p>PolyCoder 的训练数据集为 249 GB，涵盖 12 种不同的编程语言。此外，它包含 27 亿个参数。</p>
<h2 id="CodeT5"><a href="#CodeT5" class="headerlink" title="CodeT5"></a>CodeT5</h2><p>CodeT5 使用了一体化的预训练编码器-解码器模型。这使得它擅长不同的编码任务，例如发现代码中的错误或查找代码克隆，以及处理新结构，无论是将编程语言转换为普通英语还是反之，甚至在编程语言之间切换。</p>
<p>它的设计包含一些特殊技巧，增强了它正确理解和输出代码的能力，充分利用了编程语言中内置的深层结构。</p>
<p>CodeT5 在 CodeXGLUE 的 14 个不同挑战中展示了其实力（代码的通用语言理解评估基准）。在所有生成任务中，它超越了 PLBART 等旧模型，如代码总结、将文本转换为代码、代码之间的翻译和代码润色。在理解任务方面，CodeT5 在查找错误方面非常有效，并且在识别抄袭代码方面表现同样出色。</p>
<h2 id="企业软件公司"><a href="#企业软件公司" class="headerlink" title="企业软件公司"></a>企业软件公司</h2><p>大型软件公司如 SAP、ServiceNow 和 Salesforce 正在开发自己的代码生成系统。它们拥有主要优势：庞大的客户基础、巨大的资源、广泛的分销网络和可信赖的品牌。它们庞大的人才库也是一个很大的帮助。此外，它们在市场上足够大，可以设定趋势和标准。</p>
<p>将新技术与现有产品集成意味着他们可以提供完整的解决方案，吸引客户回头。因为他们已经拥有基础设施和全球业务，他们可以快速扩展这些新技术，满足市场当前和未来的需求。</p>
<p>以下是这些公司的部分代码生成系统：</p>
<p> Salesforce 代码生成器: 这使得开发人员可以轻松调整他们在 Salesforce 中的 CRM 和其他组件。它帮助使用最新的 Salesforce 语言和框架来准确实现功能。此外，您可以从 Open VSX 市场获取第三方插件，这是一个大型的 VS Code 扩展开放平台。最棒的是？您无需麻烦安装或设置这些功能。它们可以立即使用。</p>
<p> SAP 构建代码: 这是为 Java 和 JavaScript 用户制作的。此外，它与 SAP Joule 连接，这是 SAP 自己的人工智能助手。您还可以访问一些强大的数据库系统，如 SAP 的 HANA（高性能分析 Appliance）。</p>
<p> StarCoder生成器:  LLMServiceNow 和 Hugging Face 联手创建了这个开源项目。它非常强大，拥有 150 亿个参数，并在超过 80 种编程语言上训练了高达一万亿个标记。他们遵循治理、安全等规则，仅在获得宽松许可证批准的代码上进行训练。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>人工智能辅助编程工具正在为开发者带来变革，提供一些非常酷的新功能。亚马逊、谷歌、Meta 和 Salesforce 等大公司都在关注这一领域。我们也不能忘记那些以其独特功能和实惠价格吸引眼球的小型创新初创公司。开源项目也在通过提供一流的人工智能编码工具而引起关注。</p>
<p>随着这些人工智能模型变得更大更智能，它们在编写、解释和调整代码方面变得更出色。展望未来，成功的企业将使这些工具与开发人员已经在做的工作无缝结合。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/09/06/aiassistedprogramming04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/06/aiassistedprogramming04/" class="post-title-link" itemprop="url">第4章  GitHub Copilot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-06 11:48:32" itemprop="dateCreated datePublished" datetime="2024-09-06T11:48:32+08:00">2024-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 11:55:47" itemprop="dateModified" datetime="2024-09-26T11:55:47+08:00">2024-09-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在本章中，我们将介绍 GitHub Copilot，我简称为 Copilot。它是人工智能编码助手领域的佼佼者。人们甚至称它为生成式人工智能的“杀手级应用”。这主要归功于它先进的代码建议、创建和解释能力，显著提高了开发者的生产力。通过根据上下文理解和预测编码模式，它不仅节省了时间，还帮助编写更高效和无错误的代码。</p>
<p>在本章中，我们将深入探讨 Copilot：它的费用、如何设置以及它提供的所有酷炫功能。我们也会真实地谈谈它的缺点。此外，我还会提供一些实用技巧，以便充分利用它。我们不会止步于此：我们还将看看 Copilot 如何与其他公司合作，参与 Copilot 合作伙伴计划。本章将全面展示 Copilot 的功能。</p>
<h1 id="GitHub-Copilot"><a href="#GitHub-Copilot" class="headerlink" title="GitHub Copilot"></a>GitHub Copilot</h1><p>在 2021 年 6 月，微软推出了 GitHub Copilot。GitHub 的首席执行官 Nat Friedman 在一篇博客中将其描述为“人工智能配对程序员”，旨在通过帮助开发人员更高效地完成任务来加快他们的工作。</p>
<p>Copilot 是微软与 OpenAI 合作的结果。最初，它利用了一种名为 Codex 的大型语言模型，这是针对编码的 GPT-3 变体。微软通过集成一种称为中间填充（FIM）的新方法增强了该 LLM 的能力，使其更好地理解代码上下文。这提高了代码建议的质量并缩短了响应时间。该增强功能由更先进的 GPT-3.5 Turbo 提供支持，导致代码建议的接受率明显上升。为了提高安全性，该工具集成了一个人工智能系统，以即时阻止风险编码模式，重点关注硬编码凭据和 SQL 注入等漏洞。</p>
<h2 id="定价和版本"><a href="#定价和版本" class="headerlink" title="定价和版本"></a>定价和版本</h2><p>Copilot 提供 30 天免费试用。试用结束后，您有三个选择。</p>
<p> 个人版: 该计划每月 10 美元或每年 100 美元。它提供多行函数建议等功能，可以使您的编码工作流程更加顺畅。一个突出特点是加速测试生成，这是确保您的代码可靠和稳健的关键因素。此外，它还有筛选易受攻击编码模式的功能。它还防止任何可能与公共代码相似的建议，确保您创建的内容是独特和原创的。</p>
<p> 商业版: 此套餐更为全面，费用为每位用户每月 19 美元。它包括个人版 Copilot 计划的所有内容以及一些为企业设计的额外福利。它简化了许可证管理，这对公司处理订阅和访问权限是一个很大的优势。还有一个用于管理组织内政策的功能，帮助确保治理的一致性和所有项目的一致性。一个主要亮点是其一流的隐私保护措施，这对于保护敏感的商业数据安全至关重要。此外，它支持企业代理，确保公司网络的安全和顺畅连接。</p>
<p>大型企业版: 每位用户每月收费 39 美元。企业版的主要特点是允许在内部代码库上训练系统。企业版提高了开发人员的效率，因为该工具开始提供更准确的代码建议。它有助于推动采用更好的实践并遵守安全规则。它针对开发人员内部编码的方式以及他们喜欢的 API、框架和包进行了定制。企业版的另一个优势是您可以在经典语言如 COBOL 和Fortran上进行训练。通用LLMs可能在这些语言上效果不佳，因为缺乏来自公共库的训练数据。当然，它们对您公司特有的专有语言也没有任何了解。GitHub 系统还通过持续扫描公司的代码库来增强企业版的模型。例如，它关注最近的拉取请求和合并，以及点赞和点踩反馈。所有这些都有助于突出公司正在使用的最新方法和策略。</p>
<p>拥有自定义模型有助于在组织内部传播知识。人工智能提取并分享隐藏在代码中的细微知识。随着持续的训练，人工智能跟上不断变化的代码库，使其帮助随着时间的推移变得更加精准。不过，组织处理与将这些人工智能工具融入开发过程相关的隐私和知识产权风险仍然非常重要。</p>
<p>  注意</p>
<p>2023 年，Gartner 的研究显示不到 10%的大型企业已经开始使用人工智能辅助编程工具。这种犹豫部分是由于对安全性和准确性的担忧。然而，随着技术的快速进步，预计越来越多的企业将在不久的将来开始采用这些工具。总之，它们提供的好处实在是太重要了，无法忽视。</p>
<h2 id="案例：编程硬件"><a href="#案例：编程硬件" class="headerlink" title="案例：编程硬件"></a>案例：编程硬件</h2><p>一个有趣的案例研究涉及先进微处理器公司（AMD）。成立于 1969 年，该公司是中央处理器（CPU）的先驱。如今，该公司是数据中心、嵌入式系统、游戏平台和个人电脑的半导体领导者。</p>
<p>在深入之前，让我们通过回顾一些关于硬件系统开发的基础知识来设定背景。这与为网页应用程序构建软件是完全不同的游戏。关键挑战在于开发人员需要深入了解硬件系统。与在通用计算机上运行的常规软件不同，固件直接与硬件对话。这需要一种更为严格的精确性和兼容性。</p>
<p>这种精确度至关重要，因为固件开发中的错误可能导致非常昂贵的后果。仅一个错误可能意味着数百万的财务损失。而且这不仅仅是钱的问题——时间也是一个重要因素。修复固件问题通常需要重新审视制造过程，这可能会延长几个月的时间表。这种延迟不仅影响发布计划，还影响产品在市场上的竞争力。</p>
<p>显然，在这种环境下，敏捷软件开发中常见的“快速行动和破坏事物”的思维方式是行不通的。这种方法的风险太大。因此，固件开发人员必须投入大量时间和精力进行详细规划和广泛测试。这种谨慎的方法确保固件在与硬件配对之前尽可能稳固和无错误。</p>
<p>当 AMD 在 2023 年查看Copilot时，设定了非常高的标准，并且有相当多的合理怀疑。在一个试点项目中，AMD 为各种硬件描述语言（HDL）创建了一个定制版本的Copilot，如 Verilog 和 SystemVerilog。HDL 是专门用于描述电子电路的架构、设计和功能的特定类型编程语言，特别是数字逻辑电路。它们对于在不同抽象层次上建模和模拟电子系统至关重要。</p>
<p>试点结果比预期的要好得多。令人惊讶的是，Copilot生成的代码风格实际上更符合 AMD 的标准，而不是他们自己程序员所编写的代码。改进是如此显著，以至于一些程序员甚至从使用 Vim 这个高度可定制的文本编辑器转向采用 Visual Studio Code 作为他们的 IDE。</p>
<h2 id="用例：Shopify"><a href="#用例：Shopify" class="headerlink" title="用例：Shopify"></a>用例：Shopify</h2><p>另一个有趣的案例研究是 Shopify。该公司运营一个平台，让客户建立电子商务网站。Shopify 在美国的市场份额约为 10%，在欧洲为 6%。</p>
<p>毫无疑问，这需要一个庞大的基础设施。考虑到大约有 300 个公共仓库和大约 5000 个私有仓库。此外，Shopify 每天大约进行 1500 次代码部署。</p>
<p>Shopify 是最早加入 Copilot 热潮的公司之一，这对提高开发者的生产力产生了重大影响。目前，近 2000 名 Shopify 开发者使用该工具。这里有个很酷的地方：70% 的人表示它很有帮助，75% 的人经常使用。来自 Copilot 的代码建议中约有 26% 被接受。</p>
<p>当然，有一些功能没有普及，比如与命令行界面（CLI）的集成。但尽管如此，很多开发者每天都在使用代码补全和聊天。</p>
<p>这里有一些有趣的收获：</p>
<ul>
<li>代码建议的价值：即使开发者不使用某个建议，这也不是完全的损失。任何建议都可以激发编写更好代码的想法。</li>
<li> 采用率：通常会随着时间的推移而增加，这并不令人惊讶。调整日常工作流程并习惯新功能需要时间。Copilot 也有一个学习曲线。</li>
<li>高级开发人员的采用：在Copilot刚被采用的早期，经验丰富的开发者并不太热衷于使用它。他们倾向于将其视为玩具而不是严肃的工具。但随着时间的推移，他们注意到其他开发者获得了真实的结果，他们开始对其产生好感。</li>
<li> 学习增强：Shopify 注意到Copilot擅长推动人们尝试新的语言或框架。例如，Rust 的采用明显增加。</li>
</ul>
<p>大约有百万行 Shopify 代码库是使用这个工具编写的，这表明Copilot对这个业务来说非常重要。</p>
<h2 id="用例：埃森哲"><a href="#用例：埃森哲" class="headerlink" title="用例：埃森哲"></a>用例：埃森哲</h2><p>埃森哲是一家大型专业服务组织，帮助客户通过创新技术和系统改善运营和增长。该公司在 120 多个国家拥有超过 733,000 名员工。</p>
<p>在 2023 年，埃森哲对Copilot进行了 450 名内部开发人员的测试。该公司没有设定任何具体任务或目标。相反，管理者只是要求每个人像往常一样进行工作。</p>
<p>在埃森哲进行的Copilot试验持续了六个月。那么，发生了什么呢？在编码方面，Copilot的建议接受率为 35%，其中 88%的更改在代码审查后仍然保留。生产力也显著提升。拉取请求增加了 50%，合并率上升了 15%。效率也大幅提升，构建数量增加了 50%，成功率提高了 45%。开发人员呢？他们对此非常满意：高达 96%的人觉得他们从第一天起就很成功。</p>
<p>在看到这些结果后，埃森哲决定在全球范围内向其 50,000 名开发人员推出Copilot。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>高德纳调查了超过 2000 名首席信息官（CIO），发现 66%的人计划在 2023 年将最多资源投入网络和信息安全。这个趋势已经持续多年。</p>
<p>在网络威胁变得越来越复杂和普遍的情况下，安全漏洞可能意味着巨大的财务损失、声誉受损、法律问题和运营中断。此外，随着数据隐私法规变得更加严格，首席信息官必须保持警惕以确保合规，以避免罚款并保持客户信任。</p>
<p>这就是为什么对于 GitHub 来说，安全是其Copilot计划的主要关注点。GitHub 开发了一个基于LLMs的系统，可以在发生时发现并修复不安全的编码模式。</p>
<p>然后还有 GitHub 的高级安全功能，由 Copilot 提供支持。以下是主要功能：</p>
<p> 代码扫描：实时高级安全将搜索安全漏洞和编码错误。</p>
<p> 秘密扫描：该产品可以挖掘出已检查到私有仓库中的密钥和令牌等秘密。</p>
<p> 依赖审查：这显示了依赖项更改的影响。它还提供了合并拉取请求时的漏洞详细信息。</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>要开始使用Copilot，您首先需要创建一个 GitHub 账户。GitHub 是一个支持版本控制和协作软件开发的在线服务。它基于 Git 构建，Git 是一个提供代码审查和项目管理功能的工具。</p>
<p>设置好您的账户后，点击屏幕右上角的个人资料照片。您将看到一个下拉菜单，如图 4-1 所示。</p>
<p>选择Copilot然后点击启用 GitHub Copilot。您可以选择计划类型，然后点击继续。您将提供您的支付信息，假设您不符合免费账户的资格。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0401-20240829123924-trxnxs8.png"></p>
<p> 图 4-1. 从个人资料照片下拉菜单开始启用 Copilot</p>
<h2 id="Codespaces-和-Visual-Studio-Code"><a href="#Codespaces-和-Visual-Studio-Code" class="headerlink" title="Codespaces 和 Visual Studio Code"></a>Codespaces 和 Visual Studio Code</h2><p>有两种使用Copilot的方法。一种方法是通过 Codespaces 访问它，这是一个基于云的开发环境，运行在 Visual Studio Code（VS Code）上，直接在 <a target="_blank" rel="noopener" href="https://github.com/">https://github.com</a> 上可用。</p>
<p>或者，如果您使用的是 Visual Studio Code 的桌面版本，可以选择Copilot扩展。在本书中，我们将重点使用 VS Code 扩展。</p>
<p>IDE 本身是免费的。图 4-2 显示了 VS Code 的主屏幕。您可以在各种平台上运行此系统，包括 Windows（版本 7、8、10 和 11）；macOS；以及各种 Linux 发行版，如 Ubuntu、Debian、Fedora 等。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0402-20240829123924-6xnt4gi.png"></p>
<p>图 4-2. Visual Studio Code 的主屏幕包括活动栏和生成及显示代码的区域</p>
<p>左侧是活动栏，它是一堆图标。您可以使用这些图标加载文件和文件夹。您还可以选择第五个图标，即方块组，进入安装扩展的区域（图 4-3）。</p>
<p>如果在搜索框中输入“GitHub Copilot”，您将看到扩展列表。选择顶部的一个并点击安装。</p>
<p>然后查看屏幕右下角。如果您看到Copilot图标，则表示您可以使用该服务。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0403-20240829123925-u7tbrp9.png"></p>
<p>图 4-3. 您可以在 VS Code 中安装扩展，例如 Copilot</p>
<p>在屏幕中间，您将看到打印“你好，Copilot！”的代码。这是通过使用以下提示创建的，Copilot 转换成代码：</p>
<blockquote>
<p><em>Prompt:</em> # write a “Hello, Copilot!” program</p>
</blockquote>
<p>#字符指定注释。这是指示Copilot生成代码的一种方式。</p>
<p>注意代码是用 Python 编写的。为什么呢？文件的扩展名是 py。Copilot使用文件扩展名来确定使用什么语言。</p>
<p>在屏幕右上角，有一个运行程序的图标。点击它，VS Code 将启动终端。然后你会看到打印出的消息。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在 VS Code 中开始使用Copilot非常简单。当你开始输入代码时，该工具会启动，提供代码建议并根据你的输入生成代码片段。</p>
<p>假设您输入一个函数的头部在 Python 中：</p>
<pre data-type="programlisting"><strong>def find_factorial(number):</strong></pre>

<p>Copilot 将及时建议完整的函数体，如图 4-4 所示。生成的代码称为幽灵文本，并以灰色突出显示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0404-20240829123926-44lkgip.png"></p>
<p> 图 4-4. Copilot 在用户编写函数头时建议代码</p>
<p>请记住，代码在您的机器上可能看起来有些不同，这是正常的，因为底层LLM是根据一组复杂的概率工作。</p>
<p>但是问题是：GitHub 明白你正在尝试编写一个根据参数计算阶乘的函数。因此，它建议你需要的 If–Then 结构以获得正确的结果。</p>
<p>您可以按 Tab 键接受代码建议。但如果这不是您想要的，请按 Esc 键跳过。</p>
<p>如果您将鼠标悬停在生成的代码上，您将看到更多选项，如图 4-5 所示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0405-20240829123927-lpgism9.png"></p>
<p>图 4-5. 悬停在生成的代码上会出现更多选项，显示在右上角</p>
<p>您可以点击接受以接受代码建议，就像按下 Tab 键一样，或者您可以选择接受单词一次选择代码中的一个单词。如果您点击三个点，您将获得一个菜单，可以接受一行或始终显示工具栏。</p>
<p>点击左侧的 1&#x2F;2 可以查看生成代码的替代方案；在图 4-5 中，有两个替代方案，当前显示的是第一个。点击“&gt;”将带你到版本 2。然后点击“&lt;”将带你回到版本 1。</p>
<p>您还可以使用表 4-1 中列出的快捷键来导航选项。</p>
<p>表 4-1. 滚动代码建议的快捷键</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>下一建议</th>
<th>之前的建议</th>
</tr>
</thead>
<tbody><tr>
<td>macOS</td>
<td>选项（⌥）或 Alt+］</td>
<td>选项（⌥）或 Alt+[</td>
</tr>
<tr>
<td>window</td>
<td>Alt+］</td>
<td>Alt+[</td>
</tr>
<tr>
<td>Linux</td>
<td>Alt+]</td>
<td>Alt+[</td>
</tr>
</tbody></table>
<p>如果按 Ctrl+Enter，VS Code 将创建一个新标签页以显示 10 个替代解决方案（图 4-6）。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0406-20240829123928-4l52zya.png"></p>
<p> 图 4-6. 按 Ctrl+Enter 会弹出一个单独的标签页，显示 10 个不同版本的代码</p>
<p>要选择其中一个选项，请点击该代码上方的接受解决方案。否则，关闭标签以拒绝所有选项。</p>
<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>在“代码空间和 Visual Studio Code”中，我们查看了如何提示Copilot生成代码，使用一个或多个注释。为此，您需要在您正在使用的编程语言的语法中指明注释。</p>
<p>但你可以做更多。你可以使用评论与系统互动，就像它是ChatGPT。让我们看一个例子：</p>
<blockquote>
<p><em>Prompt:</em> # q: What is a class in object-oriented programming?</p>
<p><em>Copilot:</em> # a: A class is a blueprint for creating objects. An object has properties and methods (functions) associated with it. Almost everything in Python is an object.</p>
</blockquote>
<p>你可以看到答案也在你编写代码的语言上下文中。现在假设你问Copilot系统是如何工作的：</p>
<blockquote>
<p><em>Prompt:</em> # q: What is the shortcut for accepting an inline suggestion?</p>
<p><em>Copilot:</em> # a: tab</p>
</blockquote>
<p>您可以询问Copilot关于 VS Code 的功能：</p>
<blockquote>
<p><em>Prompt:</em> # q: What is the shortcut for the user settings in VS Code?</p>
<p><em>Copilot:</em> # a: Ctrl + ,</p>
</blockquote>
<p>您也可以询问它关于其他 IDE 的快捷键：</p>
<blockquote>
<p><em>Prompt:</em> # q: What is the shortcut for a new file in the Atom editor?</p>
<p><em>Copilot:</em> # a: ctrl + n</p>
</blockquote>
<p>注意Copilot知道我在使用 Windows 系统，并根据该平台提供代码。</p>
<h2 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h2><p>Copilot 聊天就像 ChatGPT，但用于你的编码环境。它方便用于讨论代码，例如当你需要弄清楚语法、修复错误、整理测试用例，或者只是理解不同的编程思想。它由 OpenAI 的 GPT-4 和 GPT-3.5 Turbo 提供支持，以及一些微软自己的 LLMs。</p>
<p>您可以直接从 <a target="_blank" rel="noopener" href="https://github.com/">https://github.com</a> 进入聊天。它非常适合分析代码、处理拉取请求、查看文档或询问任何编码问题。此外，聊天功能在 iOS 和 Android 的 GitHub 应用中均可用，因此您可以随时随地使用。</p>
<p>但现在，让我们关注一下这在 VS Code 中是如何工作的。这意味着添加一个新扩展。只需搜索“GitHub Copilot 聊天”。安装后，您会看到屏幕左侧弹出一个新图标。它有两个小聊天气泡，如图 4-7 所示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0407-20240829123929-cg5zar3.png"></p>
<p> 图 4-7. 聊天图标出现在屏幕左侧</p>
<p>在聊天面板顶部，您会看到一组菜单图标。第一个图标由横线和一个小叉组成，用于清除您所有的聊天记录。这一点很重要，因为上下文的工作方式。当您输入提示时，LLM会检查对话历史。如果您的聊天主题杂乱无章，您可能会得到一些不太有帮助的答案。这就是为什么保持每个聊天专注于特定主题，并为新主题开始新聊天是个好主意。</p>
<p>下一图标是一个人和一个聊天气泡，允许您发送关于系统的反馈。然后是历史按钮，一个时钟，显示之前的对话记录。</p>
<p>如果点击三个点，您可以在编辑器内使用聊天，那里有更多空间供您聊天。</p>
<p>在聊天框底部，有一个输入区域可以向系统提问。</p>
<p>聊天系统有许多快捷方式。一种是@workspace，它指的是在您的工作空间中打开的文件。例如，如果您有一个 Python 计算器程序，您可以输入：</p>
<blockquote>
<p><em>Prompt:</em> @workspace &#x2F;explain</p>
</blockquote>
<p>图 4-8 显示聊天已分析程序文件并提供了深入的解释。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0408-20240829123929-dspo5d2.png"></p>
<p> 图 4-8. 聊天可以用来解释代码，例如计算器程序</p>
<p>您可以让聊天解释代码的某一部分。突出显示您感兴趣的部分，然后按下鼠标右键。这将弹出一个菜单（图 4-9）。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0409-20240829123930-mdnin30.png"></p>
<p> 图 4-9. 通过高亮显示代码的一个部分并按右键聚焦聊天</p>
<p>当你告诉聊天机器人专注于代码的某部分时，你不仅可以解释代码，还可以修复它，生成文档或创建测试。</p>
<p>另一个有用的快捷方式是&#x2F;new 命令。它将为新项目或功能创建一个脚手架。以下是一些示例：</p>
<blockquote>
<p><em>Prompt:</em> &#x2F;new Create a Python script to scrape data from a website</p>
<p><em>Prompt:</em> &#x2F;new Generate a Java class for a student with fields for name, age, and grade</p>
<p><em>Prompt:</em> &#x2F;new Build a simple REST API using Flask</p>
<p><em>Prompt:</em> &#x2F;new Create a JavaScript function to sort an array of numbers in ascending order</p>
<p><em>Prompt:</em> &#x2F;new Design a SQL database schema for a blog, with tables for users, posts, and comments</p>
</blockquote>
<p>响应这些提示，聊天系统将显示主要步骤，然后提供代码列表。您还有几个选项可以处理它。如图 4-10 所示，顶部有一个菜单栏。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0410-20240829123931-cddv7tq.png"></p>
<p> 图 4-10. 聊天代码列表顶部的代码处理选项</p>
<p>第一个图标将复制代码，第二个将在文件中光标所在位置插入代码（您也可以使用 Ctrl+Enter）。如果您选择三个点，可以将代码插入到新文件或终端中。</p>
<p>创建新 Jupyter Notebook 的快捷方式：&#x2F;newNotebook。您应该指定您希望笔记本执行的操作。以下是一些示例提示：</p>
<blockquote>
<p><em>Prompt:</em> &#x2F;newNotebook Create a notebook to visualize data from a csv file using matplotlib</p>
<p><em>Prompt:</em> &#x2F;newNotebook Create a notebook to preprocess and clean a dataset for machine learning</p>
<p><em>Prompt:</em> &#x2F;newNotebook Create a notebook to implement a simple linear regression model using scikit-learn</p>
<p><em>Prompt:</em> &#x2F;newNotebook Create a notebook to analyze time series data</p>
<p><em>Prompt:</em> &#x2F;newNotebook Create a notebook to scrape data from a website and analyze it</p>
</blockquote>
<p>聊天还提供了一个&#x2F;terminal 快捷方式。您可以询问有关终端或命令行操作的问题或获取帮助，例如导航目录、运行脚本或安装软件包。以下是一些提示：</p>
<blockquote>
<p><em>Prompt:</em> &#x2F;terminal What is the command to list all environment variables?</p>
<p><em>Prompt:</em> &#x2F;terminal How do I use grep to find specific text in multiple files?</p>
<p><em>Prompt:</em> &#x2F;terminal How can I use the find command to search for files by their permissions?</p>
<p><em>Prompt:</em> &#x2F;terminal How do I redirect the output of a command to a file?</p>
<p><em>Prompt:</em> &#x2F;terminal How do I use awk to process text files?</p>
</blockquote>
<p>然后是 @vscode，它被称为代理。通过这个，你可以询问问题或获取关于 VS Code 的某些方面的帮助，例如功能、导航、配置或扩展。</p>
<p>这里有一些示例提示：</p>
<blockquote>
<p><em>Prompt:</em> @vscode How do I split the editor into multiple windows?</p>
<p><em>Prompt:</em> @vscode How can I customize my keyboard shortcuts?</p>
<p><em>Prompt:</em> @vscode How do I set up a multi-root workspace?</p>
<p><em>Prompt:</em> @vscode How do I configure task automation in VS Code?</p>
<p><em>Prompt:</em> @vscode How can I set up and use Docker with VS Code?</p>
</blockquote>
<p>最后，还有&#x2F;api 命令。您可以询问有关 API 开发或使用的方面，包括创建、测试或集成的帮助。以下是一些示例：</p>
<blockquote>
<p><em>Prompt:</em> &#x2F;api How do I make a POST request with JSON data in Node.js?</p>
<p><em>Prompt:</em> &#x2F;api How can I handle CORS issues in an Express.js API?</p>
<p><em>Prompt:</em> &#x2F;api How do I authenticate a user in a Django REST API?</p>
<p><em>Prompt:</em> &#x2F;api How can I paginate results in a Rails API?</p>
<p><em>Prompt:</em> &#x2F;api How do I version an API in ASP.NET Core?</p>
</blockquote>
<p>您也可以在 VS Code 的上下文中使用 &#x2F;api：</p>
<blockquote>
<p><em>Prompt:</em> @vscode &#x2F;api How do I create a new command in VS Code extension?</p>
<p><em>Prompt:</em> @vscode &#x2F;api How can I read and write settings in VS Code extension?</p>
<p><em>Prompt:</em> @vscode &#x2F;api How do I create a new webview panel in VS Code extension?</p>
<p><em>Prompt:</em> @vscode &#x2F;api How can I interact with the file system in VS Code Extension?</p>
<p><em>Prompt:</em> @vscode &#x2F;api How do I add a new item to the activity bar in VS Code Extension?</p>
</blockquote>
<p>注意，如果您想清除聊天，可以使用 &#x2F;clear。</p>
<h2 id="在线聊天"><a href="#在线聊天" class="headerlink" title="在线聊天"></a>在线聊天</h2><p>您可以在代码列表中使用聊天功能。您将突出显示代码，然后按 Ctrl+I（Windows）或 Cmd+I（macOS）。然后您将看到一个弹出窗口，如图 4-11 所示。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0411-20240829123932-bshdkqa.png"></p>
<p> 图 4-11. 内联聊天功能允许您在代码中聊天</p>
<p>根据 GitHub，内联聊天已成为一个热门功能。毕竟，它允许开发者保持在他们的“工作状态”中。</p>
<p>您可以使用之前描述的快捷方式来询问代码相关的问题。解释将显示在聊天面板上。</p>
<p>注意代码旁边还有一个橙色闪光图标。如果你点击它，你会得到几个选项——修复代码、解释代码或重写代码——你可以在图 4-12 中看到。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0412-20240829123932-o2e8z8p.png"></p>
<p> 图 4-12. 按压橙色闪光图标可以直接与代码交互</p>
<p>让我们尝试一个使用在线聊天的例子。我们将使用这个提示：</p>
<blockquote>
<p><em>Prompt:</em> Create a function for a bubble sort</p>
</blockquote>
<p>聊天生成代码来实现这一点。但假设我们想看看是否有更快的排序类型。突出显示函数并执行内联聊天。图 4-13 显示了响应。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0413-20240829123933-c1dwekt.png"></p>
<p> 图 4-13. 内联聊天已响应创建比冒泡排序更快的排序请求</p>
<p>聊天建议快速排序，并以“差异模式”显示。这允许比较和对比这两种方法。您可以接受新代码的全部或仅部分。</p>
<h2 id="打开标签页"><a href="#打开标签页" class="headerlink" title="打开标签页"></a>打开标签页</h2><p>当你在进行标准软件开发项目时，你的 IDE 通常会包含一堆文件，每个文件在应用程序框架中扮演着自己的角色。以使用 React 的网页项目为例。你会看到组件的.jsx 和.js 文件，还有 HTML 和 CSS 文件，更不用说.json 和.env 文件了。</p>
<p>这对Copilot意味着什么？这很有帮助。Copilot 越了解您工作的上下文就越好。这意味着它会考虑您正在处理的当前文件中的所有内容。至于其他打开的文件，LLM 并不会扫描它们全部。它专注于与您正在做的事情相关的部分。此外，Copilot 不会查看您项目中的其他文件，可能是为了尊重您的隐私。</p>
<h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p>您可以在命令行界面中使用Copilot。Copilot的两个主要功能是解释命令和建议命令。</p>
<p>要做到这一点，您需要安装 GitHub 命令行工具，然后登录到您的 GitHub 账户：</p>
<pre data-type="programlisting"><strong>gh auth login</strong></pre>

<p>接下来，您将安装Copilot：</p>
<pre data-type="programlisting"><strong>gh extension install github/gh-copilot</strong></pre>

<p>您可以升级扩展：</p>
<pre data-type="programlisting"><strong>gh extension upgrade gh-copilot</strong></pre>

<p>这是请求Copilot解释 CLI 命令的示例：</p>
<blockquote>
<p><em>Prompt:</em> gh copilot explain xcopy</p>
</blockquote>
<p>图 4-14 显示输出。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0414-20240829123934-ost0gnj.png"></p>
<p> 图 4-14. Copilot 解释了 CLI 中的 xcopy 命令</p>
<p>这里是如何让Copilot建议一个命令：</p>
<blockquote>
<p><em>Prompt:</em> gh copilot suggest</p>
</blockquote>
<p>接下来，Copilot 将询问您想要帮助的命令类型——通用 shell 命令、gh 命令或 git 命令——请指定。然后它会询问您希望命令执行什么。以下是一个示例：</p>
<blockquote>
<p><em>Prompt:</em> What are the commands for viewing and setting environment variables in the system?</p>
</blockquote>
<p>图 4-15 显示了Copilot的响应，其中包括使用的命令建议。您可以复制此内容或询问Copilot以获取更多帮助，例如解释命令或修改它。</p>
<p><img src="/../assets_aiassistedprogramming/net-img-aiap_0415-20240829123934-zzvqh0v.png"></p>
<p> 图 4-15. Copilot 在命令行界面的建议功能根据您提供的参数提供命令</p>
<h1 id="Copilot-合作伙伴计划"><a href="#Copilot-合作伙伴计划" class="headerlink" title="Copilot 合作伙伴计划"></a>Copilot 合作伙伴计划</h1><p>开发人员通常通过使用第三方工具来增强他们的应用程序并更好地利用数据。以 Splunk 为例。它是挖掘日志和数据分析的热门工具。开发人员依靠 Splunk 监控他们的应用程序并快速修复问题，这要归功于其强大的搜索和报告功能。还有 New Relic，它专注于确保您的应用程序顺利运行。它提供实时洞察和诊断，帮助您发现和修复性能问题，使您的应用程序运行得更好，以提供良好的用户体验。还有 Datadog。它是监控基础设施和应用程序的关键工具。凭借其广泛的集成，Datadog 使开发人员能够收集、混合和展示来自各种地方的数据，帮助他们做出明智的选择，以提升性能和管理资源。</p>
<p>考虑到这些系统的重要性，GitHub 推出了Copilot合作伙伴计划。它拥有不断扩展的热门集成平台阵容，所有平台均可通过插件访问。</p>
<p>该项目的早期合作伙伴之一是 DataStax，该公司开发了 Astra DB，这是一个用于构建高级人工智能应用程序的向量数据库。借助插件，开发人员可以使用 Chat 加快数据库创建。例如，Chat 提供数据库结构和元数据的代码建议，所有建议都符合编码标准。这导致代码更整洁，更易于维护。</p>
<p>请使用@datastax 标签提问。一些示例提示包括：</p>
<blockquote>
<p><em>Prompt:</em> Tell me about my chat_prod database</p>
<p><em>Prompt:</em> Tell me about the schema of a table</p>
<p><em>Prompt:</em> Write a SQL query to read from the chat table</p>
</blockquote>
<p>  注意</p>
<blockquote>
<p>玛丽-布伦达·阿科达，人工智能眼科领域的研究员，拥有相关专利，是Copilot的 avid 用户。她说：“有一次，我在不到一个小时的时间里使用Copilot编写了整个模型开发过程的代码。这是一个通常需要我花费更多时间和精力的任务。有趣的是，当我不得不使用一个不支持Copilot的在线 IDE 时，我意识到开发过程是多么繁琐和缓慢。”</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Copilot 已迅速成为编码必备的人工智能工具，大大提高了开发者的生产力和代码质量。本章介绍了它的关键特性，包括建议复杂代码块的能力、可靠的安全措施、出色的性能以及在 VS Code 中的易用性。Copilot 中的聊天和内联聊天功能使得在编码过程中与人工智能互动成为可能。尽管它仍然是一个需要人工指导的工具，但 Copilot 无疑是对人工智能驱动编码未来的一个窥探。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Howard Huang</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">638k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19:19</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动-->
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.js" integrity="sha256-+2+qOqR8CKoHh/AsVR9k2qaDBKWjYNC2nozhYmv5j9k=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
