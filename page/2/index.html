<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szhowardhuang.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="嵌入式老兵博客">
<meta property="og:url" content="https://szhowardhuang.github.io/page/2/index.html">
<meta property="og:site_name" content="嵌入式老兵博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Howard Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://szhowardhuang.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>嵌入式老兵博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">嵌入式老兵博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Howard Huang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/08/08/llmclinical/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/08/llmclinical/" class="post-title-link" itemprop="url">医疗保健的LLMs和生成式人工智能 --- 目录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-08 09:48:23" itemprop="dateCreated datePublished" datetime="2024-08-08T09:48:23+08:00">2024-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-21 14:03:21" itemprop="dateModified" datetime="2024-08-21T14:03:21+08:00">2024-08-21</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/../assets_llmClinical/image-20240821113921-n1fo6nk.png" alt="image.png"></p>
<p>LLMs and Generative AI for Healthcare</p>
<h1 id="本书的组织结构"><a href="#本书的组织结构" class="headerlink" title="本书的组织结构"></a>本书的组织结构</h1><p>本书的内容分为七个章节，组织如下——反映了LLMs及其他生成式人工智能模型在医疗保健中的独特特征，以及它们的潜力、挑战和应用。</p>
<h2 id="第一章：医生的黑色手提包"><a href="#第一章：医生的黑色手提包" class="headerlink" title="第一章：医生的黑色手提包"></a>第一章：医生的黑色手提包</h2><p>本章探讨了LLMs和生成式人工智能在医疗保健中的潜力，概述了LLMs的前景及其在医疗保健中的应用。除了描述LLMs的未来可能性外，本章还介绍了在医疗保健中使用LLMs的挑战。</p>
<h2 id="第二章：窥视人工智能黑箱"><a href="#第二章：窥视人工智能黑箱" class="headerlink" title="第二章：窥视人工智能黑箱"></a>第二章：窥视人工智能黑箱</h2><p>在这里，读者将了解LLM的结构以及LLMs的工作原理。本章帮助读者理解LLMs的架构和基本工作原理，而不是对LLMs的无定形化，并解释LLMs是如何工作和生成内容的。</p>
<h2 id="第三章：超越白大褂"><a href="#第三章：超越白大褂" class="headerlink" title="第三章：超越白大褂"></a>第三章：超越白大褂</h2><p>本章探讨了如何使用LLMs和生成式人工智能来自动化医疗保健中的更多任务。它考察了可以应用这项技术以改善运营和病人护理的领域。</p>
<h2 id="第四章：LLM与生成式人工智能的患者和临床潜力"><a href="#第四章：LLM与生成式人工智能的患者和临床潜力" class="headerlink" title="第四章：LLM与生成式人工智能的患者和临床潜力"></a>第四章：LLM与生成式人工智能的患者和临床潜力</h2><p>在本章中，我们探讨生成式人工智能如何提升患者体验并影响临床决策：健康机器人礼宾服务；医生的笔记和就诊；健康计划向导；针对常见健康问题的应用，如黑人母亲健康；用药提醒；甚至口腔健康。除了常见的健康问题，我们还将探讨临床决策支持工具、临床洞察机器人和人工智能路边医生。我们也不能忘记远程患者监测、数字双胞胎、完全自动化的医生信件，以及生成式人工智能在健康公平中的作用。</p>
<h2 id="第五章：LLMs-在药物研发、公共卫生及其他领域"><a href="#第五章：LLMs-在药物研发、公共卫生及其他领域" class="headerlink" title="第五章：LLMs 在药物研发、公共卫生及其他领域"></a>第五章：LLMs 在药物研发、公共卫生及其他领域</h2><p>本章介绍了LLMs在药物发现、临床试验设计与分析以及基因组研究中的应用。具体而言，我们讨论了LLMs在制药研发、公共卫生和基因组学中的多种应用，并进一步探讨了它们的好处和潜力。</p>
<h2 id="第六章：掌舵LLMs的伦理"><a href="#第六章：掌舵LLMs的伦理" class="headerlink" title="第六章：掌舵LLMs的伦理"></a>第六章：掌舵LLMs的伦理</h2><p>本章重点讨论如何以负责任的方式开发用于医疗保健的LLMs，并设计以最大化积极影响。它首先讨论我们所说的“积极的人工智能想象”是什么意思，然后描述围绕LLMs的伦理考虑，包括偏见、隐私和非法使用的风险。它还讨论了一些应对这些问题的策略（例如，监测LLM行为、确保和保护隐私、促进LLMs的伦理使用的政策等）。它讨论了“人工智能与回形针问题”（即对齐），指出我们必须确保人工智能的目标与人类的目标一致。</p>
<h2 id="第七章：未来将至"><a href="#第七章：未来将至" class="headerlink" title="第七章：未来将至"></a>第七章：未来将至</h2><p>最后一章提供了对LLMs未来的展望，包括对奇点的讨论以及 AGI 演变的潜力。最后一部分标题为“明天的展望”，提供了五个关于未来LLMs的预测，以及它们可能对我们的医疗保健和社会产生的影响。通过这一多样化的案例集合，本书提供了对LLMs和生成式人工智能在医疗保健中当前现实和未来机会的整体视角，赋予读者必要的知识和见解，以应对这些快速出现的技术的伦理、技术和社会影响。在阅读这七章后，读者将理解在医疗保健中使用LLMs和生成式人工智能的可能性、问题和伦理。希望章节之间的顺序能够引导读者深入理解这些工具如何在智能使用的情况下，转变医疗服务并改善患者结果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/08/07/3D-Data-Science-Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/07/3D-Data-Science-Systems/" class="post-title-link" itemprop="url">终极指南：3D 数据科学系统和工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-08-07 14:49:30 / 修改时间：14:47:59" itemprop="dateCreated datePublished" datetime="2024-08-07T14:49:30+08:00">2024-08-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/../asset_3Ddatascience/01.png" alt="The 3D Data Science Systems core components and intersecting disciplines."></p>
<p>一个 3D 数据科学项目涉及数据工程、数据分析和可视化技术的结合，这些技术专门用于处理三维数据。</p>
<p>从收集初始数据到自动化 3D 沉浸式体验，让我涵盖整个过程。我将介绍所有必要的程序、资源和方法，以确保高效的工作流程和出色的结果。</p>
<p>让我深入探讨六个主要步骤：项目范围、数据获取、数据预处理、数据分析、可视化和部署，如下所示。</p>
<p><img src="/../asset_3Ddatascience/02.png" alt="A pyramid with six layers representing the steps in a 3D data science project: Project Scope, Data Acquisition, Data Preprocessing, Data Analysis, Visualization, and Deployment."></p>
<h1 id="1-定义项目范围和目标"><a href="#1-定义项目范围和目标" class="headerlink" title="1. 定义项目范围和目标"></a>1. 定义项目范围和目标</h1><p><img src="/../asset_3Ddatascience/03.png"></p>
<p>假设你想听我的意见。在深入技术设置之前，我想做一件事：清楚地定义 3D 数据科学项目的范围和目标。这一步就像在旅行前绘制航线，确保我们做好准备，专注于一个明确的目的地。这包括：</p>
<ul>
<li>识别问题: 理解您希望通过 3D 数据解决的具体问题。</li>
<li>目标设定：弄清楚你希望实现的目标，无论是新知识、预测还是视觉表现。</li>
<li>确定交付成果：指定预期的输出，如报告、模型或交互式可视化。</li>
</ul>
<p><img src="/../asset_3Ddatascience/04.png" alt="A staircase with three steps. The first step is “Identify Problem”. The second step is labeled “Set Objectives”. The third step is labeled “Determine Deliverables”. This is for “Setting Up a 3D Data Science Project”"></p>
<h1 id="2-数据采集"><a href="#2-数据采集" class="headerlink" title="2. 数据采集"></a>2. 数据采集</h1><p><img src="/../asset_3Ddatascience/05.png"></p>
<p>在设置 3D 数据科学项目时，初始和关键的步骤之一是数据获取。在这个阶段，识别和收集来自各种来源的相关 3D 数据，并确保其格式兼容，对于项目的成功至关重要。</p>
<p>让我们深入探讨 3D 数据采集的基础构件。</p>
<h1 id="2-1-数据来源"><a href="#2-1-数据来源" class="headerlink" title="2.1. 数据来源"></a>2.1. 数据来源</h1><p>首先，我们应该从可靠的来源识别并收集必要的 3D 数据。</p>
<p><img src="/../asset_3Ddatascience/06.png" alt="The Main 3D Data Sources: Public Dataset, 3D Cameras, 3D Scanners, Generative AI."></p>
<p> 常见来源包括：</p>
<ul>
<li>3D 相机：您可以将图像转换为 3D 模型。一个著名的例子是 Kinect：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows%EF%BC%88%E6%B6%88%E8%B4%B9%E7%BA%A7%E6%B7%B1%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%89">https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows（消费级深度传感器）</a></li>
<li>3D 扫描仪：捕捉物体物理形状的设备（例如，激光雷达，如 Velodyne：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Velodyne_Lidar%EF%BC%89%E3%80%82">https://en.wikipedia.org/wiki/Velodyne_Lidar）。</a></li>
<li>生成性人工智能：通过使用生成性人工智能生成 3D 数据的工具。（例如，<a target="_blank" rel="noopener" href="https://buaacyw.github.io/mesh-anything/%EF%BC%89">https://buaacyw.github.io/mesh-anything/）</a></li>
<li>公共数据集：像 ShapeNet、ModelNet 或来自研究机构的自定义数据集等存储库。为了最好地帮助您在旅程中，我编制了一份参考数据集的列表，以帮助进行 3D 数据管理工作。</li>
</ul>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>这里有一些带有公开可用数据集的选项：</p>
<ul>
<li>斯坦福大规模数据集 (S3DIS): <a target="_blank" rel="noopener" href="https://cvgl.stanford.edu/resources.html">https://cvgl.stanford.edu/resources.html</a> （包括室内场景的 LiDAR 和 RGB 数据）</li>
<li>NuScenes: <a target="_blank" rel="noopener" href="https://www.nuscenes.org/">https://www.nuscenes.org/</a> （大规模自动驾驶数据集，包含激光雷达、相机图像等）</li>
<li>Waymo 开放数据集： <a target="_blank" rel="noopener" href="https://waymo.com/open/">https://waymo.com/open/</a> （用于自动驾驶汽车的大规模数据集，包括激光雷达和摄像头数据）</li>
<li>Thing3D: <a target="_blank" rel="noopener" href="https://www.thingiverse.com/">https://www.thingiverse.com/</a> （大型 3D 模型数据集，专注于现实世界的物体）</li>
<li>ShapeNet: <a target="_blank" rel="noopener" href="https://shapenet.org/qaforum/">https://shapenet.org/qaforum/</a> （一个用于各种类别 3D 模型的热门数据集）</li>
<li>StyleGAN2: <a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/synthesizing-high-resolution-images-with-stylegan2/">https://developer.nvidia.com/blog/synthesizing-high-resolution-images-with-stylegan2/</a> （用于创建高保真图像的生成模型，可间接用于生成 3D 模型）</li>
<li>DreamGAN: <a target="_blank" rel="noopener" href="https://github.com/NVlabs/denoising-diffusion-gan/blob/main/train_ddgan.py">https://github.com/NVlabs/denoising-diffusion-gan/blob/main/train_ddgan.py</a> （用于创建 3D 形状的生成模型）</li>
<li>美国国家海洋和大气管理局 + 国家环境信息中心： <a target="_blank" rel="noopener" href="https://www.ncei.noaa.gov/">https://www.ncei.noaa.gov/</a> （提供地理空间数据，包括三维高程数据）</li>
</ul>
<h2 id="3D-仓库"><a href="#3D-仓库" class="headerlink" title="3D 仓库"></a><strong>3D 仓库</strong></h2><p>您还可以利用 OpenRepositories，使用各种许可证下可用的数据：</p>
<ul>
<li>Sketchfab: <a target="_blank" rel="noopener" href="https://sketchfab.com/">https://sketchfab.com/</a> （分享和发现 3D 模型的平台）</li>
<li>TurboSquid： <a target="_blank" rel="noopener" href="https://www.turbosquid.com/">https://www.turbosquid.com/</a> （3D 模型市场）</li>
</ul>
<p>现在您更好地了解了如何获取 3D 数据，让我们来谈谈格式。</p>
<h1 id="2-2-数据格式"><a href="#2-2-数据格式" class="headerlink" title="2.2. 数据格式"></a>2.2. 数据格式</h1><p>实际上，我们通常会使用多种格式的交响乐 🎺，每种格式都有其自身的优缺点。选择合适的格式取决于目的——快速的 3D 打印可能更适合简单的格式，而令人惊叹的虚拟现实体验可能需要更丰富、更详细的选项。因此，确保数据以兼容的格式进行分析和可视化是至关重要的。让我描绘一下我最喜欢的五种文件格式，如下所示：</p>
<p><img src="/../asset_3Ddatascience/07.png" alt="A diagram illustrating various 3D model file formats. A pyramid is shown with lines extending outward to different shapes representing the formats: OBJ, PLY, STL, GLTF, and LAS. by Florent Poux"></p>
<ol>
<li>OBJ（波前对象）： 一种流行且广泛支持的 3D 网格格式。它使用顶点（空间中的点）、面（形成平面表面的顶点集合）和纹理坐标定义对象的基本几何形状。虽然简单且易于人类阅读，但 OBJ 缺乏关于材料和动画的信息。它是基本 3D 模型或在不同软件程序之间交换数据的中间格式的良好选择。了解更多：维基百科</li>
<li>PLY（多边形文件格式）： 一种多功能格式，可以处理 3D 网格（如 OBJ）和点云（表示 3D 空间的数据点集合）。PLY 比 OBJ 提供了更多的灵活性，允许您为每个顶点或点存储额外的属性，如颜色和强度。这使得它成为科学数据和需要额外信息的应用的良好选择。然而，与像 OBJ 这样的简单格式相比，某些软件对 PLY 的支持可能较少。了解更多：斯坦福</li>
<li>STL（立体光刻）： 3D 打印的首选格式。STL 文件将 3D 物体的表面几何形状表示为一组微小的三角形。这种简单的表示方式使得 3D 打印机能够轻松理解并转换为物理层。然而，STL 文件缺乏关于颜色、纹理或动画的信息。它们非常适合传达物体的基本形状以进行打印，但对于具有丰富视觉细节的复杂场景则不太理想。</li>
<li>GLTF（GL 传输格式）： 一种现代格式，旨在高效地在网络上传输 3D 模型。GLTF 结合了 JSON（基于文本的数据格式）和二进制数据（模型信息的压缩表示），在文件大小和细节之间实现了良好的平衡。它支持网格、材质、纹理和动画等特性，是在网页或应用程序中嵌入互动 3D 内容的绝佳选择。了解更多信息：Khronos Group</li>
<li>LAS（激光档案系统）： 专门设计用于管理大型地理空间点云数据集。LAS 文件通常包含表示地球表面物体或地形位置的 3D 点，通常由 LiDAR 扫描仪（基于激光的成像系统）捕获。这些文件还可以存储额外的信息，如强度值（激光束的反射率），这对于地形分析非常有帮助。LAS 是地理空间数据的行业标准，广泛应用于测量、制图和环境建模等领域。了解更多信息：ASPRS</li>
</ol>
<p>考虑到这一点，您可以独立于您的应用案例处理 90%的场景。</p>
<p>🦚 Florent 的备注：在某些情况下，特别是在医学成像或地理空间应用中，您可以通过利用体素集合获得好处。在这种情况下，您可能需要调整这些格式或利用更纯粹的版本。如果这听起来有趣，您可以查看下面的文章。</p>
<p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/how-to-automate-voxel-modelling-of-3d-point-cloud-with-python-459f4d43a227?source=post_page-----e92aaa8185eb--------------------------------">如何使用 Python 自动化 3D 点云的体素建模动手教程，将大型点云转换为 3D 体素🧊，使用 Python 和 open3d。解锁自动化工作流程……towardsdatascience.com</a></p>
<h1 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3. 数据预处理"></a>3. 数据预处理</h1><p><img src="/../asset_3Ddatascience/08.png"></p>
<p>清洗和转换 3D 数据是建模和分析之前的重要第一步，以确保数据适合进一步处理。这个阶段被称为数据预处理，涉及数据清理、标准化和特征提取等任务。让我们探讨在有效分析和模型开发中预处理 3D 数据所涉及的基本步骤和技术。</p>
<h1 id="3-1-数据清理"><a href="#3-1-数据清理" class="headerlink" title="3.1. 数据清理"></a>3.1. 数据清理</h1><p>数据从来都不是完美的。让我坦诚地说：有时候，它看起来就像一个幼儿把意大利面晚餐扔到了扫描仪上。朋友们，这一部分就是关于数据清理的。</p>
<p>这是我们处理异常数据点、修补漏洞的地方，通常将那团意大利面般的混乱转变为一个平滑、适度熟的数据库，随时准备应对我们投入的任何内容。虽然这可能不是工作中最引人注目的部分，但相信我，干净的数据是任何成功 3D 项目的秘密武器。</p>
<p> 这可能涉及：</p>
<ul>
<li>去除异常值: 识别和消除显著偏离常规的数据点。</li>
<li>填补缺失值：使用插值或其他技术填补数据中的空白。</li>
<li>过滤噪声：噪声与异常值不同，是一个会影响您分析的数据点。应予以处理。</li>
</ul>
<p><img src="/../asset_3Ddatascience/09.png" alt="A funnel-shaped diagram illustrating the data cleaning process. Raw data enters the top of the funnel, and through the steps of identifying outliers, filtering noise, and filling missing values, clean data emerges at the bottom."></p>
<p>通常，在这个阶段之后，您会得到一个相对“干净”的初始输入版本。一旦达到这一点，我们就可以开始“转换”我们的数据集。</p>
<h1 id="3-2-数据转换"><a href="#3-2-数据转换" class="headerlink" title="3.2. 数据转换"></a>3.2. 数据转换</h1><p>在这个阶段，我们需要调整数据，以便更有效地进行分析。以下是一些此过程的示例：</p>
<p><img src="/../asset_3Ddatascience/10.png" alt="The four main steps of 3D data pre-processing."></p>
<p>如您所见，我们有四个主要步骤：</p>
<ul>
<li>标准化：将信息调整到标准范围内。</li>
<li>重采样：调整数据的分辨率。</li>
<li>特征提取：从原始数据中识别和提取相关特征。</li>
<li>旋转、平移、缩放: 调整您的 3D 数据集在空间中的位置</li>
</ul>
<p>在这个阶段，我认为有这个高层次的概述而不深入探讨是好的。这在许多情况下应该非常有用，特别是在（3D）数据分析的任务中。</p>
<h1 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4. 数据分析"></a>4. 数据分析</h1><p><img src="/../asset_3Ddatascience/11.png"></p>
<p>在这个阶段，我们构建模型以理解数据并寻找隐藏的模式和关联。这涉及统计分析、可视化和模型构建等技术，包括应用人工智能、机器学习和深度学习，从三维数据中发现有价值的见解。</p>
<p>让我从探索性数据分析开始。</p>
<h1 id="4-1-探索性数据分析-EDA"><a href="#4-1-探索性数据分析-EDA" class="headerlink" title="4.1. 探索性数据分析 (EDA)"></a>4.1. 探索性数据分析 (EDA)</h1><p>探索性数据分析（EDA）提供了一个非常简单的工具箱，用于在深入复杂建模或分析之前了解您的 3D 数据。以下是我们始终使用的两种关键技术的简要介绍，如下所示：</p>
<p><img src="/../asset_3Ddatascience/12.png" alt="A diagram comparing two methods of data analysis. The left side shows a speech bubble with “Statistical Analysis”. The right side shows a speech bubble with “Visualization” to create 3D plots and graphs to visualize the data."></p>
<h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a><strong>统计分析</strong></h2><p>这涉及使用描述性统计来总结您的 3D 数据的关键特征。可以将其视为绘制数据的基本肖像，以了解其中心趋势和分布。技术包括提取中心趋势、均值、中位数、分布、范围或其他分布指标。</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><strong>可视化</strong></h2><p>虽然数字很重要，但有时一幅图（或者说，一个 3D 图！）要有效得多。可视化就是创建信息丰富且互动的图表，以探索数据中的关系和模式。我们通常依赖于 3D 散点图（可视化多个变量在 3D 空间中的相互关系）、直方图或热图。</p>
<p>现在我们已经通过探索性数据分析（EDA）探索了 3D 数据，是时候构建一些模型并揭示它们更深层的含义了！</p>
<h1 id="4-2-模型构建"><a href="#4-2-模型构建" class="headerlink" title="4.2. 模型构建"></a>4.2. 模型构建</h1><p>模型帮助我们从探索转向解释！理解 3D 模型（非几何模型）构建的世界是很重要的，在这里我们将使用复杂的技术来提取隐藏的模式，揭示数据中的真实含义。我们可以利用多种方法，从传统的统计分析到前沿的人工智能（AI），构建能够分析、解释甚至预测基于您宝贵的 3D 信息的未来结果的模型。</p>
<h2 id="数据分析层次与模型"><a href="#数据分析层次与模型" class="headerlink" title="数据分析层次与模型"></a>数据分析层次与模型</h2><p>首先，让我谈谈我们进行的“类型”分析：</p>
<p><img src="/../asset_3Ddatascience/13.png" alt="A diagram illustrating different levels of data analysis. The diagram is divided into four quadrants: Simple Regression Analysis, Complex Classification of Data Points, Simple 3D Object Detection, and Complex Semantic/Instance Segmentation. The axes represent complexity and breadth."></p>
<p>如您所见，我们有四个主要部分：</p>
<ul>
<li>回归分析： 该技术找到“最佳拟合”模型，以描述数据中变量之间的关系。想象一下散点图中的趋势线——这就是回归的实际应用。</li>
<li>数据点的分类: 将基本实体整理成预定义数量的类别</li>
<li>3D 物体检测：在数据集中识别和定位特定数量的类别，使用 3D 边界框</li>
<li>S语义 &#x2F; 实例分割: 更进一步，在基础实体层面进行工作（点云的点、网格的面、体素模型的体素，……）</li>
</ul>
<p>通过使用人工智能。但人工智能的细致程度如何？</p>
<h2 id="AI-模型粒度"><a href="#AI-模型粒度" class="headerlink" title="AI 模型粒度"></a>AI 模型粒度</h2><p>我们总是想知道这些模型中的“魔法”是如何发生的。AI 模型的架构定义了它在您的 3D 数据中捕获的内容，并在其有效性中发挥着至关重要的作用。让我定义一下下面所示的四个主要类别：</p>
<p><img src="/../asset_3Ddatascience/14.png" alt="The granularity of AI Models used in 3D Data Science."></p>
<p>尽可能简单地说：</p>
<ul>
<li>人工智能：试图模仿非人工智能</li>
<li>机器学习：这涉及应用上述提到的明确定义的算法（回归、分类等）来从您的数据中学习。可以把机器学习想象成一个勤奋学习教科书（数据）的学生，以便学习和做出预测。</li>
<li>深度学习：这是机器学习的一个子领域，使用人工神经网络，特别是专门设计用于处理 3D 数据的卷积神经网络（CNN）。想象一下，深度学习就像一个拥有超能力的学生，能够从远超传统机器学习算法能力的大型数据集中学习复杂的模式。</li>
<li>transformers：这些利用编码&#x2F;解码架构来完美融合全局和局部特征，更有效地把握上下文和局部变化。这对于理解上下文和 3D 场景中不同部分之间的关系等任务特别有用。</li>
</ul>
<p>🦚 Florent 的笔记：选择最佳的模型构建技术和人工智能方法取决于您的具体任务和数据。以下是一些一般性指导。对于简单的关系，回归分析或基本的机器学习算法可能就足够了。对于复杂的对象分类或分割，深度学习方法如卷积神经网络（CNN）或变换器（Transformers）通常更受欢迎。</p>
<p>现在，我们可以全力投入到 3D 可视化中！</p>
<h1 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5. 可视化"></a>5. 可视化</h1><p><img src="/../asset_3Ddatascience/15.png"></p>
<p>现在让我们进入引人入胜的 3D 数据可视化领域，在这里我们利用可用的工具和库来创建迷人且互动的 3D 数据可视化。这包括基于 Python 的可视化选项以及基于 Web 的 3D 图形，满足我们项目的各种可视化需求。这是我试图缩小范围的尝试：</p>
<p><img src="/../asset_3Ddatascience/16.png" alt="A diagram illustrating tools and libraries for 3D visualization. The central box labeled “3D Visualization Tools and Libraries” is connected to three other boxes: “Python (Py)”, “Web (WebGL)”, and “Software”. The Python box lists Matplotlib, Open3D, and Pyvista. The Web box lists Three.js, Potree, and Cesium. The Software box lists CloudCompare, Blender, and Unity."></p>
<p>正如您所见，当涉及到可视化这些 3D 数据时，我们有一整套选择可供使用，这取决于您是想进行快速的 Python 探索还是完整的网页体验。</p>
<p><strong>使用 Python：</strong></p>
<ul>
<li>Matplotlib (<a target="_blank" rel="noopener" href="https://matplotlib.org/)%EF%BC%9A%E8%BF%99%E4%B8%AA%E8%80%81%E7%89%8C%E5%B7%A5%E5%85%B7%E6%98%AF%E5%9F%BA%E6%9C%AC">https://matplotlib.org/)：这个老牌工具是基本</a> 3D 绘图甚至一些交互式 3D 可视化的绝佳选择。它是理解基础知识的坚实基础。</li>
<li>Open3D (<a target="_blank" rel="noopener" href="https://open3d.org/)%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%83%B3%E8%A6%81%E4%B8%80%E4%B8%AA%E7%9B%B4%E6%8E%A5%E9%9B%86%E6%88%90%E5%9C%A8%E4%BD%A0%E7%9A%84">https://open3d.org/)：如果你想要一个直接集成在你的</a> Python 环境中的流畅 3D 查看器，Open3D 就是你的好帮手。它让你轻松地探索和操作你的数据。</li>
<li>Pyvista (<a target="_blank" rel="noopener" href="https://docs.pyvista.org/">https://docs.pyvista.org/</a>): 这个家伙提供了良好的功能组合，能够很好地处理各种 3D 数据格式。当你需要比 Matplotlib 更多的功能时，它是一个不错的选择。</li>
</ul>
<p><strong>用于网络（WebGL）：</strong></p>
<ul>
<li>Three.js (<a target="_blank" rel="noopener" href="https://threejs.org/)%EF%BC%9A%E6%83%B3%E8%A6%81%E6%8C%91%E6%88%98%E8%87%AA%E5%B7%B1%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%BA%9B%E7%9C%9F%E6%AD%A3%E5%85%88%E8%BF%9B%E7%9A%84%E5%9F%BA%E4%BA%8E%E7%BD%91%E9%A1%B5%E7%9A%84">https://threejs.org/)：想要挑战自己，创建一些真正先进的基于网页的</a> 3D 图形吗？Three.js 是你的游乐场。它是一个强大的库，让你构建令人惊叹的互动体验。但请注意，它的学习曲线较陡。</li>
<li>Potree (<a target="_blank" rel="noopener" href="https://github.com/potree/potree">https://github.com/potree/potree</a>) : 需要在网上实时流式传输您的点云数据吗？那就看看 Potree 吧。这是一个专门为此目的设计的出色工具。</li>
<li>铯(<a target="_blank" rel="noopener" href="https://cesium.com/">https://cesium.com</a>) : 处理包含 3D 元素的地理空间数据？铯可以满足您的需求。它是一个构建互动 3D 地图和可视化的综合平台。</li>
</ul>
<p><strong>使用软件：</strong></p>
<ul>
<li>CloudCompare (<a target="_blank" rel="noopener" href="https://www.cloudcompare.org/">https://www.cloudcompare.org/</a>) — 如果你是点云的纯粹主义者并且想要一个专用的软件解决方案，CloudCompare 是一个免费的开源强大工具。它提供了丰富的工具用于处理、编辑和分析你的点云数据。</li>
<li>Blender (<a target="_blank" rel="noopener" href="https://www.blender.org/)%EF%BC%9A%E6%9C%89%E6%97%B6%E5%80%99%E4%BD%A0%E5%8F%AA%E6%83%B3%E7%9B%B4%E6%8E%A5%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9C%AC%E8%BA%AB%E6%89%93%E4%BA%A4%E9%81%93%E3%80%82Blender%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%9A%84">https://www.blender.org/)：有时候你只想直接与可视化本身打交道。Blender，一个流行的</a> 3D 创作套件，是艺术家和爱好者创建其 3D 数据惊人渲染的绝佳选择。</li>
<li>Unity (<a target="_blank" rel="noopener" href="https://unity.com/)%EF%BC%9A%E6%83%B3%E5%BE%97%E6%9B%B4%E5%A4%A7%E5%90%97%EF%BC%9FUnity">https://unity.com/)：想得更大吗？Unity</a> 是一个游戏引擎，允许您创建沉浸式 3D 体验。虽然它有一定的学习曲线，但它可以成为展示您的 3D 数据的强大工具，以一种真正引人入胜的方式。</li>
</ul>
<p>请记住，这只是可用工具的一部分。最适合您的选择将取决于您具体的项目需求和技能水平。最主要的问题是：您需要互动性吗？下面的图表应该能帮助您回答这个问题。</p>
<p><img src="/../asset_3Ddatascience/17.png" alt="What are the pros and cons of using interactive 3D Visualizations"></p>
<p>最后，关于可视化技术呢？</p>
<h1 id="5-2-可视化技术"><a href="#5-2-可视化技术" class="headerlink" title="5.2. 可视化技术"></a>5.2. 可视化技术</h1><p>您已经构建了您的 3D 模型，现在是展示它们的时候了！有效的 3D 可视化技术超越了静态图像——它们允许观众探索、互动并真正理解您的数据。您可以考虑这个第一个问题：</p>
<p><img src="/../asset_3Ddatascience/18.png" alt="The different ways to visualize 3D Data (interactive VS Static)"></p>
<p>从 3D 中，您可以推导出三个主要主题：</p>
<p><img src="/../asset_3Ddatascience/19.png"></p>
<h2 id="交互式可视化"><a href="#交互式可视化" class="headerlink" title="交互式可视化"></a><strong>交互式可视化</strong></h2><p>想象一下用户旋转一个 3D 模型，放大细节，甚至操控其组件。互动可视化创造了一个引人入胜的体验，让观众从不同的角度探索您的数据，获得更深入的见解。</p>
<p><img src="/../asset_3Ddatascience/20.png"></p>
<p>这对于产品演示、建筑漫游和科学数据探索非常有用。正如我们之前看到的，您可以利用 Three.js 和 Unity。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>有时候，静态的 3D 模型或互动但静态的体验并不足够。动画增加了时间的力量，使您能够展示数据中的变化、过程或模拟。这在可视化天气模式、生物学中的生长过程或工程中的动态模拟时非常受欢迎。在这里，Blender 是您的好帮手：</p>
<h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><p>虽然设计良好的可视化效果已经传达了很多信息，但有时添加清晰的标签、注释或标注可以进一步增强理解。注释可以突出特定特征，解释复杂概念，或引导观众理解您的数据。</p>
<p><img src="/../asset_3Ddatascience/21.png" alt="A diagram outlining the process of creating, viewing, and editing 3D annotations. The left side shows the creation process, including selecting a point on a model and adding comments and annotations. The right side shows the viewing and editing options, including viewing by anyone and editing or deleting by the creator. The bottom section highlights benefits such as easier collaboration and improved communication."></p>
<p>它们在需要指出医学扫描中的关键特征、解释复杂机器模型中的组件或在科学可视化中提供额外信息时特别有用。我建议利用 CloudCompare 来完成这个任务。</p>
<p>很好，我们几乎涵盖了 3D 数据科学应用的所有组件。但最后一步是进行部署和维护。</p>
<h1 id="6-部署与维护"><a href="#6-部署与维护" class="headerlink" title="6. 部署与维护"></a>6. 部署与维护</h1><p><img src="/../asset_3Ddatascience/22.png"></p>
<p>现在您已经构建并可视化了令人惊叹的 3D 模型，是时候将它们部署到现实世界中！本节将处理 3D 部署和维护的关键方面，确保您的模型可访问、功能齐全且保持最新。</p>
<h1 id="6-1-部署"><a href="#6-1-部署" class="headerlink" title="6.1. 部署"></a>6.1. 部署</h1><p>您 3D 模型的部署方法取决于其预期用途和目标受众。以下是一些常见策略：</p>
<p><img src="/../asset_3Ddatascience/23.png" alt="The three main families (web, desktop tools and cloud platforms)."></p>
<ul>
<li>网络应用程序：它们非常适合让任何有互联网连接的人访问您的 3D 模型。用户可以直接在网页浏览器中查看，无需下载任何特殊软件。Flask 和 Django 是两个流行的框架。</li>
<li>桌面应用程序：它们提供比网络应用程序更具互动性的体验。它们可以在用户的计算机上本地安装，并可能提供在网络浏览器环境中无法实现的额外功能。我通常使用像 PyQt 或 Electron 这样的工具。</li>
<li>云服务：云平台提供了一种可扩展且具有成本效益的方式来部署和管理您的 3D 模型。这些平台提供基础设施、存储和计算资源，可以按需访问，让您专注于构建应用程序，而无需担心管理底层硬件和软件。我建议利用像 AWS、AZURE 或 Google Cloud 这样的平台。</li>
</ul>
<p>很好。现在你已经了解了如何推广你的应用程序，最后一个阶段是如何保持它的相关性和无错误。</p>
<h1 id="6-2-维护"><a href="#6-2-维护" class="headerlink" title="6.2. 维护"></a>6.2. 维护</h1><p>就像任何创作一样，您的 3D 模型需要持续的维护，以保持其准确性和功能性。以下是一些关键做法，以确保您的 3D 项目继续提供价值。</p>
<p><img src="/../asset_3Ddatascience/24.png" alt="How to maintain your model performance and accuracy."></p>
<ul>
<li>监控: 定期检查模型的性能和准确性。</li>
<li>更新中: 根据需要整合新数据并优化模型。</li>
<li>文档: 保持全面的文档以供将来参考和协作。</li>
</ul>
<p>通过遵循这些实践并利用提供的资源，您可以确保您的 3D 数据科学应用保持良好的维护和准确性，并在未来几年继续提供价值！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>恭喜你！你已经掌握了六步指南，并且正在朝着构建有影响力的 3D 数据科学应用程序的方向迈进，如下所示。</p>
<p><img src="/../asset_3Ddatascience/25.png" alt="The linear path to deploy 3D experiences based on your data."></p>
<p>该设置需要在各个阶段进行仔细的规划和执行，从数据获取到部署。这种结构化的方法可以带来有意义的洞察、高质量的预测和三维可视化。</p>
<p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/ultimate-guide-3d-data-science-systems-and-tools-e92aaa8185eb">蓝图指南：3D 数据科学系统和工具 | 数据科学前沿 — Blueprint Guide: 3D Data Science Systems and Tools | Towards Data Science</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/08/01/Parquet_file_format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/01/Parquet_file_format/" class="post-title-link" itemprop="url">Parquet 文件格式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-01 09:49:47" itemprop="dateCreated datePublished" datetime="2024-08-01T09:49:47+08:00">2024-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-07 14:37:43" itemprop="dateModified" datetime="2024-08-07T14:37:43+08:00">2024-08-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>随着近年来数据量的指数级增长，寻找存储各种数据类型的最优方式成为了最大的挑战之一。与（不久前）过去关系数据库被视为唯一选择的情况不同，组织现在希望对原始数据进行分析——想想社交媒体情感分析、音频&#x2F;视频文件等等——这些通常无法以传统（关系）方式存储，或者以传统方式存储需要大量的努力和时间，从而增加了整体分析所需的时间。</p>
<p>另一个挑战是以某种方式坚持传统方法，以结构化的方式存储数据，但不需要设计复杂且耗时的 ETL 工作负载将这些数据移动到企业数据仓库。此外，如果您组织中的一半数据专业人员精通 Python（数据科学家、数据工程师），而另一半（数据工程师、数据分析师）精通 SQL，您会坚持让“Python 程序员”学习 SQL 吗？或者反之呢？</p>
<p>顺便说一下，如果你想学习 如何使用 Azure Synapse Analytics 从 Parquet 文件中查询数据，我可以帮你。</p>
<p>或者，您更喜欢一种可以发挥您整个数据团队优势的存储选项吗？我有好消息告诉您——这样的东西自 2013 年以来就已经存在了，它叫做 Apache Parquet。</p>
<h1 id="Parquet-文件格式简述！"><a href="#Parquet-文件格式简述！" class="headerlink" title="Parquet 文件格式简述！"></a>Parquet 文件格式简述！</h1><p>在我向您展示 Parquet 文件格式的细节之前，有（至少）五个主要原因使得 Parquet 被认为是如今存储数据的事实标准：</p>
<ul>
<li>数据压缩 — 通过应用各种编码和压缩算法，Parquet 文件提供了减少内存消耗的功能</li>
<li>列式存储 — 这在分析工作负载中至关重要，因为快速的数据读取操作是关键要求。不过，关于这一点将在文章后面详细讨论…</li>
<li>语言无关 — 如前所述，开发人员可以使用不同的编程语言来操作 Parquet 文件中的数据</li>
<li>开源格式 — 意味着您不会被特定供应商锁定</li>
<li><em><strong>对复杂数据类型的支持</strong></em></li>
</ul>
<h1 id="行存储与列存储"><a href="#行存储与列存储" class="headerlink" title="行存储与列存储"></a>行存储与列存储</h1><p>我们已经提到过 Parquet 是一种基于列的存储格式。然而，要理解使用 Parquet 文件格式的好处，我们首先需要区分基于行和基于列的数据存储方式。</p>
<p>在传统的行式存储中，数据以一系列行的形式存储。像这样：</p>
<p><img src="/../asset_parquet/01.png"></p>
<p> </p>
<p>现在，当我们谈论OLAP场景时，您的用户可能会问的一些常见问题是：</p>
<ul>
<li>我们卖了多少个球？</li>
<li>有多少来自美国的用户购买了 T 恤？</li>
<li>客户玛丽亚·亚当斯总共花费了多少？</li>
<li>我们在 1 月 2 日的销售额是多少？</li>
</ul>
<p>为了能够回答这些问题，引擎必须从头到尾扫描每一行。因此，要回答这个问题：有多少来自美国的用户购买了 T 恤，引擎必须执行类似以下的操作：</p>
<p><img src="/../asset_parquet/02.png"></p>
<p> </p>
<p>基本上，我们只需要来自两列的信息：产品（T 恤）和国家（美国），但引擎会扫描所有五列。这并不是最有效的解决方案——我想我们可以对此达成一致……</p>
<h1 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h1><p>现在让我们来看看列存储是如何工作的。正如你可能想象的那样，这种方法与传统方法截然不同。</p>
<p><img src="/../asset_parquet/03.png"></p>
<p> </p>
<p>在这种情况下，每一列都是一个独立的实体——这意味着每一列在物理上与其他列分开。回到我们之前的商业问题：引擎现在可以仅扫描查询所需的那些列（产品和国家），同时跳过扫描不必要的列。在大多数情况下，这应该会提高分析查询的性能。</p>
<p>好的，这很好，但列存储在 Parquet 之前就已经存在，并且在 Parquet 之外仍然存在。那么，Parquet 格式有什么特别之处呢？</p>
<h1 id="Parquet-是一种列式格式，它将数据存储在行组中"><a href="#Parquet-是一种列式格式，它将数据存储在行组中" class="headerlink" title="Parquet 是一种列式格式，它将数据存储在行组中"></a>Parquet 是一种列式格式，它将数据存储在行组中</h1><p>等一下，什么？！在这之前不是已经够复杂了吗？别担心，这比听起来简单得多:)</p>
<p>让我们回到之前的例子，描述一下 Parquet 将如何存储这一块相同的数据：</p>
<p><img src="/../asset_parquet/04.png"></p>
<p> </p>
<p>让我们停下来解释一下上面的插图，因为这正是 Parquet 文件的结构（一些额外的内容被故意省略，但我们很快会来解释这些）。列仍然作为单独的单元存储，但 Parquet 引入了额外的结构，称为行组。</p>
<p>为什么这个额外的结构如此重要？</p>
<p>您需要稍等一下以获取答案:)。在 OLAP 场景中，我们主要关注两个概念：<em><strong>projection</strong></em>和<em><strong>predicate(s)</strong></em> 。<em><strong>projection</strong></em>指的是 SQL 语言中的SELECT语句——查询需要哪些列。回到我们之前的例子，我们只需要产品和国家列，因此引擎可以跳过扫描其余的列。</p>
<p><em><strong>predicate(s)</strong></em> 指的是 SQL 语言中的 WHERE 子句——哪些行满足查询中定义的条件。在我们的例子中，我们只对 T 恤感兴趣，因此引擎可以完全跳过扫描第 2 行组，其中产品列中的所有值都等于袜子。</p>
<p><img src="/../asset_parquet/05.png"></p>
<p> </p>
<p>让我们在这里快速停一下，因为我希望你意识到不同类型存储在引擎需要执行的工作方面的区别：</p>
<ul>
<li>行存储 — 引擎需要扫描所有 5 列和所有 6 行</li>
<li>列存储 — 引擎需要扫描 2 列和所有 6 行</li>
<li>列存储与行组 — 引擎需要扫描 2 列和 4 行</li>
</ul>
<p>显然，这是一个过于简单化的例子，只有 6 行 5 列，在这种情况下，您肯定不会看到这三种存储选项之间的性能差异。然而，在现实生活中，当您处理更大数量的数据时，差异变得更加明显。</p>
<p>现在，合理的问题是：Parquet 是如何“知道”跳过&#x2F;扫描哪个行组的？</p>
<h1 id="Parquet-文件包含元数据"><a href="#Parquet-文件包含元数据" class="headerlink" title="Parquet 文件包含元数据"></a>Parquet 文件包含元数据</h1><p>这意味着，每个 Parquet 文件都包含“关于数据的数据”——例如特定列在某个行组中的最小值和最大值等信息。此外，每个 Parquet 文件都包含一个页脚，其中保存了关于格式版本、模式信息、列元数据等的信息。您可以在 这里 找到有关 Parquet 元数据类型的更多详细信息。</p>
<p>重要：为了优化性能并消除不必要的数据结构（行组和列），引擎首先需要“熟悉”数据，因此它首先读取元数据。这不是一个慢操作，但仍然需要一定的时间。因此，如果您从多个小的 Parquet 文件中查询数据，查询性能可能会下降，因为引擎必须从每个文件中读取元数据。因此，您最好将多个较小的文件合并为一个较大的文件（但仍然不要太大 :)…</p>
<p>我听到你说，我听到你说：尼古拉，“小”和“大”是什么？不幸的是，这里没有一个单一的“黄金”数字，但例如，微软 Azure Synapse Analytics 建议单个 Parquet 文件的大小至少应为几百 MB。</p>
<h1 id="里面还有什么？"><a href="#里面还有什么？" class="headerlink" title="里面还有什么？"></a>里面还有什么？</h1><p>这里是 Parquet 文件格式的简化高层次示意图：</p>
<p><img src="/../asset_parquet/06.png"></p>
<p> </p>
<h1 id="能比这更好吗？是的，通过数据压缩"><a href="#能比这更好吗？是的，通过数据压缩" class="headerlink" title="能比这更好吗？是的，通过数据压缩"></a>能比这更好吗？是的，通过数据压缩</h1><p>好的，我们已经解释了跳过不必要的数据结构（行组和列）的扫描如何使您的查询受益并提高整体性能。但这不仅仅是这些——还记得我一开始告诉您，Parquet 格式的主要优点之一是文件的内存占用减少吗？这是通过应用各种压缩算法实现的。</p>
<p>我已经在 Power BI（以及一般的表格模型）中写过关于各种数据压缩类型的文章 这里，所以也许从阅读这篇文章开始是个好主意。</p>
<p>有两种主要的编码类型，使 Parquet 能够压缩数据并实现惊人的空间节省：</p>
<ul>
<li>字典编码 — Parquet 创建了列中不同值的字典，然后用字典中的索引值替换“真实”值。回到我们的例子，这个过程看起来像这样：</li>
</ul>
<p><img src="/../asset_parquet/07.png"></p>
<p> </p>
<p>你可能会想：为什么要这么麻烦，产品名称不是很短吗？好吧，但现在想象一下，你存储的是产品的详细描述，比如：“长袖 T 恤，颈部有应用”。现在想象一下，这个产品卖出了一百万次……是的，与其让“长袖……等等”这个重复的值出现一百万次，Parquet 只会存储索引值（整数而不是文本）。</p>
<ul>
<li>位长编码与位打包 — 当您的数据包含许多重复值时，位长编码（RLE）算法可能会带来额外的内存节省。</li>
</ul>
<h1 id="能比这个更好吗？！是的，使用-Delta-Lake-文件格式"><a href="#能比这个更好吗？！是的，使用-Delta-Lake-文件格式" class="headerlink" title="能比这个更好吗？！是的，使用 Delta Lake 文件格式"></a>能比这个更好吗？！是的，使用 Delta Lake 文件格式</h1><p>好的，什么是 Delta Lake 格式？！这篇文章是关于 Parquet 的，对吧？</p>
<p>所以，用简单的英语来说：Delta Lake 只是“增强版”的 Parquet 格式。当我说“增强版”时，主要指的是 Parquet 文件的版本控制。它还存储一个事务日志，以便跟踪对 Parquet 文件所做的所有更改。这也被称为 符合 ACID 的事务。</p>
<p>由于它不仅支持 ACID 事务，还支持时间旅行（回滚、审计跟踪等）和数据操作语言（DML）语句，如 INSERT、UPDATE 和 DELETE，因此如果你将 Delta Lake 视为“数据湖上的数据仓库”，你不会错的（谁说的：Lakehouse :)）</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们在进化……与我们一样，数据也在进化。因此，新类型的数据需要新的存储方式。Parquet 文件格式是当前数据环境中最有效的存储选项之一，因为它提供了多种好处——在内存消耗方面，通过利用各种压缩算法，以及通过使引擎能够跳过扫描不必要的数据来实现快速查询处理。</p>
<p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/parquet-file-format-everything-you-need-to-know-ea54e27ffa6e">Parquet File Format: Everything You Need to Know | by Nikola Ilic | Jul, 2024 | Towards Data Science</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/29/GraphRAG02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/29/GraphRAG02/" class="post-title-link" itemprop="url">GraphRAG系列2 - GraphRAG和基于语义/关键字的传统RAG的比较</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-07-29 17:23:22 / 修改时间：17:34:02" itemprop="dateCreated datePublished" datetime="2024-07-29T17:23:22+08:00">2024-07-29</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="了解基于语义-关键字的-RAG"><a href="#了解基于语义-关键字的-RAG" class="headerlink" title="了解基于语义&#x2F;关键字的 RAG"></a>了解基于语义&#x2F;关键字的 RAG</h1><p>在基于语义&#x2F;关键字的 RAG 中，我们将传统的信息检索策略与语言生成相结合，以产生更准确且上下文相关的响应。</p>
<h2 id="基于语义-关键字的-RAG-的组成部分"><a href="#基于语义-关键字的-RAG-的组成部分" class="headerlink" title="基于语义&#x2F;关键字的 RAG 的组成部分"></a>基于语义&#x2F;关键字的 RAG 的组成部分</h2><p>以下是基于语义&#x2F;关键字的 RAG 的组件。</p>
<ol>
<li>文档语料库是充当知识库的文本或文档的集合。</li>
<li>嵌入模型将文本转换为捕获语义的向量表示。</li>
<li>一个矢量数据库，用于存储和索引文档的嵌入表示。</li>
<li>检索器根据查询找到相关文档。</li>
<li>一种（大）语言模型，用于根据检索到的信息和查询生成响应。</li>
</ol>
<p>以下流程代表传统的 RAG（基于语义&#x2F;关键字）流程。</p>
<p><img src="/../asset_graphrag02/01.png"></p>
<p>现在，我们不会太深入地讨论分块策略或检索策略（例如查询分解、重新排名等）的细节。这些确实有助于提高最终输出的质量。</p>
<p>我们现在了解 GraphRAG 和传统 RAG（基于语义&#x2F;关键字）的基础知识以及各自方法的组成部分。现在是时候通过示例来比较这些方法了。</p>
<p>我们将使用相同的电影场景并假设比较两种方法。</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>我们将在以下几点上比较这些方法。</p>
<ol>
<li> 知识表示</li>
<li> 检索机制</li>
<li> 上下文理解</li>
<li> 可扩展性</li>
<li> 查询解释</li>
<li> 信息综合</li>
</ol>
<h2 id="1-知识表示"><a href="#1-知识表示" class="headerlink" title="1. 知识表示"></a>1. 知识表示</h2><ul>
<li>在 GraphRAG 中，我们将电影、演员、导演和主题表示为相互关联的实体。例如，《黑客帝国》与科幻和动作类型相关，“沃卓斯基姐妹”担任导演，“基努·里维斯”担任演员。</li>
<li>在传统的 RAG 中，我们可能会将《黑客帝国》存储为文本块：“《黑客帝国》是一部 1999 年的科幻动作片，由沃卓斯基姐妹执导，由基努·里维斯主演。”</li>
</ul>
<p><img src="/../asset_graphrag02/02.png"></p>
<p>GraphRAG 的优势在于它可以轻松回答诸如“《黑客帝国》中还有哪些科幻电影明星演员？”之类的问题。通过遍历图表。</p>
<p>如果没有具体的文本提及此类联系，传统的 RAG 将难以解决这个问题。为了使这种传统的 RAG 能够处理此类查询，我们可能需要实现某种查询分解和依赖性规划。</p>
<h2 id="2-检索机制"><a href="#2-检索机制" class="headerlink" title="2. 检索机制"></a>2. 检索机制</h2><ul>
<li>在 GraphRAG 中，如果我们有一个像“科幻反乌托邦电影”这样的查询，检索可以从与“科幻”节点相似或具有“科幻”节点的社区开始，并遍历到具有“反乌托邦”这样的节点的更本地化的社区，最终检索到电影——《黑客帝国》。</li>
<li>而在传统的 RAG 中，如果没有文本块与电影“黑客帝国”或其他电影一起提及“科幻”或“反乌托邦”，那么输出可能非常通用，即与关键字“科幻”相关，或者可能有一些主题是“反乌托邦”（在大块中提到）但不是“科幻”的电影。</li>
</ul>
<p><img src="/../asset_graphrag02/03.png"></p>
<p>因此，即使查询词与存储的文本不完全匹配，GraphRAG 也可以找到相关内容。</p>
<h2 id="3-上下文理解"><a href="#3-上下文理解" class="headerlink" title="3. 上下文理解"></a>3. 上下文理解</h2><ul>
<li>GraphRAG 可以理解《盗梦空间》和《黑客帝国》是相关的，因为它们共享“科幻”类型和“令人费解的概念”主题，即使在任何文本块中都没有明确提及。</li>
<li>传统的 RAG 可能无法连接这两部电影，除非有特定的文本块来比较它们。</li>
</ul>
<p><img src="/../asset_graphrag02/04.png"></p>
<p>在这种情况下，两部电影（《盗梦空间》和《黑客帝国》）之间的关系是通过这些电影共享的类型和主题来暗示的。在图中，这两部电影之间会有联系，甚至可能形成一个社区。因此，GraphRAG 的隐式上下文理解可以帮助提供更有洞察力的建议。</p>
<h2 id="4-可扩展性"><a href="#4-可扩展性" class="headerlink" title="4. 可扩展性"></a>4. 可扩展性</h2><ul>
<li>随着我们的电影数据库的增长，GraphRAG 中的层次结构 (C0 — C1 — C2) 可实现高效导航。我们可以快速将其范围从“电影”缩小到“科幻与动作”再到“纯科幻动作”。这也取决于我们如何设计检索器——基于实体或通过社区报告的映射缩减。</li>
<li>在传统 RAG 的情况下，我们在回答广泛的查询时可能会遇到困难，因为可能存在许多与查询的各个部分类似的不相关但匹配的块。然后我们需要引入重新排名来过滤垃圾块。</li>
</ul>
<p>因此，GraphRAG 可以更有效地处理大型、复杂的数据集，尤其是探索性查询。</p>
<h2 id="5-查询解释"><a href="#5-查询解释" class="headerlink" title="5. 查询解释"></a>5. 查询解释</h2><ul>
<li>对于像“像《盗梦空间》这样的电影，但更注重动作片”这样的查询，GraphRAG 通过社区报告的映射缩减，可以理解它需要寻找“科幻惊悚片”类别中但更接近“纯科幻动作片”的类别的电影，可能暗示“黑客帝国”。</li>
<li>对于相同的查询，传统的 RAG 可能难以捕捉查询的细微差别，并且可能会返回同时提及“盗梦空间”和“动作”的电影。</li>
</ul>
<p><img src="/../asset_graphrag02/05.png"></p>
<p>因此，GraphRAG 可以处理更细微的、依赖于上下文的查询。</p>
<h2 id="6-信息综合"><a href="#6-信息综合" class="headerlink" title="6.信息综合"></a>6.信息综合</h2><ul>
<li>对于关于“从 90 年代到 2010 年代科幻电影的演变”的查询，GraphRAG 通过社区报告的 map-reduce 可以收集与“科幻”电影及其发行年份相关的信息。然后有效地利用这些信息来回答如此广泛的问题。</li>
<li>传统的 RAG 可能会获得类似于“科幻”、“90 年代”或“2010 年代”的内容，但很难将进化叙事贯穿其中。</li>
</ul>
<p><img src="/../asset_graphrag02/06.png"></p>
<p>凭借遍历相关实体的能力，GraphRAG 可以为复杂查询提供更全面的综合响应。</p>
<h1 id="没有一种RAG适合所有情况"><a href="#没有一种RAG适合所有情况" class="headerlink" title="没有一种RAG适合所有情况"></a>没有一种RAG适合所有情况</h1><p>虽然 GraphRAG 是回答更细致、更广泛和探索性问题的更好方法，但在许多用例中传统 RAG 更适合。</p>
<p>GraphRAG 在令牌数量、嵌入和检索时间方面都非常昂贵。</p>
<p>如果 GraphRAG 在本地系统上与 LLMs 一起使用，那么成本因素不是问题，但与计算文档块的嵌入相比，索引（提取 + 嵌入）时间仍然相当长。</p>
<p>对于以下情况，传统 RAG 仍然是更好的选择：</p>
<ol>
<li>简单、基于事实的查询：对于诸如“黑客帝国是哪一年发行的？”之类的问题，传统的 RAG 会更快、更直接。</li>
<li>更容易实施：对于较小的数据集或更简单的用例，传统的 RAG 可能更容易设置和维护。</li>
</ol>
<p>对于基于内容的电影推荐，用GraphRAG 实现的原因很简单，上面的比较中的不同查询示例已经对此进行了解释。</p>
<p>我们希望我们的 RAG 方法能够回答高度广泛（全球的）、细致入微（本地的）和复杂的查询。使用传统的 RAG 方法很难一致地满足如此广泛的查询。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>虽然 GraphRAG 在理解电影领域的上下文、关系和复杂查询方面具有显着优势，但传统 RAG 仍然占有一席之地，特别是对于更简单、更直接的用例。</p>
<p><a target="_blank" rel="noopener" href="https://pub.towardsai.net/graphrag-gpt-4o-mini-is-the-rag-heaven-8da0741d509b">GraphRAG + GPT-4o-Mini is the RAG Heaven | by Vatsal Saglani | Jul, 2024 | Towards AI</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/24/GraphRAG01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/24/GraphRAG01/" class="post-title-link" itemprop="url">GraphRAG系列1 - 简介GraphRAG</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-07-24 12:18:03 / 修改时间：12:35:36" itemprop="dateCreated datePublished" datetime="2024-07-24T12:18:03+08:00">2024-07-24</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>GraphRAG 是 Darren Edge 等人在《From Local to Global: A Graph RAG Approach to Query-Focused Summarization》一文中介绍的一种先进的基于图的检索增强生成 (GraphRAG) 方法。这种方法结合了图论、信息检索和LLMs。</p>
<p>核心概念是文本中的实体表示为图中的节点，这些实体之间的关系表示节点之间的边。然后，该图按层次划分为社区，并汇总为社区报告。</p>
<p>在查询时，我们必须设置探索社区的深度值来搜索相关社区。深度越深，计算&#x2F;LLM 调用就越多。</p>
<p>一旦检索到相关社区，我们就可以使用这些社区的摘要报告来回答用户查询。</p>
<p>下图描述了整个过程。</p>
<p><img src="/../asset_graphrag01/graph_rag_1-20240724094652-8avbuls.png" alt="graph_rag_1.png">  </p>
<h1 id="GraphRAG-的关键组件"><a href="#GraphRAG-的关键组件" class="headerlink" title="GraphRAG 的关键组件"></a>GraphRAG 的关键组件</h1><p>如上图所示，我们将 GraphRAG 流程分为以下三个关键部分。</p>
<ol>
<li> 提炼</li>
<li> 嵌入</li>
<li> 询问</li>
</ol>
<p>让我们分别了解这些组件。</p>
<h2 id="提炼"><a href="#提炼" class="headerlink" title="提炼"></a>提炼</h2><p>在提取组件中，我们做了以下事情，</p>
<ol>
<li> 提取实体</li>
<li>提取实体之间的关系</li>
<li>提取实体的声明</li>
<li>摘录关系的声明</li>
</ol>
<p>我们将通过一个例子来理解这一点。</p>
<p>假设我们有以下文本。</p>
<blockquote>
<p>电影：《肖申克的救赎》两个被囚禁的男人多年来结下不解之缘，通过共同的正派行为找到安慰和最终的救赎。\n年份：1994\n导演：弗兰克·达拉邦特\n演员：[“蒂姆·罗宾斯”、“摩根·弗里曼” 、“鲍勃·冈顿”、“威廉·赛德勒”]\n证书：A</p>
</blockquote>
<p><strong>步骤 1：提取实体</strong></p>
<ul>
<li>肖申克的救赎（电影）</li>
<li>弗兰克·达拉邦特（Frank Darabont）（人—导演）</li>
<li>蒂姆·罗宾斯（人 — 演员）</li>
<li>摩根·弗里曼（人 — 演员）</li>
<li>鲍勃·冈顿（人—演员）</li>
<li>威廉·赛德勒（人 — 演员）</li>
<li> 1994 (年)</li>
<li> 证书(A)</li>
</ul>
<p><strong>步骤 2：提取关系</strong></p>
<ul>
<li>肖申克的救赎 ——导演：弗兰克·达拉邦特</li>
<li>肖申克的救赎 — 明星 — 蒂姆·罗宾斯</li>
<li>肖申克的救赎 — 明星 — 摩根·弗里曼</li>
<li>肖申克的救赎 ——明星——鲍勃·冈顿</li>
<li>肖申克的救赎 — 明星 — 威廉·赛德勒</li>
<li>肖申克的救赎 ——1994 年上映</li>
<li>肖申克的救赎 — 有证书 — A</li>
</ul>
<p><strong>步骤 3-4：提取实体和关系的声明</strong></p>
<ul>
<li>肖申克的救赎：“两个被囚禁的男人多年来结下了不解之缘，通过共同的正派行为找到了安慰并最终得到救赎。”</li>
<li>肖申克的救赎：1994 年上映</li>
<li>肖申克的救赎：拥有 A 级证书</li>
</ul>
<p>中心节点将是电影的名称——肖申克的救赎。</p>
<p>如果我们要绘制实体、关系和声明，它将如下图所示。</p>
<p><img src="/../asset_graphrag01/01.png"></p>
<h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>在处理所有文档的第一个组件（提取）所需的步骤后，提取的信息将嵌入到图表中。</p>
<p>由于我们需要将电影嵌入到图表中，所以我们再看两个电影文本。</p>
<blockquote>
<p>“电影：‘盗梦空间’\n类型：[‘科幻’、‘动作’、‘惊悚片’]\n年份：2010年\n导演：克里斯托弗·诺兰\n演员：[‘莱昂纳多·迪卡普里奥’、‘约瑟夫·高登-莱维特’]\ n证书：PG-13”</p>
<p>“电影：‘黑客帝国’\n类型：[‘科幻’、‘动作’]\n年份：1999年\n导演：沃卓斯基姐妹\n演员：[‘基努·里维斯’、‘劳伦斯·菲什伯恩’]\n证书：R”</p>
</blockquote>
<p><em><strong>盗梦空间的提取输出</strong></em></p>
<p><strong>步骤 1：提取实体</strong></p>
<ul>
<li> 盗梦空间（电影）</li>
<li>克里斯托弗·诺兰（人—导演）</li>
<li>莱昂纳多·迪卡普里奥（人—演员）</li>
<li>约瑟夫·高登-莱维特（人—演员）</li>
<li> 2010年（年）</li>
<li> PG-13（证书）</li>
<li> 科幻（类型）</li>
<li> 动作（类型）</li>
<li> 惊悚片（类型）</li>
</ul>
<p><strong>步骤 2：提取关系</strong></p>
<ul>
<li>盗梦空间 — 导演 — 克里斯托弗·诺兰</li>
<li>盗梦空间 — 明星 — 莱昂纳多·迪卡普里奥</li>
<li>盗梦空间 — 明星 — 约瑟夫·高登-莱维特</li>
<li>盗梦空间 — 发布于 — 2010</li>
<li>盗梦空间 — 拥有证书 — PG-13</li>
<li>盗梦空间 ——类型——科幻</li>
<li>盗梦空间 ——类型——动作</li>
<li>盗梦空间 — 类型 — 惊悚片</li>
</ul>
<p><strong>步骤 3-4：提取实体和关系的声明</strong></p>
<ul>
<li>盗梦空间：“一个熟练的小偷拥有从人们的头脑中‘提取’信息的罕见能力，他将获得一个重获旧生活的机会，作为完成一项被认为不可能完成的任务的报酬：‘盗梦空间’，将另一个人的想法植入目标的大脑中。”潜意识。”</li>
<li>成立时间：2010年发布</li>
<li>成立：拥有 PG-13 证书</li>
<li>《盗梦空间》：是一部科幻电影</li>
<li>《盗梦空间》：是一部动作片</li>
<li>《盗梦空间》：是一部惊悚片</li>
</ul>
<p><em><strong>《黑客帝国》的提取输出</strong></em></p>
<p><strong>步骤 1：提取实体</strong></p>
<ul>
<li> 黑客帝国（电影）</li>
<li>沃卓斯基姐妹（个人 — 董事）</li>
<li>基努·里维斯（人—演员）</li>
<li>劳伦斯·菲什伯恩（人物 — 演员）</li>
<li> 1999 (年)</li>
<li> R（证书）</li>
<li> 科幻（类型）</li>
<li> 动作（类型）</li>
</ul>
<p><strong>步骤 2：提取关系</strong></p>
<ul>
<li>黑客帝国 — 导演 — 沃卓斯基姐妹</li>
<li>黑客帝国 ——明星——基努·里维斯</li>
<li>黑客帝国 ——明星——劳伦斯·菲什伯恩</li>
<li>黑客帝国 — 发布于 — 1999 年</li>
<li>黑客帝国 — 有证书 — R</li>
<li>黑客帝国 ——类型——科幻</li>
<li>黑客帝国 — 类型 — 动作</li>
</ul>
<p><strong>步骤 3-4：提取实体和关系的声明</strong></p>
<ul>
<li>《黑客帝国》：“一名计算机程序员发现他所知道的现实是机器创造的模拟，旨在征服人类，并加入叛乱以推翻他们。”</li>
<li>《黑客帝国》：1999 年上映</li>
<li>黑客帝国：拥有 R 证书</li>
<li>《黑客帝国》：是一部科幻电影</li>
<li>《黑客帝国》：是一部动作片</li>
</ul>
<p><strong>嵌入步骤 1：创建图表</strong></p>
<p>现在我们有了所有三部电影的实体、关系和声明，我们可以将它们嵌入到如下图中。</p>
<p><img src="/../asset_graphrag01/02.png">  </p>
<p><strong>嵌入步骤 2-3：检测社区并建立层次结构</strong></p>
<p>我们可以根据流派将图分为以下两个社区。</p>
<ol>
<li>戏剧和犯罪社区</li>
<li>科幻与动作社区</li>
</ol>
<p><img src="/../asset_graphrag01/03.png">  </p>
<p>我们可以使用分层社区检测算法（莱顿算法）将节点聚类成单独的社区。</p>
<p>首先，让我们看看分层社区将如何出现。</p>
<p><img src="/../asset_graphrag01/04.png">  </p>
<p>我们有以下层次结构。</p>
<ol>
<li>C0 — 电影：该社区包含我们数据集中的所有电影。它代表了跨越不同类型、时期和主题的各种电影。这些电影具有共同的元素，如导演、演员、类型和发行年份，但在具体内容和风格上有所不同。</li>
<li>C1 — 戏剧和犯罪：该社区专注于带有犯罪元素的戏剧故事讲述。</li>
<li>C1 — 科幻与动作：这个社区结合了科幻与动作的元素。</li>
<li>C2——纯科幻：这个子社区以《黑客帝国》为代表，专注于科幻概念，重点强调动作。</li>
<li>C2——科幻惊悚片：以《盗梦空间》为代表的子社区，将科幻元素与心理惊悚片相结合。</li>
</ol>
<p>有了这个层次结构，我们就有了全局和局部分类。 C0 和 C1 集群&#x2F;组&#x2F;社区非常广泛（全球），而 C2 集群&#x2F;组&#x2F;社区非常具体（本地）。</p>
<p><strong>嵌入步骤 4：总结社区</strong></p>
<ol>
<li>C1——戏剧和犯罪</li>
</ol>
<ul>
<li>强烈的人物驱动叙事</li>
<li>对人际关系和情感的探索</li>
<li>正义、救赎、坚忍的主题</li>
<li>刑事司法系统的现实写照</li>
</ul>
<ol start="2">
<li>C1——科幻与动作</li>
</ol>
<ul>
<li>未来或另类现实设置</li>
<li>令人费解的概念和技术</li>
<li>智力刺激和视觉奇观的融合</li>
<li>探索现实和意识的本质</li>
</ul>
<ol start="3">
<li>C2——纯科幻动作</li>
</ol>
<ul>
<li>反乌托邦未来设定</li>
<li>先进技术作为核心情节元素</li>
<li>高辛烷值动作序列</li>
<li>人与机器的主题</li>
</ul>
<ol start="4">
<li>C2——科幻惊悚片</li>
</ol>
<ul>
<li>复杂、层次分明的叙述</li>
<li>心理操纵与探索</li>
<li>现实与想象之间的界限变得模糊</li>
<li>智力难题和令人费解的概念</li>
</ul>
<blockquote>
<p>摘要报告还可以包含奖项、演员名录的表演、票房结果等。</p>
</blockquote>
<p><em>我们将绕一小段路，通过电影示例来了解莱顿算法。</em></p>
<h1 id="关于莱顿算法"><a href="#关于莱顿算法" class="headerlink" title="关于莱顿算法"></a>关于莱顿算法</h1><blockquote>
<p>Leiden算法是用于社区检测的Louvain方法的改进版本。它的工作原理是优化模块化——衡量社区内部链接与社区之间链接相比的密度。</p>
</blockquote>
<p>首先，让我们了解模块化。</p>
<p>模块化是衡量网络划分为社区的程度的指标。我们可以将其视为，</p>
<ul>
<li>高度模块化意味着社区内部联系较多，不同社区之间联系较少。</li>
<li>低模块化意味着连接分布更均匀，没有清晰的社区结构。</li>
</ul>
<p>对于我们的电影示例，高度模块化意味着社区内的电影具有许多共同的特征，例如科幻和动作社区。低模块化意味着戏剧和犯罪社区等共同特征较少。</p>
<h2 id="分层社区检测步骤"><a href="#分层社区检测步骤" class="headerlink" title="分层社区检测步骤"></a>分层社区检测步骤</h2><p>让我们看看电影示例中的社区检测步骤。</p>
<h3 id="步骤-1：从单个节点开始"><a href="#步骤-1：从单个节点开始" class="headerlink" title="步骤 1：从单个节点开始"></a>步骤 1：从单个节点开始</h3><p>首先将每部电影视为自己的社区。</p>
<ul>
<li>社区1：肖申克的救赎</li>
<li>社区 2：盗梦空间</li>
<li>社区 3：黑客帝国</li>
</ul>
<p><img src="/../asset_graphrag01/05.png"></p>
<p> </p>
<h3 id="步骤-2：将节点合并到社区中"><a href="#步骤-2：将节点合并到社区中" class="headerlink" title="步骤 2：将节点合并到社区中"></a>步骤 2：将节点合并到社区中</h3><p>查看电影之间的联系，例如共享类型或主题，如果可以提高模块化程度，请将它们合并。</p>
<ul>
<li>将《盗梦空间》和《黑客帝国》合并为科幻和动作社区。</li>
<li>《肖申克的救赎》仍然属于自己的戏剧和犯罪社区。</li>
</ul>
<p><img src="/../asset_graphrag01/06.png"></p>
<p> </p>
<h3 id="步骤-3：创建第一级层次结构-C1-："><a href="#步骤-3：创建第一级层次结构-C1-：" class="headerlink" title="步骤 3：创建第一级层次结构 (C1)："></a>步骤 3：创建第一级层次结构 (C1)：</h3><ul>
<li>C1 社区 1：戏剧与犯罪（肖申克的救赎）</li>
<li>C1 社区 2：科幻与动作（盗梦空间、黑客帝国）</li>
</ul>
<p><img src="/../asset_graphrag01/07.png"></p>
<p> </p>
<h3 id="步骤-4：社区作为节点"><a href="#步骤-4：社区作为节点" class="headerlink" title="步骤 4：社区作为节点"></a>步骤 4：社区作为节点</h3><p>现在将社区视为节点。</p>
<p><img src="/../asset_graphrag01/08.png"></p>
<p> </p>
<h3 id="步骤-5：在更高级别重复步骤-1、2-和-3"><a href="#步骤-5：在更高级别重复步骤-1、2-和-3" class="headerlink" title="步骤 5：在更高级别重复步骤 1、2 和 3"></a>步骤 5：在更高级别重复步骤 1、2 和 3</h3><p>寻找这些社区节点之间的联系。在这种情况下，没有足够的社区来进一步合并，因此我们在这里产生 C0 级别。</p>
<h3 id="步骤-6：细化较低级别"><a href="#步骤-6：细化较低级别" class="headerlink" title="步骤 6：细化较低级别"></a>步骤 6：细化较低级别</h3><p>返回科幻和动作社区并查找子社区。</p>
<ul>
<li>根据《盗梦空间》和《黑客帝国》更具体的特征进行拆分。</li>
</ul>
<p><img src="/../asset_graphrag01/09.png"></p>
<p> </p>
<h3 id="步骤-7：创建第二级层次结构-C2"><a href="#步骤-7：创建第二级层次结构-C2" class="headerlink" title="步骤 7：创建第二级层次结构 (C2)"></a>步骤 7：创建第二级层次结构 (C2)</h3><ul>
<li>C2 社区 1：纯科幻动作（黑客帝国）</li>
<li>C2 社区 2：科幻惊悚片（盗梦空间）</li>
</ul>
<p><img src="/../asset_graphrag01/10.png"></p>
<p> </p>
<p>最后，我们有以下层次结构。</p>
<p><img src="/../asset_graphrag01/11.png"></p>
<h2 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h2><p>在查询部分，我们使用映射缩减方法（map-reduce）来使用映射操作查找相关社区。然后将映射输出提供给reduce（缩减器）以回答用户查询。</p>
<p>让我们用一个示例查询来看看查询过程——我想看一部犯罪剧。</p>
<p>以下是整个过程的样子。</p>
<p><img src="/../asset_graphrag01/12.png"></p>
<h3 id="映射阶段"><a href="#映射阶段" class="headerlink" title="映射阶段"></a>映射阶段</h3><p>我们首先进入地图阶段。在这里，每个社区报告都会传递给映射器，映射器将输出社区与给定查询以及电影的相关程度。</p>
<p><img src="/../asset_graphrag01/13.png"></p>
<p>每个社区的地图阶段的输出如下所示。</p>
<ul>
<li> 戏剧与犯罪C1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;community&quot;: &quot;Drama &amp; Crime C1&quot;,</span><br><span class="line">    &quot;relevance_score&quot;: 95,</span><br><span class="line">    &quot;movies&quot;: [&quot;The Shawshank Redemption&quot;],</span><br><span class="line">    &quot;reason&quot;: &quot;Directly matches the crime drama genre request&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 科幻与动作 C1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;community&quot;: &quot;Sci-Fi &amp; Action C1&quot;,</span><br><span class="line">    &quot;relevance_score&quot;: 10,</span><br><span class="line">    &quot;movies&quot;: [&quot;Inception&quot;, &quot;The Matrix&quot;],</span><br><span class="line">    &quot;reason&quot;: &quot;Does not match the crime drama genre request&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 纯科幻动作C2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;community&quot;: &quot;Pure Sci-Fi Action C2&quot;,</span><br><span class="line">    &quot;relevance_score&quot;: 5,</span><br><span class="line">    &quot;movies&quot;: [&quot;The Matrix&quot;],</span><br><span class="line">    &quot;reason&quot;: &quot;Does not match the crime drama genre request&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 科幻惊悚片 C2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;community&quot;: &quot;Sci-Fi Thriller C2&quot;,</span><br><span class="line">    &quot;relevance_score&quot;: 15,</span><br><span class="line">    &quot;movies&quot;: [&quot;Inception&quot;],</span><br><span class="line">    &quot;reason&quot;: &quot;Has some thriller elements but not crime drama&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩减阶段"><a href="#缩减阶段" class="headerlink" title="缩减阶段"></a>缩减阶段</h3><p>映射阶段的输出与用户查询一起传递到缩减器，以获取相关建议和其他建议的列表。</p>
<p><img src="/../asset_graphrag01/14.png"></p>
<p>以下是reduce 阶段的输出的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;relevant_communities&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;community&quot;: &quot;Drama &amp; Crime C1&quot;,</span><br><span class="line">            &quot;relevance_score&quot;: 95,</span><br><span class="line">            &quot;movies&quot;: [&quot;The Shawshank Redemption&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;other_suggestions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;community&quot;: &quot;Sci-Fi Thriller C2&quot;,</span><br><span class="line">            &quot;relevance_score&quot;: 15,</span><br><span class="line">            &quot;movies&quot;: [&quot;Inception&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，我们可以通过 LLM 向用户查询和相关社区提供电影详细信息和建议来传达此输出。我们可以提示 LLM 根据用户查询和相关电影以及额外建议来个性化输出。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在这篇博客中，我们介绍了 GrapRAG 及其关键组件——提取、嵌入和查询。除此之外，我们还了解了使用莱顿算法进行分层社区检测。在接下来的博客中，我们将利用这些知识为基于内容的电影推荐系统开发 GraphRAG 模块 - GraphRAG4Recommendation。</p>
<p><a target="_blank" rel="noopener" href="https://pub.towardsai.net/graphrag-gpt-4o-mini-is-the-rag-heaven-b9191dbd44e1">GraphRAG + GPT-4o-Mini is the RAG Heaven | by Vatsal Saglani | Jul, 2024 | Towards AI</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/08/AIOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/08/AIOS/" class="post-title-link" itemprop="url">LLM代理操作系统 （AIOS）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-07-08 09:25:04 / 修改时间：10:31:31" itemprop="dateCreated datePublished" datetime="2024-07-08T09:25:04+08:00">2024-07-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一种称为AIOS（LLM代理操作系统）的新方法旨在改变基于大型语言模型的代理的开发和部署。通过集成到LLMs操作系统中，AIOS 创建了一个功能类似于大脑的操作系统，标志着向通用人工智能 （AGI） 迈出了一步。</p>
<p><strong>AIOS的主要特点和优势：</strong></p>
<ol>
<li>资源分配优化：AIOS改善了资源分配，确保了LLM代理请求的高效利用。</li>
<li>无缝上下文切换：它简化了在代理之间切换上下文的过程，实现了平稳过渡并保持连续性。</li>
<li>并发代理执行：AIOS 允许多个代理同时运行，从而提高整体系统性能和响应能力。</li>
<li>全面的代理工具集：它为代理提供了广泛的工具供代理使用，从而为他们提供了扩展的功能。</li>
<li>强大的访问控制：AIOS实施严格的访问控制措施，对代理权限进行管理，维护系统安全。</li>
</ol>
<p><img src="/../asset_aios/01.png" alt="Example of how an agent (i.e., Travel Agent) requires both LLM level and OS"></p>
<p>代理（即旅行代理）如何需要LLM级别和操作系统级别的资源和功能来完成任务的示例</p>
<h2 id="LLM内核"><a href="#LLM内核" class="headerlink" title="LLM内核"></a>LLM内核</h2><p>AIOS的核心是LLM内核，这是一个专门的组件，旨在通过一套专用模块管理LLM相关的活动：</p>
<ul>
<li>代理调度器：该模块优化了代理请求的调度，确保了LLM资源的高效利用。通过对请求队列进行优先级排序和管理，Agent Scheduler 可以最大限度地提高吞吐量并最小化延迟。</li>
<li>上下文管理器：上下文管理器负责保存和恢复 LLM的生成进度，即使中断，也可以无缝恢复任务。它还管理上下文窗口，确保LLM上下文容量的最佳利用。</li>
<li>内存管理器：AIOS 包括一个内存管理器，为每个代理的交互提供短期内存。这使代理能够保持本地状态并快速访问相关信息，从而提高他们的响应能力和性能。</li>
<li>存储管理器：为了实现长期持久性，存储管理器可以安全地保存代理交互。这使代理能够访问历史数据，从过去的经验中学习，并根据广泛的知识做出明智的决策。</li>
<li>工具管理器：工具管理器负责监督代理可以使用的外部 API 工具。通过集成各种工具，AIOS 使代理能够执行复杂的任务并访问丰富的信息和功能。</li>
<li>访问管理器：为确保隐私和安全，访问管理器在代理之间实施严格的访问控制策略。它管理权限、身份验证和授权，防止未经授权的访问并保护敏感数据。</li>
</ul>
<h2 id="开发人员友好的界面和-SDK"><a href="#开发人员友好的界面和-SDK" class="headerlink" title="开发人员友好的界面和 SDK"></a>开发人员友好的界面和 SDK</h2><p>AIOS 提供了一个直观的LLM系统调用接口，允许开发人员轻松地与底层LLM内核进行交互。此外，AIOS SDK 提供了一套全面的工具和库，使开发人员能够轻松创建复杂的代理应用程序。SDK 抽象了复杂的功能，使代理开发更加易于访问和高效。</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>AIOS采用三层架构，保证模块化、可扩展性和性能：</p>
<ol>
<li>应用程序层：此层是开发和部署代理应用程序的地方。开发人员利用 AIOS SDK 创建可以执行各种任务的智能和交互式代理。</li>
<li>内核层：内核层由两个主要组件组成 — 操作系统内核和LLM内核。操作系统内核处理常规操作系统任务，而LLM内核则专门用于管理LLM特定的活动，确保最佳性能和资源利用率。</li>
<li>硬件层：硬件层包含系统的物理组件，例如 CPU、GPU、内存和存储设备。AIOS 有效地利用这些资源来提供无缝且高性能的代理执行环境。</li>
</ol>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>在AIOS上进行的实验表明，它能够同时运行多个代理，并具有出色的可靠性和效率。即使代理请求暂停和恢复，LLM响应也保持一致，从而确保了生成的输出的完整性。此外，AIOS的智能调度机制明显优于顺序代理执行，在等待和处理时间上实现了更好的平衡。</p>
<p><img src="/../asset_aios/02.png" alt="AIOS architecture"></p>
<p>AIOS 架构概述</p>
<h2 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h2><p>虽然 AIOS 为LLM基于代理的开发和部署提供了一种开创性的方法，但未来还有几种令人兴奋的研究和改进途径：</p>
<ul>
<li>高级调度算法：开发考虑座席请求之间的依赖关系的调度算法，并根据优先级和紧急程度优化资源分配。</li>
<li>高效的上下文管理：探索更高效地管理上下文的技术，例如上下文压缩和摘要，以最大限度地提高上下文窗口的LLM利用率。</li>
<li>优化内存和存储：研究优化内存和存储架构的方法，以促进无缝代理协作，例如实施共享内存池和分层缓存机制。</li>
<li>增强安全性和隐私性：不断增强 AIOS 的安全和隐私功能，包括高级加密技术、安全通信协议和强大的访问控制机制。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>AIOS代表了开发和部署基于代理的LLM的一步。通过集成到LLMs操作系统中，AIOS为代理执行创造了一个智能高效的环境。凭借其全面的模块集、开发人员友好的界面和优化的架构，AIOS 为智能代理生态系统奠定了基础。</p>
<p>随着研究人员继续探索和扩展AIOS的功能，我们可以预见未来，基于LLM智能体的代理将变得越来越复杂、自主，并成为各个领域不可或缺的一部分。AIOS开辟了许多可能性，为下一代智能系统铺平了道路，这些系统能够以前所未有的方式理解、推理并与世界互动。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@simeon.emanuilov/llm-agent-operating-system-aios-and-the-future-of-llm-powered-agents-3d08b4e91c34">https://medium.com/@simeon.emanuilov/llm-agent-operating-system-aios-and-the-future-of-llm-powered-agents-3d08b4e91c34</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/04/knowledge-transfer-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/04/knowledge-transfer-tutorial/" class="post-title-link" itemprop="url">英文知识搬运教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-04 10:21:12" itemprop="dateCreated datePublished" datetime="2024-07-04T10:21:12+08:00">2024-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-21 14:19:16" itemprop="dateModified" datetime="2024-08-21T14:19:16+08:00">2024-08-21</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前搬运很多medium的文章，搬运过程很耗时间，首先要把网页文章翻译成中文，然后一段段的校对，拷贝黏贴到markdown文件中，图片文件要下载存储更名到本地，编写markdown文件链接。最后再转换成html文件发布到github io博客。经常要2~3个小时才能完成一篇文章的搬运。</p>
<p>前两天发现思源笔记可以直接拷贝粘贴翻译好的文章，生成笔记，作为平时的网络摘抄笔记。评估了一下思源的会员，最后还是安装思源笔记docker server版本，免费开源。会员有图传和同步功能，对于程序员来说，可以克服这些问题。</p>
<p>言归正传，对于经典的文章，想要发布到博客的，可以用思源笔记把文章导出到markdown文件，省掉编辑markdown的时间。不过，markdown里面的图片链接都是远程的，我们当然不希望这些图片不受控制，所以还需要把图片下载到本地，然后更新markdown文件中的链接。思源笔记有图床，不过要收费，而且一样不受控。思源笔记有转换远程图片到本地的功能，不过对medium搞不定。</p>
<p>所以，还是自己动手吧，写个python脚本，自动下载markdown的远程链接文件，把图片下载到本地，更新链接，这样就可以省下很多时间，而且图片也能更好地管理。</p>
<p>pip install requests python-magic</p>
<p>对于windows系统，还需要 pip install python-magic-bin</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> magic</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_images_and_update_markdown</span>(<span class="params">markdown_file, output_directory</span>):</span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_directory):</span><br><span class="line">        os.makedirs(output_directory)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将输出目录转换为绝对路径</span></span><br><span class="line">    output_directory = os.path.abspath(output_directory)</span><br><span class="line">    markdown_file = os.path.abspath(markdown_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取Markdown文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(markdown_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = file.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用正则表达式匹配图片URL</span></span><br><span class="line">    urls = re.findall(<span class="string">r&#x27;!\[.*?\]\((https?://[^\s]+)\)&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储远程到本地文件的映射</span></span><br><span class="line">    url_to_local = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls, start=<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 临时文件路径</span></span><br><span class="line">            temp_filename = os.path.join(output_directory, <span class="string">f&quot;temp_<span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 下载文件</span></span><br><span class="line">            response = requests.get(url, headers=headers)</span><br><span class="line">            response.raise_for_status()  <span class="comment"># 检查请求是否成功</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存临时文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(temp_filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(response.content)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用magic库检测文件类型</span></span><br><span class="line">            mime = magic.Magic(mime=<span class="literal">True</span>)</span><br><span class="line">            mime_type = mime.from_file(temp_filename)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 根据mime类型确定扩展名</span></span><br><span class="line">            <span class="keyword">if</span> mime_type == <span class="string">&#x27;image/jpeg&#x27;</span>:</span><br><span class="line">                extension = <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> mime_type == <span class="string">&#x27;image/png&#x27;</span>:</span><br><span class="line">                extension = <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> mime_type == <span class="string">&#x27;image/gif&#x27;</span>:</span><br><span class="line">                extension = <span class="string">&#x27;.gif&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                extension = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> extension:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Failed to determine the file type of <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最终文件名</span></span><br><span class="line">            filename = os.path.join(output_directory, <span class="string">f&quot;<span class="subst">&#123;index:02&#125;</span><span class="subst">&#123;extension&#125;</span>&quot;</span>)</span><br><span class="line">            os.rename(temp_filename, filename)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Downloaded: <span class="subst">&#123;url&#125;</span> to <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算相对于Markdown文件的相对路径并替换反斜杠为正斜杠</span></span><br><span class="line">            relative_path = os.path.relpath(filename, os.path.dirname(markdown_file)).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存远程到本地文件的映射</span></span><br><span class="line">            url_to_local[url] = relative_path</span><br><span class="line">        <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Failed to download <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新Markdown文件内容</span></span><br><span class="line">    <span class="keyword">for</span> url, local_path <span class="keyword">in</span> url_to_local.items():</span><br><span class="line">        content = content.replace(url, local_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将更新后的内容写回Markdown文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(markdown_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Download images from a markdown file and update the links.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;markdown_file&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;The path to the markdown file.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;output_directory&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;The path to the output directory.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    download_images_and_update_markdown(args.markdown_file, args.output_directory)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/03/serveless-ai/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/03/serveless-ai/" class="post-title-link" itemprop="url">使用 Google Cloud 预训练 AI 构建无服务器图像文本提取器和翻译器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 17:52:25" itemprop="dateCreated datePublished" datetime="2024-07-03T17:52:25+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-04 11:16:21" itemprop="dateModified" datetime="2024-07-04T11:16:21+08:00">2024-07-04</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>53 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/../asset_serveless_ai/01.jpg"></p>
<p> 图像-文本-翻译器</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一篇关于Google Cloud端到端开发体验的博客。</p>
<p><img src="/../asset_serveless_ai/02.png"></p>
<p>在这篇博客中，我将讨论如何构建一个无服务器 AI 应用程序，该应用程序获取用户上传的图像，提取它找到的任何文本，并在必要时对其进行翻译。我将利用：</p>
<ul>
<li>Cloud Run 以 Python Flask 应用程序的形式托管 UI。</li>
<li>Cloud Functions，用于托管后端逻辑以响应用户上传图像。</li>
<li><strong>Google 预构建的图像和翻译 AI 机器学习 API。</strong></li>
<li>使用 Visual Studio Code 进行本地开发，以及 functions-framework 用于本地 Cloud Functions 开发的 Cloud Code，以及用于本地 Cloud Run 开发的 Cloud Code。</li>
</ul>
<h1 id="AI-和-AI-产品概览"><a href="#AI-和-AI-产品概览" class="headerlink" title="AI 和 AI 产品概览"></a>AI 和 AI 产品概览</h1><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>人工智能是一个广义的术语，用于描述利用机器自动化来执行通常需要人类智能的任务。例如语音识别、视觉感知、语言翻译、决策。</p>
<p><img src="/../asset_serveless_ai/03.gif"></p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>人工智能的一个特定子领域，与教机器识别数据模式有关，并且能够在没有明确编码解决方案的情况下进行预测和解决问题。</p>
<h2 id="生成式人工智能（Gen-AI）"><a href="#生成式人工智能（Gen-AI）" class="headerlink" title="生成式人工智能（Gen AI）"></a>生成式人工智能（Gen AI）</h2><p>AI 的一个子类，能够生成与训练数据相似但不相同的新数据。Gen AI 依赖于基础模型，例如大型语言模型 （）、LLMs生成图像模型和多模态模型。多模态模型是一种能够处理多种类型的输入数据（例如文本、图像和视频）并生成多种类型内容的模型。</p>
<p><img src="/../asset_serveless_ai/04.png"></p>
<p>多模态 Gen AI — 例如 Google Gemini Pro</p>
<p>我的解决方案不会使用 Gen AI。但我在这里提到它，因为 Gen AI 非常普遍，我想确保你了解这些模型与我在解决方案中使用的预测模型有何不同。</p>
<h2 id="Google-的预训练机器学习-API"><a href="#Google-的预训练机器学习-API" class="headerlink" title="Google 的预训练机器学习 API"></a>Google 的预训练机器学习 API</h2><p>这些是 Google 预先构建和训练的 ML 模型，用于执行特定任务。它们被归类为预测模型，而不是生成模型。示例包括：</p>
<ul>
<li>Google Cloud Vision API — 用于分类、面部识别和文本检测等任务。</li>
<li>Google Cloud Natural Language API— 用于理解文本背后的含义。这包括识别文本的重要元素，以及情感分析。</li>
<li>Google Cloud Translation API — 用于将一种语言翻译成另一种语言。</li>
<li>Google Cloud Video — 用于视频分析和注释。</li>
</ul>
<h1 id="申请动机"><a href="#申请动机" class="headerlink" title="申请动机"></a>申请动机</h1><p>我学习乌克兰语已经有一段时间了,乌克兰有一种模因。有时我会理解这个模因。通常我不会。</p>
<p><img src="/../asset_serveless_ai/11.png"></p>
<p> 乌克兰模因</p>
<p>所以我想……“我想要一个应用程序，我可以上传一个模因（或任何图像），从中提取文本，并将该文本翻译成我的母语。”</p>
<p>当然，还有其他方法可以做到这一点。但我认为这是一个很好的用例，可以在 Google Cloud 中从头开始构建一个新的无服务器应用程序。</p>
<h1 id="应用程序架构"><a href="#应用程序架构" class="headerlink" title="应用程序架构"></a>应用程序架构</h1><p>这是一个非常简单的应用程序架构，托管在 Google Cloud 无服务器服务上：</p>
<p><img src="/../asset_serveless_ai/06.png"></p>
<p>图像-文本-翻译器应用程序的体系结构</p>
<h2 id="The-Webapp-UI-—-Cloud-Run"><a href="#The-Webapp-UI-—-Cloud-Run" class="headerlink" title="The Webapp UI — Cloud Run"></a>The Webapp UI — Cloud Run</h2><p>在这里，我在 Google Cloud Run 上将 Flask Web 应用程序作为容器运行。Web 应用程序执行以下几项操作：</p>
<ol>
<li>它呈现包含用于捕获用户输入（例如语言和图像上传）的表单的前端页面。</li>
<li>它处理来自用户的请求，捕获图像，并将其发送到 Cloud Function 后端。</li>
</ol>
<p>我之所以选择 Cloud Run，是因为：</p>
<ul>
<li>它提供了一种托管和运行容器化应用程序的无服务器方式。（即我们的 Python Flask Web 应用程序。</li>
<li>它非常适合托管简单的无状态 Web 应用程序，例如这个应用程序。</li>
<li>它会自动扩展，并在没有需求时缩减到 0 个实例。</li>
</ul>
<h2 id="后端-—-云函数"><a href="#后端-—-云函数" class="headerlink" title="后端 — 云函数"></a>后端 — 云函数</h2><p>Cloud Function 从用户处接收图像（通过 Web 应用程序界面），然后调用相应的 Google Cloud API，以便从图像中提取文本并进行翻译。</p>
<p>我之所以选择 Cloud Functions，是因为：</p>
<ul>
<li>它非常适合执行短期处理，以响应事件。因此，非常适合运行我们的提取和翻译任务，以响应用户上传的图像。</li>
<li>它会自动缩放，并在没有需求时缩减到 0。</li>
<li>我们可以将图像处理与实际用户前端解耦。因此，如果我们想使用不同的前端，我们可以轻松地做到这一点，而无需更改云函数中的代码。</li>
</ul>
<h2 id="文本提取和翻译"><a href="#文本提取和翻译" class="headerlink" title="文本提取和翻译"></a>文本提取和翻译</h2><p>我正在使用 Google 预构建的 Vision API 和 Translation API。但是，为什么不使用生成式AI模型，例如Gemini Pro Vision呢？</p>
<ul>
<li>视觉和翻译 API 是专门为我想要执行的任务而构建的。</li>
<li>相反，Gemini Pro Gen AI 多模态基础模型可以响应自然语言提示，实现相同的结果。但是，我们在这里不需要自然语言交互。为什么？因为我们确切地知道我们希望 API 在响应图像上传时执行什么操作。</li>
<li>尽管 Gemino Pro Vision 作为多模态基础模型具有更多的多功能性，但这种功能伴随着更高的价格标签。Vision API 每月允许 1000 次免费调用;翻译 API 每月免费提供前五十万个字符的翻译。</li>
</ul>
<h1 id="我的开发环境"><a href="#我的开发环境" class="headerlink" title="我的开发环境"></a>我的开发环境</h1><h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>我正在运行 Windows，其中包含适用于 Linux 的 Windows 子系统 （WSL）。对于那些不熟悉 WSL 的人来说，它是一个开箱即用的环境（包含在 Windows 10 及更高版本中），允许直接在 Windows 中运行完整的 Linux 环境。我碰巧在使用 Ubuntu。</p>
<p>在 WSL 中工作的好处是我可以用 bash 编写任何必要的脚本，这意味着我的代码将更具可移植性。例如，我可以在自己的环境中运行与在 Google Cloud Shell 中相同的脚本。</p>
<h2 id="Visual-Studio-代码"><a href="#Visual-Studio-代码" class="headerlink" title="Visual Studio 代码"></a>Visual Studio 代码</h2><p>VS Code 是我选择的代码编辑器。它是免费和开源的。它在 Windows、Linux 和 Mac 上运行，并具有许多有用的插件，例如 Git 集成和 Google Cloud Code：一组 AI 辅助插件（包括 Gemini Code Assist），用于促进使用 Google Cloud 服务的本地开发。</p>
<h1 id="开发项目结构"><a href="#开发项目结构" class="headerlink" title="开发项目结构"></a>开发项目结构</h1><p>如果你想查看 git 存储库，你可以在这里找到它。</p>
<p>整体结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">└── image-text-translator</span><br><span class="line">    ├── docs/                   - Documentation for the repo</span><br><span class="line">    |</span><br><span class="line">    ├── infra-tf/               - Terraform for installing infra</span><br><span class="line">    |</span><br><span class="line">    ├── scripts/                - For environment setup and helper scripts</span><br><span class="line">    |   └── setup.sh            - Setup helper script</span><br><span class="line">    |</span><br><span class="line">    ├── app/                    - The Application</span><br><span class="line">    │   ├── ui_cr/                - Browser UI (Cloud Run)</span><br><span class="line">    │   │   ├── static/             - Static content for frontend</span><br><span class="line">    |   |   ├── templates/          - HTML templates for frontend</span><br><span class="line">    |   |   ├── app.py              - The Flask application</span><br><span class="line">    |   |   ├── requirements.txt    - The UI Python requirements</span><br><span class="line">    |   |   ├── Dockerfile             - Dockerfile to build the Flask container</span><br><span class="line">    |   |   └── .dockerignore          - Files to ignore in Dockerfile</span><br><span class="line">    |   |</span><br><span class="line">    │   └── backend_gcf/          - Backend (Cloud Function)</span><br><span class="line">    │       ├── main.py             - The backend CF application</span><br><span class="line">    │       └── requirements.txt    - The backend CF Python requirements</span><br><span class="line">    |</span><br><span class="line">    ├── testing/</span><br><span class="line">    │   └── images/</span><br><span class="line">    |</span><br><span class="line">    ├── requirements.txt          - Python requirements for project local dev</span><br><span class="line">    └── README.md</span><br></pre></td></tr></table></figure>

<h1 id="一次性-Google-项目设置和权限"><a href="#一次性-Google-项目设置和权限" class="headerlink" title="一次性 Google 项目设置和权限"></a>一次性 Google 项目设置和权限</h1><h2 id="创建-Google-Cloud-项目"><a href="#创建-Google-Cloud-项目" class="headerlink" title="创建 Google Cloud 项目"></a>创建 Google Cloud 项目</h2><p>为您的应用创建 Google Cloud 项目。这是我的：</p>
<p><img src="/../asset_serveless_ai/07.png"></p>
<p>创建您的 Google Cloud 项目</p>
<p>从具有足够权限的帐户（例如 或 Project Admin Org Admin .</p>
<h2 id="启用-API"><a href="#启用-API" class="headerlink" title="启用 API"></a>启用 API</h2><p>最终，我们将对这种配置进行 Terraform。但最初，这些是您需要启用的 API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Authenticate to Google Cloud</span><br><span class="line">gcloud auth list</span><br><span class="line"></span><br><span class="line"># Check we have the correct project selected</span><br><span class="line">export PROJECT_ID=&lt;enter your project ID&gt;</span><br><span class="line">gcloud config set project $PROJECT_ID</span><br><span class="line"></span><br><span class="line"># Enable Cloud Build API</span><br><span class="line">gcloud services enable cloudbuild.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Storage API</span><br><span class="line">gcloud services enable storage-api.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Artifact Registry API</span><br><span class="line">gcloud services enable artifactregistry.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Eventarc API</span><br><span class="line">gcloud services enable eventarc.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Run Admin API</span><br><span class="line">gcloud services enable run.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Logging API</span><br><span class="line">gcloud services enable logging.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Pub/Sub API</span><br><span class="line">gcloud services enable pubsub.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Functions API</span><br><span class="line">gcloud services enable cloudfunctions.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Translation API</span><br><span class="line">gcloud services enable translate.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Vision API</span><br><span class="line">gcloud services enable vision.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Service Account Credentials API</span><br><span class="line">gcloud services enable iamcredentials.googleapis.com</span><br></pre></td></tr></table></figure>

<h2 id="服务帐户和角色"><a href="#服务帐户和角色" class="headerlink" title="服务帐户和角色"></a>服务帐户和角色</h2><p>服务帐户是管理应用程序（而不是最终用户）的身份验证和授权的标准方法。我们的 Cloud Run 应用程序需要向 Cloud Function 进行身份验证，而 Cloud Function 需要向 Cloud Cloud Vision 和 Translation API 进行身份验证。</p>
<p>因此，让我们创建一个服务帐户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Make sure your PROJECT_ID variable is set before doing this!</span><br><span class="line">export SVC_ACCOUNT=image-text-translator-sa</span><br><span class="line">export SVC_ACCOUNT_EMAIL=$SVC_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com</span><br><span class="line"></span><br><span class="line"># Attaching a user-managed service account is the preferred way to provide credentials to ADC for production code running on Google Cloud.</span><br><span class="line">gcloud iam service-accounts create $SVC_ACCOUNT</span><br></pre></td></tr></table></figure>

<p>现在，我们将多个角色绑定到我们的服务帐户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Grant roles to the service account</span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/run.admin</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/run.invoker</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/cloudfunctions.admin</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/cloudfunctions.invoker</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=&quot;roles/cloudtranslate.user&quot;</span><br><span class="line"></span><br><span class="line"># Grant the required role to the principal that will attach the service account to other resources.</span><br><span class="line">gcloud iam service-accounts add-iam-policy-binding $SVC_ACCOUNT_EMAIL \</span><br><span class="line">  --member=&quot;group:gcp-devops@my-org.com&quot; \</span><br><span class="line">  --role=roles/iam.serviceAccountUser</span><br><span class="line"></span><br><span class="line"># Allow service account impersonation</span><br><span class="line">gcloud iam service-accounts add-iam-policy-binding $SVC_ACCOUNT_EMAIL \</span><br><span class="line">  --member=&quot;group:gcp-devops@my-org.com&quot; \</span><br><span class="line">  --role=roles/iam.serviceAccountTokenCreator</span><br><span class="line"></span><br><span class="line"># Ensure your account has access to deploy to Cloud Functions and Cloud Run</span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">   --member=&quot;group:gcp-devops@my-org.com&quot; \</span><br><span class="line">   --role roles/run.admin</span><br></pre></td></tr></table></figure>

<h1 id="本地开发环境设置"><a href="#本地开发环境设置" class="headerlink" title="本地开发环境设置"></a>本地开发环境设置</h1><p>（您需要在计划进行开发的任何计算机上执行这些步骤。</p>
<p>打开终端。（我正在从 Windows 终端打开 Ubuntu Shell。如果您尚未这样做，则需要将 Google gcloud CLI 和支持工具安装到您的本地环境中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Install Google Cloud CLI in your local Linux environment.</span><br><span class="line"># See https://cloud.google.com/sdk/docs/install</span><br><span class="line"></span><br><span class="line"># Setup Python and pip in Gcloud CLI</span><br><span class="line"># See https://cloud.google.com/python/docs/setup</span><br><span class="line"></span><br><span class="line"># Install additional Google Cloud CLI packages for local dev</span><br><span class="line">sudo apt install google-cloud-cli-gke-gcloud-auth-plugin kubectl google-cloud-cli-skaffold google-cloud-cli-minikube</span><br></pre></td></tr></table></figure>

<p>在这里（从现在开始），我们将使用我们的开发人员帐户进行身份验证，而不是组织管理员帐户。为什么？我遵循最小特权原则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Authenticate to Google Cloud</span><br><span class="line">gcloud auth login</span><br></pre></td></tr></table></figure>

<p>身份验证时，单击显示的第一个链接。然后，系统会提示您提供密码。</p>
<p><img src="/../asset_serveless_ai/08.png"></p>
<p>向 Google Cloud 进行身份验证</p>
<p>接下来，我们将设置应用程序项目文件夹并安装一些依赖项。如果您要遵循并从头开始构建应用程序，则接下来的步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># This is where I keep my project</span><br><span class="line">cd ~/localdev/gcp/image-text-translator</span><br><span class="line"></span><br><span class="line"># Create a Python virtual env. For example...</span><br><span class="line">python3 -m venv .venv</span><br><span class="line"># And now ACTIVATE it</span><br><span class="line"></span><br><span class="line"># Add Python packages we need...</span><br><span class="line">python3 -m pip install Flask</span><br><span class="line">python3 -m pip install pillow # For image handling</span><br><span class="line">python3 -m pip install functions-framework</span><br><span class="line">python3 -m pip install google-cloud-storage google-cloud-translate google-cloud-vision google-auth</span><br><span class="line"></span><br><span class="line"># And create the requirements.txt file</span><br><span class="line">python3 -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>或者，如果你想克隆我的 git 存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/derailed-dash/image-text-translator.git</span><br><span class="line"></span><br><span class="line">cd image-text-translator</span><br><span class="line"></span><br><span class="line"># Create a Python virtual env. For example...</span><br><span class="line">python3 -m venv .venv</span><br><span class="line"># And now ACTIVATE it. E.g.</span><br><span class="line">source .venv/bin/activate</span><br><span class="line"></span><br><span class="line"># Install the Python dependencies now</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="Git-设置"><a href="#Git-设置" class="headerlink" title="Git 设置"></a>Git 设置</h2><p>如果你从头开始构建所有内容（没有克隆我的存储库），你现在应该设置你的 Git 和 GitHub 环境。别忘了先创建 .gitignore .查看我的存储库以了解它应该是什么样子。然后按照下列步骤操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Setup git in Cloud Shell, if you haven&#x27;t done so before</span><br><span class="line">git config --global user.email &quot;bob@wherever.com&quot;</span><br><span class="line">git config --global user.name &quot;Bob&quot;</span><br><span class="line">git config --global core.autocrlf input # really important if you&#x27;re using WSL!</span><br><span class="line"></span><br><span class="line"># Create local git repo.</span><br><span class="line"># Before proceeding, make sure you have created .gitignore file </span><br><span class="line"># to ignore .terraform dirs and local state, plans, etc.</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line"># Let&#x27;s authenticate the GitHub command line tool</span><br><span class="line"># It is already installed on Cloud Shell</span><br><span class="line">gh auth login</span><br><span class="line"></span><br><span class="line"># Now let&#x27;s use gh cli to create a remote repo in GitHub.</span><br><span class="line"># You can make it private, if you prefer</span><br><span class="line">gh repo create image-text-translator --public --source=.</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="运行-VS-Code"><a href="#运行-VS-Code" class="headerlink" title="运行 VS Code"></a>运行 VS Code</h2><p>让我们从项目文件夹中打开 VS Code：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># From /path/to/your/image-text-translator</span><br><span class="line">code .</span><br></pre></td></tr></table></figure>

<p>VS Code 足够聪明，可以配置所需的任何必要的 WSL 插件。</p>
<p><img src="/../asset_serveless_ai/09.png"></p>
<p>VS Code 知道它在 WSL 环境中工作</p>
<h2 id="安装应用程序默认凭据-（ADC）"><a href="#安装应用程序默认凭据-（ADC）" class="headerlink" title="安装应用程序默认凭据 （ADC）"></a>安装应用程序默认凭据 （ADC）</h2><p>ADC 是一种策略，它允许身份验证库根据当前环境自动查找凭据。这很有用，因为我们既可以在本地环境（使用 Cloud SDK）中利用 ADC，也可以在 Google Cloud 上的目标环境中利用 ADC。</p>
<p>ADC 可以配置为使用我们的服务帐户凭据。有两种方法可以做到这一点：</p>
<ol>
<li>我们可以使用自己的用户身份模拟服务帐户。</li>
<li>我们可以为我们的服务帐户创建一个私钥，并将 ADC 指向此密钥的位置。</li>
</ol>
<p>我最初尝试使用模拟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud auth application-default login --impersonate-service-account $SVC_ACCOUNT_EMAIL</span><br></pre></td></tr></table></figure>

<p>不幸的是，在对 Cloud Run 的 Cloud Function 调用进行身份验证时，我很难做到这一点。因此，我创建了一个服务帐户密钥，我们可以将 ADC 指向：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gcloud auth application-default login</span><br><span class="line"></span><br><span class="line"># If these are not already set...</span><br><span class="line">export SVC_ACCOUNT=image-text-translator-sa</span><br><span class="line">export SVC_ACCOUNT_EMAIL=$SVC_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com</span><br><span class="line"></span><br><span class="line"># Create a service account key for local dev</span><br><span class="line">gcloud iam service-accounts keys create ~/.config/gcloud/$SVC_ACCOUNT.json \</span><br><span class="line">  --iam-account=$SVC_ACCOUNT_EMAIL</span><br><span class="line"></span><br><span class="line"># Configure the ADC environment variable</span><br><span class="line"># which is automatically detected by client libraries</span><br><span class="line">export GOOGLE_APPLICATION_CREDENTIALS=~/.config/gcloud/$SVC_ACCOUNT.json</span><br></pre></td></tr></table></figure>

<p>我们实际上需要在每个会话中设置这个 GOOGLE_APPLICATION_CREDENTIALS 环境变量。这就把我们带到了…</p>
<h1 id="每个会话的设置"><a href="#每个会话的设置" class="headerlink" title="每个会话的设置"></a>每个会话的设置</h1><p>您需要在每个新的终端会话中运行这些命令。（或者，您可以运行命令 source <project_dir>&#x2F;scripts&#x2F;setup.sh 来运行这些命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export PROJECT_ID=$(gcloud config list --format=&#x27;value(core.project)&#x27;)</span><br><span class="line">export REGION=europe-west4</span><br><span class="line">export SVC_ACCOUNT=image-text-translator-sa</span><br><span class="line">export SVC_ACCOUNT_EMAIL=$SVC_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com</span><br><span class="line">export GOOGLE_APPLICATION_CREDENTIALS=~/.config/gcloud/$SVC_ACCOUNT.json</span><br><span class="line"></span><br><span class="line"># Functions</span><br><span class="line">export FUNCTIONS_PORT=8081</span><br><span class="line">export BACKEND_GCF=https://$REGION-$PROJECT_ID.cloudfunctions.net/extract-and-translate</span><br><span class="line"></span><br><span class="line"># Flask</span><br><span class="line">export FLASK_SECRET_KEY=some-secret-1234</span><br><span class="line">export FLASK_RUN_PORT=8080</span><br><span class="line"></span><br><span class="line">echo &quot;Environment variables configured:&quot;</span><br><span class="line">echo PROJECT_ID=&quot;$PROJECT_ID&quot;</span><br><span class="line">echo REGION=&quot;$REGION&quot;</span><br><span class="line">echo SVC_ACCOUNT_EMAIL=&quot;$SVC_ACCOUNT_EMAIL&quot;</span><br><span class="line">echo BACKEND_GCF=&quot;$BACKEND_GCF&quot;</span><br><span class="line">echo FUNCTIONS_PORT=&quot;$FUNCTIONS_PORT&quot;</span><br><span class="line">echo FLASK_RUN_PORT=&quot;$FLASK_RUN_PORT&quot;</span><br></pre></td></tr></table></figure>

<h1 id="云函数后端"><a href="#云函数后端" class="headerlink" title="云函数后端"></a>云函数后端</h1><h2 id="功能的本地开发"><a href="#功能的本地开发" class="headerlink" title="功能的本地开发"></a>功能的本地开发</h2><p>我不会重现所有代码，因为您可以在 GitHub 中查看它。我只想指出几件关键的事情。</p>
<p>在我的 backend-gcf 文件夹中，我创建了一个 requirements.txt .这是为了定义必须安装的 Python 包。当您部署 Cloud Functions 时，Cloud Functions 会自动安装这些软件包。</p>
<p>然后我创建一个 main.py .以下是作为云函数入口点的部分函数： extract_and_translate() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@functions_framework.http</span><br><span class="line">def extract_and_translate(request):</span><br><span class="line">    &quot;&quot;&quot;Extract and translate the text from an image.</span><br><span class="line">    The image can be POSTed in the request, or it can be a GCS object reference.</span><br><span class="line"></span><br><span class="line">    If a POSTed image, enctype should be multipart/form-data and the file should be named &#x27;uploaded&#x27;.</span><br><span class="line">    If we&#x27;re passing a GCS object reference, content-type should be &#x27;application/json&#x27;, </span><br><span class="line">    with two attributes:</span><br><span class="line">    - bucket: name of GCS bucket in which the file is stored.</span><br><span class="line">    - filename: name of the file to be read.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # Check if the request method is POST</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        # Get the uploaded file from the request</span><br><span class="line">        uploaded = request.files.get(&#x27;uploaded&#x27;)  # Assuming the input filename is &#x27;uploaded&#x27;</span><br><span class="line">        to_lang = request.form.get(&#x27;to_lang&#x27;, &quot;en&quot;)</span><br><span class="line">        print(f&quot;&#123;uploaded=&#125;, &#123;to_lang=&#125;&quot;)</span><br><span class="line">        if not uploaded:</span><br><span class="line">            return flask.jsonify(&#123;&quot;error&quot;: &quot;No file uploaded.&quot;&#125;), 400</span><br><span class="line"></span><br><span class="line">        if uploaded: # Process the uploaded file</span><br><span class="line">            file_contents = uploaded.read()  # Read the file contents</span><br><span class="line">            image = vision.Image(content=file_contents)</span><br><span class="line">        else:</span><br><span class="line">            return flask.jsonify(&#123;&quot;error&quot;: &quot;Unable to read uploaded file.&quot;&#125;), 400</span><br></pre></td></tr></table></figure>

<p>这是不言自明的。</p>
<ul>
<li>我们检查函数是否已收到 POST。 （稍后，我们将创建 Cloud Run 应用程序来 POST 请求。</li>
<li>如果是这样，我们将在请求中查找一个名为 uploaded 的对象。（我们的 Cloud Run 应用程序会将其附加到请求中。</li>
<li>如果我们发现这个对象附加了，我们把它读成二进制，然后用它来创建 vision.Image 对象。</li>
<li>接下来我们调用函数 detect_text() ，传入图像。此函数将使用 Vision API 查看图像中是否有任何文本。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Use the Vision API to extract text from the image</span><br><span class="line">detected = detect_text(image)</span><br><span class="line">if detected:</span><br><span class="line">   translated = translate_text(detected, to_lang)</span><br><span class="line">   if translated[&quot;text&quot;] != &quot;&quot;:</span><br><span class="line">       return translated[&quot;text&quot;]</span><br></pre></td></tr></table></figure>

<p>如果是这样，它将返回包含此文本的 Python 字典。然后，它会将此文本传递到函数中 translate_text() ，以将文本翻译成我们选择的语言。</p>
<p>detect_text() 功能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def detect_text(image: vision.Image) -&gt; dict | None:</span><br><span class="line">    &quot;&quot;&quot;Extract the text from the Image object &quot;&quot;&quot;</span><br><span class="line">    text_detection_response = vision_client.text_detection(image=image)</span><br><span class="line">    annotations = text_detection_response.text_annotations</span><br><span class="line"></span><br><span class="line">    if annotations:</span><br><span class="line">        text = annotations[0].description</span><br><span class="line">    else:</span><br><span class="line">        text = &quot;&quot;</span><br><span class="line">    print(f&quot;Extracted text from image:\n&#123;text&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # Returns language identifer in ISO 639-1 format. E.g. en.</span><br><span class="line">    # See https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes</span><br><span class="line">    detect_language_response = translate_client.detect_language(text)</span><br><span class="line">    src_lang = detect_language_response[&quot;language&quot;]</span><br><span class="line">    print(f&quot;Detected language: &#123;src_lang&#125;.&quot;)</span><br><span class="line"></span><br><span class="line">    message = &#123;</span><br><span class="line">        &quot;text&quot;: text,</span><br><span class="line">        &quot;src_lang&quot;: src_lang,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return message</span><br></pre></td></tr></table></figure>

<p>此代码不仅检测图像中的任何文本，还使用 Google 语言 API 来确定文本的语言。</p>
<p>接下来， translate_text() 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def translate_text(message: dict, to_lang: str) -&gt; dict:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Translates the text in the message from the specified source language</span><br><span class="line">    to the requested target language, then sends a message requesting another</span><br><span class="line">    service save the result.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    text = message[&quot;text&quot;]</span><br><span class="line">    src_lang = message[&quot;src_lang&quot;]</span><br><span class="line"></span><br><span class="line">    translated = &#123; # before translating</span><br><span class="line">        &quot;text&quot;: text,</span><br><span class="line">        &quot;src_lang&quot;: src_lang,</span><br><span class="line">        &quot;to_lang&quot;: to_lang,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if src_lang != to_lang and src_lang != &quot;und&quot;:</span><br><span class="line">        print(f&quot;Translating text into &#123;to_lang&#125;.&quot;)</span><br><span class="line">        translated_text = translate_client.translate(</span><br><span class="line">                text, target_language=to_lang, source_language=src_lang)</span><br><span class="line"></span><br><span class="line">        translated = &#123;</span><br><span class="line">            &quot;text&quot;: unescape(translated_text[&quot;translatedText&quot;]),</span><br><span class="line">            &quot;src_lang&quot;: src_lang,</span><br><span class="line">            &quot;to_lang&quot;: to_lang,</span><br><span class="line">        &#125;</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;No translation required.&quot;)</span><br><span class="line"></span><br><span class="line">    return translated</span><br></pre></td></tr></table></figure>

<p>我们检查源语言和目标语言是否不同，并且源语言是否未定义。如果我们通过了此检查，我们将使用 Google 翻译 API 来翻译文本。</p>
<h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>首先，让我们在本地运行该函数。从我们的 backend-gcf 文件夹中运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run the function</span><br><span class="line">functions-framework --target extract_and_translate \</span><br><span class="line">  --debug --port $FUNCTIONS_PORT</span><br></pre></td></tr></table></figure>

<p>它应该看起来像这样：</p>
<p><img src="/../asset_serveless_ai/10.png"></p>
<p>在本地运行我们的函数</p>
<p>我将用这张图片进行测试：</p>
<p><img src="/../asset_serveless_ai/11.png"></p>
<p> 乌克兰语中的模因</p>
<p>从第二个终端，让我们对函数进行 POST 操作，使用 curl ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># You will first need to authenticate and set the environment vars in this terminal</span><br><span class="line">source ./scripts/setup.sh</span><br><span class="line"></span><br><span class="line"># now invoke</span><br><span class="line">curl -X POST localhost:$FUNCTIONS_PORT \</span><br><span class="line">   -H &quot;Content-Type: multipart/form-data&quot; \</span><br><span class="line">   -F &quot;uploaded=@./testing/images/ua_meme.jpg&quot; \</span><br><span class="line">   -F &quot;to_lang=en&quot;</span><br></pre></td></tr></table></figure>

<p> 它有效！！</p>
<p><img src="/../asset_serveless_ai/12.png"></p>
<p>我们申请的回应</p>
<h2 id="部署云功能（到-Google-Cloud）"><a href="#部署云功能（到-Google-Cloud）" class="headerlink" title="部署云功能（到 Google Cloud）"></a>部署云功能（到 Google Cloud）</h2><p>现在我们已经在本地测试了它，我们可以将其部署到 Google Cloud。同样，我们必须从我们的 backend-gcf 文件夹中运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># From the backend-gcf folder</span><br><span class="line">gcloud functions deploy extract-and-translate \</span><br><span class="line">  --gen2 --max-instances 1 \</span><br><span class="line">  --region $REGION \</span><br><span class="line">  --runtime=python312 --source=. \</span><br><span class="line">  --trigger-http --entry-point=extract_and_translate \</span><br><span class="line">  --no-allow-unauthenticated</span><br><span class="line"></span><br><span class="line"># Allow this function to be called by the service account</span><br><span class="line">gcloud functions add-invoker-policy-binding extract-and-translate \</span><br><span class="line">  --region=$REGION \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot;</span><br></pre></td></tr></table></figure>

<p> 部署结果：</p>
<p><img src="/../asset_serveless_ai/13.png"></p>
<p> 部署成功！</p>
<p>这是一件很酷的事情……借助 VS Code 中的 Cloud Code 扩展，我们现在可以看到我们在 Google Cloud 中部署的云功能！</p>
<p><img src="/../asset_serveless_ai/14.png"></p>
<p>在 Google Cloud 中查看我们的云功能，从 VS Code 中的 Cloud Code 查看</p>
<h2 id="测试云函数"><a href="#测试云函数" class="headerlink" title="测试云函数"></a>测试云函数</h2><p>我们只需要一个稍微不同的 curl 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST https://$REGION-$PROJECT_ID.cloudfunctions.net/extract-and-translate \</span><br><span class="line">    -H &quot;Authorization: Bearer $(gcloud auth print-identity-token)&quot; \</span><br><span class="line">    -H &quot;Content-Type: multipart/form-data&quot; \</span><br><span class="line">    -F &quot;uploaded=@./testing/images/ua_meme.jpg&quot; \</span><br><span class="line">    -F &quot;to_lang=en&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../asset_serveless_ai/15.png"></p>
<p> 它有效！</p>
<p>让我们用这个模因测试英语到英语：</p>
<p><img src="/../asset_serveless_ai/16.jpg"></p>
<p> 测试英语反式</p>
<p><img src="/../asset_serveless_ai/17.png"></p>
<p> 提取英语</p>
<p>现在我将尝试翻译成乌克兰语：</p>
<p><img src="/../asset_serveless_ai/18.png"></p>
<p> 翻译成乌克兰语</p>
<p>呜呜！它有效！现在到法语：</p>
<p><img src="/../asset_serveless_ai/19.png"></p>
<p> 翻译成法语</p>
<p>万岁！所有测试似乎都在起作用。</p>
<p>注意：如果您尝试在不传入经过身份验证和授权的凭据的情况下使用该函数，则会看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;403 Forbidden&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body text=#000000 bgcolor=#ffffff&gt;</span><br><span class="line">&lt;h1&gt;Error: Forbidden&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Your client does not have permission to get URL &lt;code&gt;/extract-and-translate&lt;/code&gt; from this server.&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="部署新版本"><a href="#部署新版本" class="headerlink" title="部署新版本"></a>部署新版本</h2><p>如果我们更新代码并想要重新部署，我们可以重新运行相同的 deploy 命令。</p>
<p><img src="/../asset_serveless_ai/20.png"></p>
<p>通过重新部署来更新我们的功能</p>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><p>如果要删除 Cloud Funtion，只需运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud functions delete extract-and-translate --region=$REGION</span><br></pre></td></tr></table></figure>

<h1 id="烧瓶用户界面"><a href="#烧瓶用户界面" class="headerlink" title="烧瓶用户界面"></a>烧瓶用户界面</h1><p>我们将使用 Cloud Run 创建一个简单的 Flask Python Web 应用程序。此应用程序将呈现表单页面，并处理表单。然后，在检索表单响应（包括上传的图像）后，它将调用我们的云函数。</p>
<h2 id="创建-Flask-Web-应用程序"><a href="#创建-Flask-Web-应用程序" class="headerlink" title="创建 Flask Web 应用程序"></a>创建 Flask Web 应用程序</h2><p>本文不打算作为 Flask 教程。因此，我的建议是查看 GitHub 存储库 ui_cr 文件夹中的代码。</p>
<p>但这里有一些关键点：</p>
<ul>
<li>我创建了一个 requirements.txt 来定义此应用程序所需的 Python 包。</li>
<li>我创建了一个 Dockerfile 负责将我们的 Flask 应用程序打包到 Docker 容器中。（稍后我们将需要此功能才能部署到 Cloud Run。为此，它复制 ui_cr 文件夹的内容，安装 Python 依赖项（如 中 requirements.txt 所定义），然后定义应用程序的入口点。即运行 python app.py .</li>
</ul>
<p>我们的 ui_cr 文件夹具有以下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── ui_cr/                - Browser UI (Cloud Run)</span><br><span class="line">    ├── static/             - Static content for frontend</span><br><span class="line">    ├── templates/          - HTML templates for frontend</span><br><span class="line">    ├── app.py              - The Flask application</span><br><span class="line">    ├── requirements.txt    - The UI Python requirements</span><br><span class="line">    ├── Dockerfile             - Dockerfile to build the Flask container</span><br><span class="line">    └── .dockerignore          - Files to ignore in Dockerfile</span><br></pre></td></tr></table></figure>

<h2 id="应用程序代码"><a href="#应用程序代码" class="headerlink" title="应用程序代码"></a>应用程序代码</h2><p>我不打算详细介绍代码。但我会强调一些有趣的观点和陷阱。</p>
<p>让我们来看看 app.py 。首先，实例化 Flask 应用程序的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def create_app():</span><br><span class="line">    &quot;&quot;&quot; Create and configure the app &quot;&quot;&quot;</span><br><span class="line">    flask_app = Flask(__name__, instance_relative_config=True)</span><br><span class="line">    flask_app.config.from_mapping(</span><br><span class="line">        SECRET_KEY=&#x27;dev&#x27;, # override with FLASK_SECRET_KEY env var</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # Load envs starting with FLASK_</span><br><span class="line">    # E.g. FLASK_SECRET_KEY, FLASK_PORT</span><br><span class="line">    flask_app.config.from_prefixed_env()</span><br><span class="line">    client = translate.Client()</span><br><span class="line">    flask_app.languages = &#123;lang[&#x27;language&#x27;]: lang[&#x27;name&#x27;] for lang in client.get_languages()&#125;</span><br><span class="line">    flask_app.backend_func = os.environ.get(&#x27;BACKEND_GCF&#x27;, &#x27;undefined&#x27;)</span><br><span class="line">    return flask_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br></pre></td></tr></table></figure>

<ul>
<li>Flask 应用程序需要密钥才能管理会话。我们可以使用环境变量 FLASK_SECRET_KEY 将密钥传递给应用程序。</li>
<li>我正在使用 Google 翻译 API 检索要翻译的可用语言列表。我将使用它在我的表单中填充下拉选择。</li>
<li>我们需要传递目标函数的 URL。同样，我将为此使用一个环境变量： BACKEND_GCF .</li>
</ul>
<h2 id="处理对-Flask-主页的请求"><a href="#处理对-Flask-主页的请求" class="headerlink" title="处理对 Flask 主页的请求"></a>处理对 Flask 主页的请求</h2><p>在这里，我们处理对 &#x2F; 的请求。当我们的用户第一次访问该页面时，他们将发送一个 GET 请求。但是，当他们提交带有要翻译的图像的表格时，该请求将作为 POST 收到。因此，我们需要同时处理两者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def entry():</span><br><span class="line">    &quot;&quot;&quot; Render the upload form &quot;&quot;&quot;</span><br><span class="line">    message = &quot;Upload your image!&quot;</span><br><span class="line">    to_lang = os.environ.get(&#x27;TO_LANG&#x27;, &#x27;en&#x27;)</span><br><span class="line">    encoded_img = &quot;&quot;</span><br><span class="line">    translation = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;: # Form has been posted</span><br><span class="line">        app.logger.debug(&quot;Got POST&quot;)</span><br><span class="line">        file = request.files.get(&#x27;file&#x27;)</span><br><span class="line">        to_lang = request.form.get(&#x27;to_lang&#x27;)</span><br><span class="line"></span><br><span class="line">        if file is None:</span><br><span class="line">            flash(&#x27;No file part.&#x27;)</span><br><span class="line">        elif file.filename == &#x27;&#x27;:</span><br><span class="line">            flash(&#x27;No file selected for uploading.&#x27;)</span><br><span class="line">        elif not allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            flash(f&#x27;&#123;secure_filename(filename)&#125; is not a supported image format. &#x27;</span><br><span class="line">                  f&#x27;Supported formats are: &#123;ALLOWED_EXTENSIONS&#125;&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            app.logger.debug(&quot;Got %s&quot;, filename)</span><br><span class="line">            app.logger.debug(&quot;Translating to %s&quot;, to_lang)</span><br><span class="line"></span><br><span class="line">            # We don&#x27;t need to save the image. We just want to binary encode it.</span><br><span class="line">            try:</span><br><span class="line">                img = Image.open(file.stream)</span><br><span class="line">                with BytesIO() as buf:</span><br><span class="line">                    if img_format := img.format: # e.g. JPEG, GIF, PNG</span><br><span class="line">                        img.save(buf, img_format.lower())</span><br><span class="line">                        content_type = f&quot;image/&#123;img_format.lower()&#125;&quot;</span><br><span class="line">                        image_bytes = buf.getvalue()</span><br><span class="line">                        encoded_img = base64.b64encode(image_bytes).decode()</span><br><span class="line">                    else:</span><br><span class="line">                        flash(&#x27;Unable to determine image format.&#x27;)</span><br><span class="line">            except UnidentifiedImageError:</span><br><span class="line">                # This will happen if we resubmit the form</span><br><span class="line">                flash(&#x27;Unable to process image.&#x27;)</span><br><span class="line"></span><br><span class="line">            if encoded_img:</span><br><span class="line">                message = f&quot;Processed &lt;&#123;secure_filename(filename)&#125;&gt;. Feel free to upload a new image.&quot;</span><br><span class="line">                func_response = make_authorized_post_request(endpoint=app.backend_func,</span><br><span class="line">                                        image_data=image_bytes, to_lang=to_lang,</span><br><span class="line">                                        filename=filename, content_type=content_type)</span><br><span class="line">                app.logger.debug(&quot;Function response code: %s&quot;, func_response.status_code)</span><br><span class="line">                app.logger.debug(&quot;Function response text: %s&quot;, func_response.text)</span><br><span class="line">                translation = func_response.text</span><br><span class="line"></span><br><span class="line">    return render_template(&#x27;index.html&#x27;,</span><br><span class="line">                           languages=app.languages,</span><br><span class="line">                           message=message,</span><br><span class="line">                           to_lang=to_lang,</span><br><span class="line">                           img_data=encoded_img,</span><br><span class="line">                           translation=translation), 200</span><br></pre></td></tr></table></figure>

<p>我们验证输入，然后 - 如果图像已上传并且是有效的图像 - 我们向云函数发出请求。此请求需要传递上传图像的原始字节。</p>
<p>此外，我希望能够在返回的页面中向用户显示上传的图像。我想避免将上传的图像保存在后端的磁盘上，所以我采取了这种方法：</p>
<ul>
<li>将上传的图像转换为内存中的 BytesIO 对象。</li>
<li>将内存中的对象转换为 JPEG。</li>
<li>在缓冲区中检索图像的原始字节数据。（这也是我将发送到函数的原始 make_authorised_post_request() 数据。</li>
<li>使用 Base64 编码对 JPEG 二进制图像数据进行编码，这是一种可以安全地发送回浏览器的字符串表示形式。</li>
</ul>
<h2 id="对我们的函数进行经过身份验证的调用"><a href="#对我们的函数进行经过身份验证的调用" class="headerlink" title="对我们的函数进行经过身份验证的调用"></a>对我们的函数进行经过身份验证的调用</h2><p>从 Cloud Run Flask 应用程序调用 Cloud Function 时，我们需要在请求标头中包含服务帐户访问令牌。Google 客户端库将自动从 ADC 检索凭据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def make_authorized_post_request(endpoint:str,</span><br><span class="line">                                 image_data, to_lang:str,</span><br><span class="line">                                 filename:str, content_type:str):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Make a POST request to the specified HTTP endpoint by authenticating with the ID token</span><br><span class="line">    obtained from the google-auth client library using the specified audience value.</span><br><span class="line">    Expects the image_data to be a bytes representation of the image.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if endpoint == &quot;undefined&quot;:</span><br><span class="line">        raise ValueError(&quot;Unable to retrieve Function endpoint.&quot;)</span><br><span class="line"></span><br><span class="line">    # Cloud Functions uses your function&#x27;s URL as the `audience` value</span><br><span class="line">    # For Cloud Functions, `endpoint` and `audience` should be equal</span><br><span class="line">    # ADC requires valid service account credentials</span><br><span class="line">    audience = endpoint</span><br><span class="line">    auth_req = GoogleAuthRequest()</span><br><span class="line"></span><br><span class="line">    # Requests OAuth 2.0 access token for the service identity</span><br><span class="line">    # from the instance metadata server or with local ADC. E.g.</span><br><span class="line">    # export GOOGLE_APPLICATION_CREDENTIALS=/path/to/svc_account.json</span><br><span class="line">    id_token = google.oauth2.id_token.fetch_id_token(auth_req, audience)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;Authorization&quot;: f&quot;Bearer &#123;id_token&#125;&quot;,</span><br><span class="line">        # &quot;Content-Type&quot;: &quot;multipart/form-data&quot; # Let requests library decide on the content-type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files = &#123;</span><br><span class="line">        &quot;uploaded&quot;: (filename, image_data, content_type),</span><br><span class="line">        &quot;to_lang&quot;: (None, to_lang)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # Send the HTTP POST request to the Cloud Function</span><br><span class="line">    response = requests.post(endpoint, headers=headers, files=files, timeout=10)</span><br><span class="line"></span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<h2 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h2><p>Flask 使用 Jinja2 模板将内容渲染回浏览器。这些是包含嵌入代码的 HTML 文件。当我们从 中 app.py 调用 render_template() 时，我们会传入一些变量，然后在模板中引用这些变量。</p>
<h2 id="启动和调试"><a href="#启动和调试" class="headerlink" title="启动和调试"></a>启动和调试</h2><p>我们可以通过以下几种方式在本地启动 Flask 应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd app/ui_cr/</span><br><span class="line">source ../../scripts/setup.sh  # Initialise vars if we&#x27;re in a new terminal</span><br><span class="line"></span><br><span class="line"># Run the Flask App</span><br><span class="line">python app.py</span><br><span class="line"></span><br><span class="line"># Or with the Flask command.</span><br><span class="line"># This will automatically load any environment vars starting FLASK_</span><br><span class="line"># The --debug tells Flask to automatically reload after any changes</span><br><span class="line"># and to set the app.logger to debug.</span><br><span class="line">python -m flask --app app run --debug</span><br></pre></td></tr></table></figure>

<p>此外，如果要使用 VS Code 交互式调试器，我建议创建如下所示的启动配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Python Debugger: Flask&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;debugpy&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;module&quot;: &quot;flask&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/app/ui_cr&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;</span><br><span class="line">                &quot;FLASK_APP&quot;: &quot;app.py&quot;,</span><br><span class="line">                &quot;FLASK_DEBUG&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;FLASK_RUN_PORT&quot;: &quot;8080&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;run&quot;,</span><br><span class="line">                &quot;--debug&quot;,</span><br><span class="line">                &quot;--no-debugger&quot;,</span><br><span class="line">                &quot;--no-reload&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;jinja&quot;: true,</span><br><span class="line">            &quot;autoStartBrowser&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        // Other configurations</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试应用程序"><a href="#测试应用程序" class="headerlink" title="测试应用程序"></a>测试应用程序</h2><p>好了，我们就可以运行应用程序了！</p>
<p><img src="/../asset_serveless_ai/21.png"></p>
<p> 启动 Flask 应用程序</p>
<p>以下是它在浏览器中的样子：</p>
<p><img src="/../asset_serveless_ai/22.png"></p>
<p> 运行应用程序</p>
<p>让我们用它来翻译我们的乌克兰模因：</p>
<p><img src="/../asset_serveless_ai/23.png"></p>
<p> 它有效！</p>
<p> 万岁！</p>
<h1 id="部署到-Google-Cloud-Run"><a href="#部署到-Google-Cloud-Run" class="headerlink" title="部署到 Google Cloud Run"></a>部署到 Google Cloud Run</h1><p>现在，我们已准备好将 Flask 应用程序部署到 Cloud Run。回想一下，Cloud Run 是一个无服务器容器运行时，因此我们需要先将应用程序打包为容器映像，然后才能部署它。</p>
<p>我们将运行以下步骤：</p>
<ol>
<li>创建一个 Google Artifact Registry （GAR） 存储库，用于存储我们的 Flask 应用容器映像。</li>
<li>使用 Cloud Build 从源代码构建容器映像并存储在 GAR 中。</li>
<li>将我们的应用程序从 GAR 部署到 Cloud Run。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud artifacts repositories create image-text-translator-artifacts \</span><br><span class="line">  --repository-format=docker \</span><br><span class="line">  --location=$REGION \</span><br><span class="line">  --project=$PROJECT_ID</span><br></pre></td></tr></table></figure>

<p><img src="/../asset_serveless_ai/24.png"></p>
<p> 构建存储库</p>
<p>您可以在 Cloud Console 中检查存储库是否已创建：</p>
<p><img src="/../asset_serveless_ai/25.png"></p>
<p> 工件注册表</p>
<p>现在构建 Docker 映像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export IMAGE_NAME=$REGION-docker.pkg.dev/$PROJECT_ID/image-text-translator-artifacts/image-text-translator-ui</span><br><span class="line"></span><br><span class="line"># configure Docker to use the Google Cloud CLI to authenticate requests to Artifact Registry.</span><br><span class="line">gcloud auth configure-docker $REGION-docker.pkg.dev</span><br><span class="line"></span><br><span class="line"># Build the image and push it to Artifact Registry</span><br><span class="line"># Run from the ui_cr folder</span><br><span class="line">gcloud builds submit --tag $IMAGE_NAME:v0.1 .</span><br></pre></td></tr></table></figure>

<p>这需要一分钟左右的时间。现在，我们的容器映像已被推送到存储库：</p>
<p><img src="/../asset_serveless_ai/26.png"></p>
<p>Google Artifact Registry 中的容器映像</p>
<p>最后，我们可以使用映像部署到 Cloud Run。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># create a random secret key for our Flask application</span><br><span class="line">export RANDOM_SECRET_KEY=$(openssl rand -base64 32)</span><br><span class="line"></span><br><span class="line">gcloud run deploy image-text-translator-ui \</span><br><span class="line">  --image=$IMAGE_NAME:v0.1 \</span><br><span class="line">  --region=$REGION \</span><br><span class="line">  --platform=managed \</span><br><span class="line">  --allow-unauthenticated \</span><br><span class="line">  --max-instances=1 \</span><br><span class="line">  --service-account=$SVC_ACCOUNT \</span><br><span class="line">  --set-env-vars BACKEND_GCF=$BACKEND_GCF,FLASK_SECRET_KEY=$RANDOM_SECRET_KEY</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<p><img src="/../asset_serveless_ai/27.png"></p>
<p> 部署到 Cloud Run</p>
<p>我们可以验证我们的服务是否已部署在 Google Cloud 控制台中：</p>
<p><img src="/../asset_serveless_ai/28.png"></p>
<p> 我们的 Cloud Run 服务</p>
<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>如果我们想部署应用程序的新版本，我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Check our IMAGE_NAME is set</span><br><span class="line">export IMAGE_NAME=$REGION-docker.pkg.dev/$PROJECT_ID/image-text-translator-artifacts/image-text-translator-ui</span><br><span class="line"># Set our new version number</span><br><span class="line">export VERSION=v0.2</span><br><span class="line"></span><br><span class="line"># Rebuild the container image and push to the GAR</span><br><span class="line">gcloud builds submit --tag $IMAGE_NAME:$VERSION .</span><br><span class="line"></span><br><span class="line"># create a random secret key for our Flask application</span><br><span class="line">export RANDOM_SECRET_KEY=$(openssl rand -base64 32)</span><br><span class="line"></span><br><span class="line"># Redeploy</span><br><span class="line">gcloud run deploy image-text-translator-ui \</span><br><span class="line">  --image=$IMAGE_NAME:$VERSION \</span><br><span class="line">  --region=$REGION \</span><br><span class="line">  --platform=managed \</span><br><span class="line">  --allow-unauthenticated \</span><br><span class="line">  --max-instances=1 \</span><br><span class="line">  --service-account=$SVC_ACCOUNT \</span><br><span class="line">  --set-env-vars BACKEND_GCF=$BACKEND_GCF,FLASK_SECRET_KEY=$RANDOM_SECRET_KEY</span><br></pre></td></tr></table></figure>

<h2 id="（可选）设置自定义-DNS-映射"><a href="#（可选）设置自定义-DNS-映射" class="headerlink" title="（可选）设置自定义 DNS 映射"></a>（可选）设置自定义 DNS 映射</h2><p>像 <a target="_blank" rel="noopener" href="https://image-text-translator-ui-adisqviovq-ez.a.run.app/">https://image-text-translator-ui-adisqviovq-ez.a.run.app/</a> 这样的 URL 不是很令人难忘！因此，您可能希望映射到自定义域。您可以在此处找到详细的指南。</p>
<blockquote>
<p>此时，我发现 Cloud Run 不支持该区域 europe-west2 的域映射。因此，我最终使用 europe-west4 .</p>
</blockquote>
<p>假设您已经创建了子域 image-text-translator.mydomain.com ，并且想要将此地址用于应用程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Verify your domain ownership with Google</span><br><span class="line">gcloud domains verify mydomain.com</span><br><span class="line"># Check it</span><br><span class="line">gcloud domains list-user-verified</span><br><span class="line"></span><br><span class="line"># Create a mapping to your domain</span><br><span class="line">gcloud beta run domain-mappings create \</span><br><span class="line">  --region $REGION \</span><br><span class="line">  --service image-text-translator-ui \</span><br><span class="line">  --domain image-text-translator.mydomain.com</span><br></pre></td></tr></table></figure>

<p><img src="/../asset_serveless_ai/29.png"></p>
<p>创建域映射的输出</p>
<p>现在我们需要获取此域映射的 DNS 记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Obtain the DNS records. We want everything under `resourceRecords`.</span><br><span class="line">gcloud beta run domain-mappings describe \</span><br><span class="line">  --region $REGION \</span><br><span class="line">  --domain image-text-translator.mydomain.com</span><br></pre></td></tr></table></figure>

<p>获取 下 resourceRecords 显示的任何 DNS 记录，并在 DNS 注册机构中创建这些 DNS 记录。对我来说，只有一条 CNAME 记录需要添加：</p>
<p><img src="/../asset_serveless_ai/30.png"></p>
<p> 要添加的 DNS 记录</p>
<p>DNS 记录的传播以及 Google 配置托管 SSL 证书可能需要相当长的时间。对我来说，花了将近两个小时。</p>
<p>在等待期间，您可以使用以下工具检查进度：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a></li>
</ul>
<p>但最后……这一切都在我的域中工作！</p>
<p><img src="/../asset_serveless_ai/31.png"></p>
<p>从您的域运行应用</p>
<h1 id="定价和成本管理"><a href="#定价和成本管理" class="headerlink" title="定价和成本管理"></a>定价和成本管理</h1><p>在撰写本文时…</p>
<h2 id="Google-Cloud-函数"><a href="#Google-Cloud-函数" class="headerlink" title="Google Cloud 函数"></a>Google Cloud 函数</h2><p>成本是函数调用、使用的计算和网络出口的总和。</p>
<ul>
<li>每个月的前 100 万次计算秒数是免费的，前 200 万次函数调用也是免费的。</li>
<li>前 400,000 GB 秒和前 200,000 GHz 秒的计算时间是免费的。</li>
<li>此外，由于 Cloud Functions 在不使用时会缩放到 0，因此对于零星或低利用率的工作负载来说，这可能非常经济高效。</li>
</ul>
<h2 id="Google-Cloud-Run（谷歌云运行酒店）"><a href="#Google-Cloud-Run（谷歌云运行酒店）" class="headerlink" title="Google Cloud Run（谷歌云运行酒店）"></a>Google Cloud Run（谷歌云运行酒店）</h2><p>成本是所用 CPU 和内存的组合。</p>
<ul>
<li>前 240000 vCPU 秒每月免费。之后，计算按每 vCPU 秒 0.00001800 USD 收费。</li>
<li>前 450,000 GiB 秒每月免费。之后，内存按 0.000000200 USD&#x2F;GiB 秒收费</li>
<li>由于 Cloud Run 在不使用时会扩展到 0，因此这对于零星或低利用率的工作负载来说可能非常经济高效。</li>
</ul>
<h2 id="Cloud-Vision-API"><a href="#Cloud-Vision-API" class="headerlink" title="Cloud Vision API"></a>Cloud Vision API</h2><p>每个月免费对每个图像进行前 1000 次文本检测。之后，每 1.50 张图像收费 1000 美元。</p>
<h2 id="云翻译-API"><a href="#云翻译-API" class="headerlink" title="云翻译 API"></a>云翻译 API</h2><p>每个月前 050 万个字符免费，用于检测和翻译呼叫。之后，它按每百万个字符 20 美元收费。</p>
<h2 id="一些成本控制策略"><a href="#一些成本控制策略" class="headerlink" title="一些成本控制策略"></a>一些成本控制策略</h2><p>应考虑实施以下成本控制策略：</p>
<ul>
<li>在结算帐号中设置预算提醒。如果超过预算阈值（例如 50%、75%、90%、100%），您将收到电子邮件通知。注意：这不会限制您的支出。它只是在达到阈值时提醒您。</li>
<li>限制自动缩放。虽然 Cloud Run 和 Cloud Functions 都是无服务器自动缩放服务，但我预计我的小应用程序不会有任何重大需求。因此，我将 Cloud Function 和 Cloud Run 服务都设置为 max-instances 1。这意味着每个服务永远不会部署多个并发实例。</li>
<li>更复杂的策略：当超出预算时，向 Pub&#x2F;Sub 发送通知。 使用 Pub&#x2F;Sub 事件触发云函数，然后将项目与计费帐户分离，从而有效地禁用项目中的所有资源。</li>
</ul>
<h1 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h1><p>扩展到 0 的无服务器服务的缺点之一是，如果需求较低且零星，则通常不会有正在运行的服务实例。对于Cloud Functions来说，这并不是一个真正的问题，因为Cloud Functions是超轻量级的，启动速度非常快。但是我们的 Cloud Run Flask 应用程序稍大一些，冷启动可能需要几秒钟。因此，我们的用户在访问页面时会发现应用程序很慢。</p>
<p>有几种策略可以通过 Cloud Run 处理此问题：</p>
<ol>
<li>我们可以将最小实例配置为 1。如果我们这样做，我们的 Cloud Run 服务将永远不会扩展到 0。总会有一个实例准备好处理请求。但是，这意味着我们将为此实例付费……一直以来。这通常是一个很好的策略。但是对于我点头的低利用率应用程序，我真的不想这样做。</li>
<li>我们可以配置 Cloud Run 启动 CPU 提升。在这里，Google Cloud 在启动期间为我们的 Cloud Run 容器动态分配更多 CPU，这可以显着缩短我们的启动时间。而且，由于这些额外的 CPU 仅分配给那些不频繁的冷启动，因此它通常比保持实例一直运行更具成本效益。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcloud beta run services update image-text-translator-ui \</span><br><span class="line">  --region=$REGION --cpu-boost</span><br></pre></td></tr></table></figure>

<p>此外，请检查 Flask 应用程序是否未在启用调试的情况下部署。这肯定会影响您的启动时间！</p>
<h1 id="一些常见问题、一般观察和提示"><a href="#一些常见问题、一般观察和提示" class="headerlink" title="一些常见问题、一般观察和提示"></a>一些常见问题、一般观察和提示</h1><h2 id="生成式人工智能！"><a href="#生成式人工智能！" class="headerlink" title="生成式人工智能！"></a>生成式人工智能！</h2><p>当然，我需要再次提到Gen AI！！虽然我没有在实际解决方案中使用任何 Gen AI，但我在构建解决方案时大量使用它来获得建议和答案。特别是，我与 Gemini Code Assist（包含在 VS Code 的 Cloud Code 插件中）和 ChatGPT 4 进行了多次对话。我估计，使用这些工具解决问题已经消除了我总时间和精力的 40%。</p>
<h2 id="为什么同时使用-Cloud-Run-和-Cloud-Functions？"><a href="#为什么同时使用-Cloud-Run-和-Cloud-Functions？" class="headerlink" title="为什么同时使用 Cloud Run 和 Cloud Functions？"></a>为什么同时使用 Cloud Run 和 Cloud Functions？</h2><p>为什么不只包含从我的 Flask 应用程序提取和翻译 API 调用？这样我就完全不需要 Cloud Functions。</p>
<p> 原因有二：</p>
<ol>
<li>我想将提取和翻译逻辑与 UI 分离。这样一来，如果我想更换 UI 或添加另一个 UI（例如移动应用程序），我仍然可以在不更改它的情况下使用我的 Cloud Function。</li>
<li>我想构建一个需要集成两个无服务器组件的应用程序。这样，我就可以演示一个如何调用另一个，还可以演示其他必要的元素，例如使用服务帐户。</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>大功告成！让我们回顾一下我们取得的成就：</p>
<ul>
<li>我们创建了一个 Google Cloud 项目来托管我们的应用程序。</li>
<li>我们建立了一个本地开发项目和环境。</li>
<li>我们定义了一个服务帐户并为其分配了角色。</li>
<li>我们配置了应用程序默认凭据，以便我们的代码可以在部署到的任何环境中查找凭据。</li>
<li>我们构建了一个 Google Cloud 函数（在 Python 中），用于接收图像数据，从图像中提取任何文本，然后将其翻译成任何指定的语言。我们通过调用 Google 的预制 AI API 来做到这一点。</li>
<li>我们已使用 Functions 框架在本地测试了 Cloud Function。</li>
<li>我们已将云功能部署到 GCP 并对其进行了测试。它只能由经过身份验证和授权的客户端调用。</li>
<li>我们使用 Flask 构建了一个 Python Web 用户界面应用程序。</li>
<li>我们使用 HTML Jinja 模板、CSS 样式表和 Javascript 构建了一个前端。</li>
<li>我们已将 Flask Web 应用程序配置为能够对函数进行经过身份验证的调用。</li>
<li>在本地测试 Flask 应用后，我们使用 Google Cloud Build 将应用打包为容器映像。</li>
<li>我们已将该图像推送到 Google Artifact Registry。</li>
<li>我们已从 Artifact Registry 部署到 Cloud Run。</li>
<li>我们已使用自己的域名公开了我们的 Cloud Run 服务。</li>
<li>我们回顾了一些成本管理最佳实践和控制措施。</li>
<li>我们实施了 cpu-boost 加速 Cloud Run 的冷启动。</li>
</ul>
<p><img src="/../asset_serveless_ai/32.gif"></p>
<p> 唷！</p>
<p>这很有趣！我希望你也喜欢它！</p>
<h1 id="下一步是什么？"><a href="#下一步是什么？" class="headerlink" title="下一步是什么？"></a>下一步是什么？</h1><p>我将跟进第二部分。在第 2 部分中，我将介绍：</p>
<ul>
<li>使用 Terraform 部署我们的 Google Cloud 基础架构。</li>
<li>设置 CI&#x2F;CD 管道，以自动生成和部署更改。</li>
<li>其他一些应用程序增强功能。</li>
</ul>
<h1 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h1><ul>
<li>请与您认为会感兴趣的任何人分享。它可能会帮助他们，它真的帮助了我！</li>
<li>请给我鼓掌！你知道你不止一次鼓掌，对吧？</li>
<li>随意发表评论💬。</li>
<li>关注并订阅，这样您就不会错过我的内容。转到我的个人资料页面，然后单击以下图标：</li>
</ul>
<p><img src="/../asset_serveless_ai/33.png"></p>
<p> 关注并订阅</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><ul>
<li><a target="_blank" rel="noopener" href="https://image-text-translator.just2good.co.uk/">https://image-text-translator.just2good.co.uk/</a></li>
</ul>
<h2 id="应用程序的源代码"><a href="#应用程序的源代码" class="headerlink" title="应用程序的源代码"></a>应用程序的源代码</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/derailed-dash/image-text-translator">GitHub 中的源代码存储库</a></li>
</ul>
<h2 id="开发设置"><a href="#开发设置" class="headerlink" title="开发设置"></a>开发设置</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/sdk/docs/install"> Gcloud CLI 设置</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/python/docs/setup">适用于 Gcloud CLI 的 Python 设置</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode">适用于 VS Code 的云代码</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/python/tutorial-flask">VS Code：示例 Python 烧瓶教程</a></li>
</ul>
<h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><ul>
<li>使用 Python 设置和调用 Cloud Functions，包括本地开发</li>
<li>适用于 Python 的 Functions 框架 — 适用于本地开发</li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/terraform-ml-image-annotation-gcf">Cloud Functions — 图像注释</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/calling/http">Cloud Functions — HTTP 触发器</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/tutorials/ocr">OCR 和 CF 翻译</a></li>
</ul>
<h2 id="云运行"><a href="#云运行" class="headerlink" title="云运行"></a>云运行</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode/create-service">在 VS Code 中从示例应用程序创建 Cloud Run 服务Create a Cloud Run service from a sample application in VS Code</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode/develop-service">在 Cloud Code 中本地开发云运行服务</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode/debug-service">在 VS Code 中调试云运行</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/run/helloworld">Cloud Run — Hello World</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/run/image-processing">Cloud Run — 图像处理</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/run/docs/mapping-custom-domains">将自定义域映射到 Cloud Run 服务</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/run?utm_source=google&utm_medium=cpc&utm_campaign=emea-gb-all-en-dr-skws-all-all-trial-%7Bmatchtype%7D-gcp-1707574&utm_content=text-ad-none-any-DEV_%7Bdevice%7D-CRE_%7Bcreative%7D-ADGP_%7B_dsadgroup%7D-KWID_%7B_dstrackerid%7D-%7Btargetid%7D-userloc_%7Bloc_physical_ms%7D&utm_term=KW_%7Bkeyword%7D-NET_%7Bnetwork%7D-PLAC_%7Bplacement%7D&%7B_dsmrktparam%7D%7Bignore%7D=&%7B_dsmrktparam%7D=&gclsrc=aw.ds&gad_source=1&gclid=CjwKCAjw-O6zBhASEiwAOHeGxWZDg7nObT9R0wHudfnP1YHPkCpAq7PFfcyV7QBKZNQjp6jpgO2g0hoCLzcQAvD_BwE&hl=en#pricing"> Cloud Run 定价</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/blog/products/serverless/announcing-startup-cpu-boost-for-cloud-run--cloud-functions">云运行启动 CPU 提升</a></li>
</ul>
<h2 id="AI-ML-API"><a href="#AI-ML-API" class="headerlink" title="AI&#x2F;ML API"></a>AI&#x2F;ML API</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/vision/docs/ocr">视觉 API — 检测图像中的文本</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/vision/pricing">Google Cloud Vision API 定价</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/translate/docs/basic/translating-text">翻译 API — 翻译文本</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/translate/pricing/?gad_source=1&gclid=CjwKCAjw-O6zBhASEiwAOHeGxdMh6YLV1qcoix8_RgmX5O8Ql2HTmUdPBBX-ckt1bDnothunMt_u4hoCk8kQAvD_BwE&gclsrc=aw.ds">Google Cloud Translation API 定价</a></li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/docs/authentication/application-default-credentials">Appication 默认凭据的工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/docs/authentication/provide-credentials-adc#local-dev">设置应用程序默认凭据</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/blob/main/auth/service-to-service/auth.py">Python 服务到服务身份验证</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/securing/managing-access-iam#gcloud">管理对函数的访问</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/securing/authenticating">Cloud Functions：对调用进行身份验证</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/run/docs/securing/service-identity">Cloud Run：服务标识</a></li>
<li>Cloud Run：对服务到服务进行身份验证 — 创建服务帐户;获取 Google 签名的 ID 令牌，并将该令牌添加到标头。</li>
</ul>
<h2 id="DNS-和-SSL-配置"><a href="#DNS-和-SSL-配置" class="headerlink" title="DNS 和 SSL 配置"></a>DNS 和 SSL 配置</h2><ul>
<li><a target="_blank" rel="noopener" href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://medium.com/google-cloud/building-a-serverless-image-text-extractor-and-translator-using-google-cloud-pre-trained-ai-adfdccdb18d9">使用 Google Cloud 预训练 AI 构建无服务器图像文本提取器和翻译器 |by 达兹博 （Darren Lester） |Google Cloud - 社区 |2024年6月 |中等 — Building a Serverless Image Text Extractor and Translator Using Google Cloud Pre-Trained AI | by Dazbo (Darren Lester) | Google Cloud - Community | Jun, 2024 | Medium</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/06/20/erp-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/20/erp-introduce/" class="post-title-link" itemprop="url">ERP介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-06-20 10:22:06 / 修改时间：10:38:26" itemprop="dateCreated datePublished" datetime="2024-06-20T10:22:06+08:00">2024-06-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在技术驱动的世界中，在线开展业务并对其进行管理是日常业务活动不可或缺的一部分。</p>
<p>ERP（企业资源规划）是帮助企业进行数字化转型、提高利润率、升级服务并提供增强客户体验的解决方案。它不仅有助于自动化工作流程，还简化了业务流程。</p>
<h2 id="什么是ERP？"><a href="#什么是ERP？" class="headerlink" title="什么是ERP？"></a>什么是ERP？</h2><p>ERP 是企业资源规划的缩写，是一种软件应用程序，可帮助管理组织的核心活动，例如供应链流程、财务管理、风险和合规管理等等。它有效地帮助规划、管理、预测和报告组织的整体活动，同时确保整个业务流程的透明度。</p>
<p>ERP系统帮助组织的不同部门进行无缝协作和沟通，确保成本效益和生产力。</p>
<p>ERP系统主要有三种类型，即：本地ERP，基于云的ERP和混合ERP系统。</p>
<h2 id="ERP系统的组件"><a href="#ERP系统的组件" class="headerlink" title="ERP系统的组件"></a>ERP系统的组件</h2><p>ERP系统有五个关键组成部分，它们如下：</p>
<p><img src="/../asset_erpintroduce/01.png"></p>
<ul>
<li>客户关系管理（CRM）</li>
<li>金融</li>
<li>人力资源管理（HRM）</li>
<li>制造和物流</li>
<li>供应链管理 （SCM）</li>
</ul>
<h3 id="客户关系管理（CRM）"><a href="#客户关系管理（CRM）" class="headerlink" title="客户关系管理（CRM）"></a>客户关系管理（CRM）</h3><p>该系统使用客户的个人信息、购买历史、使用模式等相关数据与客户互动，以提供个性化的服务和建议，从而增加销售额并提高客户满意度。</p>
<h3 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h3><p>它是每个组织的核心流程和基础之一，ERP 解决方案有助于轻松监控和管理您的所有财务活动，如应收账款和应付账款、经常性成本、预算、总账等。<br>它有助于优化现金流、减少损失和提高业务的盈利能力，从而使您能够简化复杂的会计流程。</p>
<h3 id="人力资源管理（HRM）"><a href="#人力资源管理（HRM）" class="headerlink" title="人力资源管理（HRM）"></a>人力资源管理（HRM）</h3><p>它是一个重要的ERP模块，有助于有效管理人力资源，其中包括组织从下到上层次结构中的每个员工。<br>它有助于处理所有与员工相关的任务，例如考勤管理、工资单管理、绩效报告、员工详细信息等等。</p>
<h3 id="制造和物流"><a href="#制造和物流" class="headerlink" title="制造和物流"></a>制造和物流</h3><p>它是开源 ERP 系统中最重要和最复杂的组件之一，它使您能够战略性地计划、生产&#x2F;包装、运输和交付产品给客户，从而确保无缝的订单履行流程。<br>它使您能够清楚地了解组织每项活动的实时进度，同时在指尖有效地管理它们。</p>
<h3 id="供应链管理-（SCM）"><a href="#供应链管理-（SCM）" class="headerlink" title="供应链管理 （SCM）"></a>供应链管理 （SCM）</h3><p>这是ERP系统的另一个重要组成部分，它通过确保每个必需的资源都可用来促进货物的无缝生产。它通过收集实时信息来帮助优化制造和分销过程，从而提高您的服务效率。</p>
<p>ERP系统还有其他附加模块，包括库存管理、电子商务、营销自动化、仓库管理、订单管理、项目管理、采购等，有助于自动化工作流程并简化所有业务流程。</p>
<h2 id="ERP对企业有什么好处"><a href="#ERP对企业有什么好处" class="headerlink" title="ERP对企业有什么好处"></a>ERP对企业有什么好处</h2><p>ERP系统可帮助您优化业务运营和活动，并满足其他一些好处，其中包括以下内容：</p>
<p><img src="/../asset_erpintroduce/02.png"></p>
<ul>
<li>准确的报告和分析</li>
<li>集中式数据</li>
<li>节省成本</li>
<li>数据安全与合规</li>
<li>提高生产力</li>
<li>可扩展性和灵活性</li>
</ul>
<h3 id="准确的报告和分析-–"><a href="#准确的报告和分析-–" class="headerlink" title="准确的报告和分析 –"></a>准确的报告和分析 –</h3><p>ERP 的第一个也是最重要的好处是，它可以帮助您根据您的业务需求和要求、客户的购买模式、搜索趋势和其他几个方面提供详细的报告，您可以分析这些方面为您的客户提供优质的服务以及最大的客户满意度，同时使您能够在需要时改进您的服务。</p>
<h3 id="集中式数据-–"><a href="#集中式数据-–" class="headerlink" title="集中式数据 –"></a>集中式数据 –</h3><p>ERP使您能够在一个集中的位置管理所有业务数据，这意味着您可以随时随地访问它。它可以帮助您了解最新的市场趋势和消费者偏好，从而进一步增强您企业的决策过程。</p>
<h3 id="节省成本-–"><a href="#节省成本-–" class="headerlink" title="节省成本 –"></a>节省成本 –</h3><p>ERP解决方案的另一个重要好处是，它有助于自动化整个业务流程和工作流程，从而消除手动和重复性任务，这反过来又有助于节省相关成本，同时最大限度地减少错误，并使您的业务服务更加省时和具有成本效益。</p>
<h3 id="数据安全与合规-–"><a href="#数据安全与合规-–" class="headerlink" title="数据安全与合规 –"></a>数据安全与合规 –</h3><p>它还通过实施多层安全协议、防火墙、身份验证方法和其他安全措施，帮助保护敏感信息免受可能的网络攻击，从而确保安全的工作流程和业务流程。</p>
<p>此外，它还有助于遵守财务标准和法规以及其他必要的法规遵从性。</p>
<h3 id="提高生产力-–"><a href="#提高生产力-–" class="headerlink" title="提高生产力 –"></a>提高生产力 –</h3><p>它还有助于通过简化一个屋檐下的协作和通信环境来提高团队的生产力。它确保了团队成员之间的透明度，并实现了工作流程的自动化，从而减少了繁琐的手动工作，同时减少了错误或没有错误，从而确保了高质量的工作和服务。</p>
<h3 id="可扩展性和灵活性-–"><a href="#可扩展性和灵活性-–" class="headerlink" title="可扩展性和灵活性 –"></a>可扩展性和灵活性 –</h3><p>ERP还提供灵活性，这意味着您可以根据自己的要求构建自定义工作流程，并支持您独特的业务流程和服务。它还随着业务的增长进行相应的调整，使您的业务具有可扩展性，从而适应不断增长的用户群和业务需求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/06/04/ai-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/04/ai-integration/" class="post-title-link" itemprop="url">如何在应用程序中集成AI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-04 20:26:26" itemprop="dateCreated datePublished" datetime="2024-06-04T20:26:26+08:00">2024-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-05 16:30:38" itemprop="dateModified" datetime="2024-06-05T16:30:38+08:00">2024-06-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于许多企业拥有运行多年的大型复杂系统，对它们进行重大更改是有风险且昂贵的。</p>
<p>本文讨论如何将人工智能添加到现有的应用程序中，即使这些应用程序很难或不可能更改。我们将探讨实现这一目标的实际方法。</p>
<h2 id="业务用例"><a href="#业务用例" class="headerlink" title="业务用例"></a>业务用例</h2><p>我们模拟一个供应链管理公司，它有多个部门，每个部门都暴露自己的 REST API，要得到一个查询的答案，必须通过这些部门的 API 和数据库调用。我们将引入人工智能，但保持所有现有流程不变。</p>
<p><img src="/../asset_aiintegration/01.png"></p>
<p>该公司的中央部门是“Data Processing System”，负责数据管理和处理的核心操作。它通过不同的接口与其他各部门进行交互。 “Client Call”组件代表客户请求或查询进入系统的入口点。然后将这些请求传递给“Data Processing System”进行处理。该“Data Processing System”系统还与“Central Data Management”组件通信，后者作为管理和存储与供应链操作相关数据的集中存储库。</p>
<p>“Company Data Handling System”是另一个关键部门，包括一个“Data Retrieval Server”。该服务器存储和管理公司的内部数据，其中包括有关库存、订单、物流和其他运营细节的信息。 “AI Integration System” 组件专门设计用于将人工智能功能集成到现有系统中。它与“Company Data Handling System”互动，并间接访问“Central Data Management”组件，使其能够利用来自多个来源的数据进行基于 AI 的决策或自动化。</p>
<p>“Mapping System” 部门连接到包含有地理数据、路由信息以及与供应链映射和物流相关的其他细节的“Supply Chain Mapping DB”（数据库）。“System Admin Dashboard”允许授权员工登录并访问管理功能或监控系统性能。该仪表板与“AI Integration System”互动，以提供洞见、报告或对 AI 功能进行控制。</p>
<p>最后，“REST API call”组件公开了一个 RESTful API，允许外部系统或应用与其交互，并可能利用其功能或数据。</p>
<h2 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/szhowardhuang/ai_integration</span><br><span class="line"><span class="built_in">cd</span> ai_integration</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="客户端界面-dashboard-py"><a href="#客户端界面-dashboard-py" class="headerlink" title="客户端界面 dashboard.py"></a>客户端界面 dashboard.py</h2><h3 id="LLM客户端"><a href="#LLM客户端" class="headerlink" title="LLM客户端"></a>LLM客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client = Groq(api_key=os.getenv(<span class="string">&#x27;GROQ_API_KEY&#x27;</span>))</span><br><span class="line">MODEL = <span class="string">&#x27;mixtral-8x7b-32768&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>申请Groq的API，并配置好LLM模型 mixtral</li>
</ul>
<h3 id="定义-get-supply-chain-data-函数"><a href="#定义-get-supply-chain-data-函数" class="headerlink" title="定义 get_supply_chain_data 函数"></a>定义 get_supply_chain_data 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_supply_chain_data</span>(<span class="params">query</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the supply chain data for a given query by calling the Flask API.&quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">f&#x27;http://127.0.0.1:5000/supply-chain-data?query=<span class="subst">&#123;query&#125;</span>&#x27;</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> json.dumps(response.json())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> json.dumps(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;API request failed&quot;</span>, <span class="string">&quot;status_code&quot;</span>: response.status_code&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此函数通过向 Flask API 端点发出 HTTP GET 请求来检索供应链数据。</p>
</li>
<li><p>它需要一个 query 参数，该参数代表与供应链活动相关的查询。</p>
</li>
<li><p>URL 是使用提供的查询参数构建的。</p>
</li>
<li><p>该函数检查响应状态码。如果是 200（OK），则返回响应的 JSON 表示。否则，返回一个包含错误消息和状态码的 JSON 对象。</p>
</li>
</ul>
<h3 id="定义-run-conversation-函数"><a href="#定义-run-conversation-函数" class="headerlink" title="定义 run_conversation 函数"></a>定义 run_conversation 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_conversation</span>(<span class="params">user_prompt</span>):</span><br><span class="line">    messages = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a function calling LLM that uses the data extracted from the get_supply_chain_data function to answer questions related to supply chain management. Include the relevant supply chain activity and data in your response.&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: user_prompt,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    tools = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_supply_chain_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Get the supply chain data for a given query&quot;</span>,</span><br><span class="line">                <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The query related to a supply chain activity&quot;</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;query&quot;</span>],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此函数管理用户和 AI 模型之间的对话。</p>
</li>
<li><p>它准备好消息，包括系统消息和用户消息，其中包含它们的提示词。</p>
</li>
<li><p>它准备了 AI 模型在对话过程中可以使用的工具。包括一个名为“get_supply_chain_data”的函数，以及它的描述和参数。</p>
</li>
</ul>
<h3 id="Gradio-界面设置"><a href="#Gradio-界面设置" class="headerlink" title="Gradio 界面设置"></a>Gradio 界面设置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">background_path = os.path.join(os.getcwd(), <span class="string">&#x27;images&#x27;</span>, <span class="string">&#x27;background.png&#x27;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> gr.Blocks(css=<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...CSS Styling...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) <span class="keyword">as</span> demo:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此部分为用户交互设置了 Gradio 界面。</p>
</li>
<li><p>它构建了界面中背景图像的路径。</p>
</li>
<li><p>界面布局和样式是在 gr.Blocks 上下文管理器中使用 CSS 定义的。</p>
</li>
</ul>
<h3 id="Gradio-界面组件"><a href="#Gradio-界面组件" class="headerlink" title="Gradio 界面组件"></a>Gradio 界面组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gr.Markdown(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;header&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Supply Chain Management Company&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Your AI-powered supply chain management&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">gr.Markdown(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;<span class="subst">&#123;background_path&#125;</span>&quot; class=&quot;background-image&quot;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> gr.Row():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了 Gradio 界面的组件，包括一个带有标题和描述的标题栏，以及一张图片。</p>
</li>
<li><p>标题提供有关供应链管理系统的信息。</p>
</li>
<li><p>图像作为界面的背景。</p>
</li>
</ul>
<h3 id="设置用户输入和输出组件"><a href="#设置用户输入和输出组件" class="headerlink" title="设置用户输入和输出组件"></a>设置用户输入和输出组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> gr.Row():</span><br><span class="line">    <span class="keyword">with</span> gr.Column(scale=<span class="number">1</span>):</span><br><span class="line">        user_input = gr.Textbox(</span><br><span class="line">            label=<span class="string">&quot;Enter your query&quot;</span>,</span><br><span class="line">            placeholder=<span class="string">&quot;Ask a question about supply chain management...&quot;</span>,</span><br><span class="line">            lines=<span class="number">3</span>,</span><br><span class="line">            elem_id=<span class="string">&quot;user-input&quot;</span></span><br><span class="line">        )</span><br><span class="line">        submit_button = gr.Button(<span class="string">&quot;Submit&quot;</span>, variant=<span class="string">&quot;primary&quot;</span>, elem_classes=<span class="string">&quot;submit-button&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> gr.Column(scale=<span class="number">2</span>):</span><br><span class="line">        output_text = gr.Textbox(</span><br><span class="line">            label=<span class="string">&quot;Response&quot;</span>,</span><br><span class="line">            lines=<span class="number">10</span>,</span><br><span class="line">            elem_id=<span class="string">&quot;output-text&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此部分在行列布局中设置了用户输入（文本框和提交按钮）和输出（文本框）的组件。</p>
</li>
<li><p>用户可以在文本框中输入与供应链管理相关的查询。</p>
</li>
<li><p>提交查询后，AI 模型的响应将显示在输出文本框中。</p>
</li>
</ul>
<h3 id="更新供应链统计数据"><a href="#更新供应链统计数据" class="headerlink" title="更新供应链统计数据"></a>更新供应链统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stats_text = gr.Text(value=<span class="string">&quot;Loading...&quot;</span>, label=<span class="string">&quot;Supply Chain Stats&quot;</span>, interactive=<span class="literal">False</span>, elem_classes=<span class="string">&quot;stats&quot;</span>)</span><br><span class="line"></span><br><span class="line">submit_button.click(</span><br><span class="line">    gradio_interface,</span><br><span class="line">    inputs=user_input,</span><br><span class="line">    outputs=output_text,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">threading.Thread(target=update_stats_text, daemon=<span class="literal">True</span>).start()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此部分初始化文本组件以显示供应链统计数据。</p>
</li>
<li><p>它为提交按钮设置了一个点击事件处理程序。当按钮被点击时，使用者输入调用 gradio_interface 函数，并在输出文本框中显示输出。</p>
</li>
<li><p>此外，它启动一个单独的线程，持续更新显示在界面上的供应链统计数据。</p>
</li>
</ul>
<h3 id="启动-Gradio-界面"><a href="#启动-Gradio-界面" class="headerlink" title="启动 Gradio 界面"></a>启动 Gradio 界面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.launch()</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，这一行启动了 Gradio 界面，使用户能够与 AI 驱动的供应链管理系统进行交互。</li>
</ul>
<h2 id="公司数据处理系统-data-retriever-py"><a href="#公司数据处理系统-data-retriever-py" class="headerlink" title="公司数据处理系统 data_retriever.py"></a>公司数据处理系统 data_retriever.py</h2><h3 id="导入库并设置日志"><a href="#导入库并设置日志" class="headerlink" title="导入库并设置日志"></a>导入库并设置日志</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> WordNetLemmatizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">nltk.download(<span class="string">&#x27;punkt&#x27;</span>)</span><br><span class="line">nltk.download(<span class="string">&#x27;stopwords&#x27;</span>)</span><br><span class="line">nltk.download(<span class="string">&#x27;wordnet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化词形还原器</span></span><br><span class="line">lemmatizer = WordNetLemmatizer()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>导入了必要的库，如 json ， os ， logging 和 requests 。</p>
</li>
<li><p>设置日志以跟踪程序执行过程中的信息、警告和错误。</p>
</li>
<li><p>载入NLP模型，并初始化词形还原器</p>
</li>
</ul>
<h3 id="定义-SupplyChainDataRetriever-类"><a href="#定义-SupplyChainDataRetriever-类" class="headerlink" title="定义 SupplyChainDataRetriever 类"></a>定义 SupplyChainDataRetriever 类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SupplyChainDataRetriever</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, database_folder, mapping_api_url=<span class="string">&#x27;http://localhost:5001/mapping&#x27;</span></span>):</span><br><span class="line">        self.database_folder = database_folder</span><br><span class="line">        self.query_mapping = self.fetch_query_mapping(mapping_api_url)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了一个名为 SupplyChainDataRetriever 的类，用于根据用户查询来检索供应链数据。</p>
</li>
<li><p>该类使用 database_folder 路径和可选的 mapping_api_url 进行查询映射初始化。</p>
</li>
</ul>
<h3 id="获取查询映射"><a href="#获取查询映射" class="headerlink" title="获取查询映射"></a>获取查询映射</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_query_mapping</span>(<span class="params">self, mapping_api_url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(mapping_api_url)</span><br><span class="line">        response.raise_for_status()</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error fetching query_mapping: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    logger.info(<span class="string">f&quot;SupplyChainDataRetriever instance created with database folder: <span class="subst">&#123;database_folder&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法从指定的 API 端点获取查询映射。</p>
</li>
<li><p>它向 mapping_api_url 发送 HTTP GET 请求并处理任何异常。</p>
</li>
<li><p>如果成功，它将返回包含查询映射的 JSON 响应。</p>
</li>
</ul>
<h3 id="检索供应链数据"><a href="#检索供应链数据" class="headerlink" title="检索供应链数据"></a>检索供应链数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_supply_chain_data</span>(<span class="params">self, query</span>):</span><br><span class="line">    query = query.lower()</span><br><span class="line">    logger.info(<span class="string">f&quot;Received query: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> activity, filename <span class="keyword">in</span> self.query_mapping.items():</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法根据用户的查询检索供应链数据。</p>
</li>
<li><p>它首先将查询转换为小写，以进行不区分大小写的匹配，并记录接收到的查询。</p>
</li>
<li><p>然后，它通过查询映射字典进行迭代，以找到查询和已知供应链活动之间的匹配。</p>
</li>
</ul>
<h3 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_text</span>(<span class="params">text</span>):</span><br><span class="line">    tokens  = re.split(<span class="string">r&#x27;[\s_]+&#x27;</span>, text)</span><br><span class="line">    <span class="comment"># 转为小写</span></span><br><span class="line">    tokens = [token.lower() <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</span><br><span class="line">    <span class="comment"># 去除停用词和词形还原</span></span><br><span class="line">    tokens = [lemmatizer.lemmatize(word) <span class="keyword">for</span> word <span class="keyword">in</span> tokens <span class="keyword">if</span> word.isalpha() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> stopwords.words(<span class="string">&#x27;english&#x27;</span>)]</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br></pre></td></tr></table></figure>

<ul>
<li>preprocess_text根据空格和下划线来分词，并进行词形还原</li>
</ul>
<h3 id="将查询与活动匹配"><a href="#将查询与活动匹配" class="headerlink" title="将查询与活动匹配"></a>将查询与活动匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本预处理</span></span><br><span class="line">activity_words = preprocess_text(activity)</span><br><span class="line">query_words = preprocess_text(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征提取：使用TF-IDF</span></span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">tfidf_matrix = vectorizer.fit_transform([<span class="string">&#x27; &#x27;</span>.join(activity_words), <span class="string">&#x27; &#x27;</span>.join(query_words)])</span><br><span class="line"><span class="comment"># 计算余弦相似度</span></span><br><span class="line">similarity_score = cosine_similarity(tfidf_matrix[<span class="number">0</span>:<span class="number">1</span>], tfidf_matrix[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Text Similarity Score: <span class="subst">&#123;similarity_score[<span class="number">0</span>][<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> similarity_score[<span class="number">0</span>][<span class="number">0</span>] &gt;= <span class="number">0.3</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这里，将活动和查询预处理，分成一组词。</p>
</li>
<li><p>使用余弦相似度比较活动和查询之间的相似度</p>
</li>
</ul>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_path = os.path.join(self.database_folder, filename)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        data = json.load(file)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    logger.error(<span class="string">f&quot;File not found: <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果找到匹配查询的活动，根据 database_folder 和文件名构建文件路径。</p>
</li>
<li><p>检查文件是否存在，如果存在，从文件中读取 JSON 数据并返回。</p>
</li>
<li><p>如果文件不存在，会记录一个错误消息。</p>
</li>
</ul>
<h3 id="处理没有匹配活动"><a href="#处理没有匹配活动" class="headerlink" title="处理没有匹配活动"></a>处理没有匹配活动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error_message = &#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;No data found for the given query&quot;</span>&#125;</span><br><span class="line">logger.warning(<span class="string">f&quot;No data found for query: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> error_message</span><br></pre></td></tr></table></figure>

<ul>
<li>如果未找到与查询匹配的活动，会记录一个警告并返回一个错误消息。</li>
</ul>
<h2 id="数据处理系统-server-py"><a href="#数据处理系统-server-py" class="headerlink" title="数据处理系统 server.py"></a>数据处理系统 server.py</h2><h3 id="导入库并设置日志记录"><a href="#导入库并设置日志记录" class="headerlink" title="导入库并设置日志记录"></a>导入库并设置日志记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> data_retriever <span class="keyword">import</span> SupplyChainDataRetriever</span><br><span class="line"><span class="keyword">import</span> logging</span><br></pre></td></tr></table></figure>

<ul>
<li>导入了必要的库，比如 Flask 用于创建 Web 应用程序，logging 用于在程序执行过程中跟踪信息、警告和错误。</li>
</ul>
<h3 id="初始化-Flask-应用程序和数据检索器"><a href="#初始化-Flask-应用程序和数据检索器" class="headerlink" title="初始化 Flask 应用程序和数据检索器"></a>初始化 Flask 应用程序和数据检索器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">data_retriever = SupplyChainDataRetriever(<span class="string">&#x27;database&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建了一个名为 app 的 Flask 应用实例。</p>
</li>
<li><p>实例化了一个名为 data_retriever 的 SupplyChainDataRetriever 对象，用于根据用户查询来检索供应链数据。传递了名为 ‘database’ 的文件夹，其中存储着包含数据的 JSON 文件。</p>
</li>
</ul>
<h3 id="用于供应链数据检索的-Flask-路由"><a href="#用于供应链数据检索的-Flask-路由" class="headerlink" title="用于供应链数据检索的 Flask 路由"></a>用于供应链数据检索的 Flask 路由</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/supply-chain-data&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">supply_chain</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Flask route to handle supply chain data retrieval requests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Query Parameters:</span></span><br><span class="line"><span class="string">        query (str): The user&#x27;s query related to a supply chain activity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        JSON response: The corresponding supply chain data or an error message.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    query = request.args.get(<span class="string">&#x27;query&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> query:</span><br><span class="line">        logger.error(<span class="string">&quot;Missing query parameter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;Missing query&#x27;</span>&#125;), <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Received query: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line">    data = data_retriever.get_supply_chain_data(query)</span><br><span class="line">    logger.info(<span class="string">f&quot;Returning data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了一个 Flask 路由 &#x2F;supply-chain-data 来处理作为 HTTP GET 请求发送的供应链数据检索请求。</p>
</li>
<li><p>路由声明一个名为 ‘query’ 的查询参数，该参数代表与供应链活动相关的用户查询。</p>
</li>
<li><p>如果缺少查询参数，会记录一个错误并返回一个带有错误消息和状态码 400（错误请求）的 JSON 响应。</p>
</li>
<li><p>记录接收到的查询，使用 data_retriever 对象检索相应的供应链数据，并用 JSON 响应来返回之前的记录数据。</p>
</li>
</ul>
<h3 id="启动-Flask-应用程序"><a href="#启动-Flask-应用程序" class="headerlink" title="启动 Flask 应用程序"></a>启动 Flask 应用程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logger.info(<span class="string">&quot;Starting Flask application&quot;</span>)</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果脚本直接执行（而不是作为模块导入），启动 Flask 应用程序。</p>
</li>
<li><p>记录了一条消息，表明 Flask 应用程序正在启动。</p>
</li>
<li><p>启动 Flask 开发服务器，并启用了调试模式，以便在开发过程中进行简单调试。</p>
</li>
</ul>
<p>以这种方式构建代码，使用 Flask 创建了一个网络服务，为用户查询提供基于供应链数据的 API 端点。日志配置确保为调试和监控目的记录相关信息。</p>
<h2 id="映射系统-mapping-server-py"><a href="#映射系统-mapping-server-py" class="headerlink" title="映射系统 mapping_server.py"></a>映射系统 mapping_server.py</h2><h3 id="定义-MappingAPI-类"><a href="#定义-MappingAPI-类" class="headerlink" title="定义 MappingAPI 类"></a>定义 MappingAPI 类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingAPI</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mapping_file_path=<span class="literal">None</span></span>):</span><br><span class="line">        self.app = Flask(__name__)</span><br><span class="line">        self.app.add_url_rule(<span class="string">&#x27;/mapping&#x27;</span>, <span class="string">&#x27;mapping&#x27;</span>, self.get_mapping, methods=[<span class="string">&#x27;GET&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mapping_file_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            mapping_file_path = os.path.join(<span class="string">&#x27;center_dept_database&#x27;</span>, <span class="string">&#x27;mapping.json&#x27;</span>)</span><br><span class="line">        self.mapping_file_path = mapping_file_path</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了一个名为 MappingAPI 的类，用于创建一个基于 Flask 的 API，用于提供中心和部门之间的 JSON 映射。</p>
</li>
<li><p>在构造函数（ <strong>init</strong> ）中，实例化了一个 Flask 应用程序（ app ），并为 &#x2F;mapping 端点添加了一个 URL 规则，通过 HTTP GET 访问时将调用 get_mapping 方法。</p>
</li>
<li><p>将映射文件的默认路径设置为 ‘center_dept_database&#x2F;mapping.json’ ，但在初始化 MappingAPI 对象时，可以通过提供不同的路径来覆盖它。</p>
</li>
</ul>
<h3 id="检索映射数据"><a href="#检索映射数据" class="headerlink" title="检索映射数据"></a>检索映射数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_mapping</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(self.mapping_file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        mapping_data = json.load(file)</span><br><span class="line">    <span class="keyword">return</span> jsonify(mapping_data)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此方法从由 mapping_file_path 指定的 JSON 文件中检索映射数据。</p>
</li>
<li><p>它打开文件，读取其内容，并将 JSON 数据加载到 Python 字典中（ mapping_data ）。</p>
</li>
<li><p>然后，使用 Flask 的 jsonify 函数将映射数据作为 JSON 响应返回。</p>
</li>
</ul>
<h3 id="启动-Flask-应用程序-1"><a href="#启动-Flask-应用程序-1" class="headerlink" title="启动 Flask 应用程序"></a>启动 Flask 应用程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5001</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Starting MappingAPI on <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line">    self.app.run(host=host, port=port, debug=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mapping_api = MappingAPI()</span><br><span class="line">    mapping_api.run()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>run 方法启动 Flask 开发服务器。</p>
</li>
<li><p>它需要可选参数 host 和 port 来指定服务器的主机名和端口号。默认情况下，它在端口 5001 上监听所有接口（ ‘0.0.0.0’ ）。</p>
</li>
<li><p>当脚本直接执行（ if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘: ）时，它会创建一个 MappingAPI 的实例，并使用 run 方法运行 Flask 应用程序。</p>
</li>
<li><p>此外，它打印一条消息，指示 API 服务器的启动。</p>
</li>
</ul>
<p>这段代码，用于创建一个简单的基于 Flask 的 API，用于提供中心和部门之间的 JSON 映射。该 API 提供了一个用于检索映射数据的单个端点，使其易于部署和配置到各种应用程序中。</p>
<h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#start mapping server</span></span><br><span class="line">python mapping_server.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#start backend server</span></span><br><span class="line">python server.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">http://127.0.0.1:5000/supply-chain-data?query=order_tracking</span><br><span class="line"></span><br><span class="line">python dashboard.py</span><br></pre></td></tr></table></figure>

<p>打开浏览器，查看 <a target="_blank" rel="noopener" href="http://127.0.0.1:5000/supply-chain-data?query=order_tracking">http://127.0.0.1:5000/supply-chain-data?query=order_tracking</a> ， 成功的话，可以看到json字串。</p>
<p>打开浏览器，查看 <a target="_blank" rel="noopener" href="http://127.0.0.1:7860/">http://127.0.0.1:7860</a> ， 页面如下：</p>
<p><img src="/../asset_aiintegration/02.png"></p>
<p>询问一下当前的库存 what is our current inventory?</p>
<p><img src="/../asset_aiintegration/03.gif"></p>
<p>询问一下货物的具体状态 i need shipment details for delivered status</p>
<p><img src="/../asset_aiintegration/04.gif"></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本文中我们探讨的供应链管理项目的例子，展示了如何将人工智能能力无缝集成到现有业务系统中，而无需进行重大改造。通过利用现代人工智能技术的灵活性和强大功能，我们能够增强供应链管理系统的功能，同时保留其核心运营和工作流程。</p>
<p>在整个开发过程中，我们非常强调减少对现有系统架构的影响。我们并没有试图替换或修改已建立的组件，而是引入了一个“AI 集成系统”，它充当现有基础设施和 AI 功能之间的桥梁。这种方法使我们能够保持现有系统的完整性，同时利用 AI 的好处。</p>
<p>这种整合策略的关键优势之一是能够利用现有系统中已有的大量数据。通过访问和处理这些数据，我们能够通过人工智能模型生成智能的用户查询响应，为特定供应链活动和情景提供有价值的见解和建议。</p>
<p>展望未来，将人工智能无缝集成到现有业务生态系统中的重要性只会继续增长。随着技术进步和对智能自动化和决策支持需求的增加，采用这种方法的组织将更好地把握人工智能带来的机遇，同时最大限度地减少对其运营的干扰。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://ai.gopubby.com/master-ai-integration-how-to-integrate-ai-in-your-application-6b936376df61">https://ai.gopubby.com/master-ai-integration-how-to-integrate-ai-in-your-application-6b936376df61</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Howard Huang</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">494k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:59</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动-->
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.js" integrity="sha256-+2+qOqR8CKoHh/AsVR9k2qaDBKWjYNC2nozhYmv5j9k=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
