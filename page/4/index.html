<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szhowardhuang.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="嵌入式老兵博客">
<meta property="og:url" content="https://szhowardhuang.github.io/page/4/index.html">
<meta property="og:site_name" content="嵌入式老兵博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Howard Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://szhowardhuang.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>嵌入式老兵博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">嵌入式老兵博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Howard Huang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/08/AIOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/08/AIOS/" class="post-title-link" itemprop="url">LLM代理操作系统 （AIOS）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-07-08 09:25:04 / 修改时间：10:31:31" itemprop="dateCreated datePublished" datetime="2024-07-08T09:25:04+08:00">2024-07-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一种称为AIOS（LLM代理操作系统）的新方法旨在改变基于大型语言模型的代理的开发和部署。通过集成到LLMs操作系统中，AIOS 创建了一个功能类似于大脑的操作系统，标志着向通用人工智能 （AGI） 迈出了一步。</p>
<p><strong>AIOS的主要特点和优势：</strong></p>
<ol>
<li>资源分配优化：AIOS改善了资源分配，确保了LLM代理请求的高效利用。</li>
<li>无缝上下文切换：它简化了在代理之间切换上下文的过程，实现了平稳过渡并保持连续性。</li>
<li>并发代理执行：AIOS 允许多个代理同时运行，从而提高整体系统性能和响应能力。</li>
<li>全面的代理工具集：它为代理提供了广泛的工具供代理使用，从而为他们提供了扩展的功能。</li>
<li>强大的访问控制：AIOS实施严格的访问控制措施，对代理权限进行管理，维护系统安全。</li>
</ol>
<p><img src="/../asset_aios/01.png" alt="Example of how an agent (i.e., Travel Agent) requires both LLM level and OS"></p>
<p>代理（即旅行代理）如何需要LLM级别和操作系统级别的资源和功能来完成任务的示例</p>
<h2 id="LLM内核"><a href="#LLM内核" class="headerlink" title="LLM内核"></a>LLM内核</h2><p>AIOS的核心是LLM内核，这是一个专门的组件，旨在通过一套专用模块管理LLM相关的活动：</p>
<ul>
<li>代理调度器：该模块优化了代理请求的调度，确保了LLM资源的高效利用。通过对请求队列进行优先级排序和管理，Agent Scheduler 可以最大限度地提高吞吐量并最小化延迟。</li>
<li>上下文管理器：上下文管理器负责保存和恢复 LLM的生成进度，即使中断，也可以无缝恢复任务。它还管理上下文窗口，确保LLM上下文容量的最佳利用。</li>
<li>内存管理器：AIOS 包括一个内存管理器，为每个代理的交互提供短期内存。这使代理能够保持本地状态并快速访问相关信息，从而提高他们的响应能力和性能。</li>
<li>存储管理器：为了实现长期持久性，存储管理器可以安全地保存代理交互。这使代理能够访问历史数据，从过去的经验中学习，并根据广泛的知识做出明智的决策。</li>
<li>工具管理器：工具管理器负责监督代理可以使用的外部 API 工具。通过集成各种工具，AIOS 使代理能够执行复杂的任务并访问丰富的信息和功能。</li>
<li>访问管理器：为确保隐私和安全，访问管理器在代理之间实施严格的访问控制策略。它管理权限、身份验证和授权，防止未经授权的访问并保护敏感数据。</li>
</ul>
<h2 id="开发人员友好的界面和-SDK"><a href="#开发人员友好的界面和-SDK" class="headerlink" title="开发人员友好的界面和 SDK"></a>开发人员友好的界面和 SDK</h2><p>AIOS 提供了一个直观的LLM系统调用接口，允许开发人员轻松地与底层LLM内核进行交互。此外，AIOS SDK 提供了一套全面的工具和库，使开发人员能够轻松创建复杂的代理应用程序。SDK 抽象了复杂的功能，使代理开发更加易于访问和高效。</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>AIOS采用三层架构，保证模块化、可扩展性和性能：</p>
<ol>
<li>应用程序层：此层是开发和部署代理应用程序的地方。开发人员利用 AIOS SDK 创建可以执行各种任务的智能和交互式代理。</li>
<li>内核层：内核层由两个主要组件组成 — 操作系统内核和LLM内核。操作系统内核处理常规操作系统任务，而LLM内核则专门用于管理LLM特定的活动，确保最佳性能和资源利用率。</li>
<li>硬件层：硬件层包含系统的物理组件，例如 CPU、GPU、内存和存储设备。AIOS 有效地利用这些资源来提供无缝且高性能的代理执行环境。</li>
</ol>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>在AIOS上进行的实验表明，它能够同时运行多个代理，并具有出色的可靠性和效率。即使代理请求暂停和恢复，LLM响应也保持一致，从而确保了生成的输出的完整性。此外，AIOS的智能调度机制明显优于顺序代理执行，在等待和处理时间上实现了更好的平衡。</p>
<p><img src="/../asset_aios/02.png" alt="AIOS architecture"></p>
<p>AIOS 架构概述</p>
<h2 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h2><p>虽然 AIOS 为LLM基于代理的开发和部署提供了一种开创性的方法，但未来还有几种令人兴奋的研究和改进途径：</p>
<ul>
<li>高级调度算法：开发考虑座席请求之间的依赖关系的调度算法，并根据优先级和紧急程度优化资源分配。</li>
<li>高效的上下文管理：探索更高效地管理上下文的技术，例如上下文压缩和摘要，以最大限度地提高上下文窗口的LLM利用率。</li>
<li>优化内存和存储：研究优化内存和存储架构的方法，以促进无缝代理协作，例如实施共享内存池和分层缓存机制。</li>
<li>增强安全性和隐私性：不断增强 AIOS 的安全和隐私功能，包括高级加密技术、安全通信协议和强大的访问控制机制。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>AIOS代表了开发和部署基于代理的LLM的一步。通过集成到LLMs操作系统中，AIOS为代理执行创造了一个智能高效的环境。凭借其全面的模块集、开发人员友好的界面和优化的架构，AIOS 为智能代理生态系统奠定了基础。</p>
<p>随着研究人员继续探索和扩展AIOS的功能，我们可以预见未来，基于LLM智能体的代理将变得越来越复杂、自主，并成为各个领域不可或缺的一部分。AIOS开辟了许多可能性，为下一代智能系统铺平了道路，这些系统能够以前所未有的方式理解、推理并与世界互动。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@simeon.emanuilov/llm-agent-operating-system-aios-and-the-future-of-llm-powered-agents-3d08b4e91c34">https://medium.com/@simeon.emanuilov/llm-agent-operating-system-aios-and-the-future-of-llm-powered-agents-3d08b4e91c34</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/04/knowledge-transfer-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/04/knowledge-transfer-tutorial/" class="post-title-link" itemprop="url">英文知识搬运教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-04 10:21:12" itemprop="dateCreated datePublished" datetime="2024-07-04T10:21:12+08:00">2024-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-08 11:43:42" itemprop="dateModified" datetime="2024-10-08T11:43:42+08:00">2024-10-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前搬运很多medium的文章，搬运过程很耗时间，首先要把网页文章翻译成中文，然后一段段的校对，拷贝黏贴到markdown文件中，图片文件要下载存储更名到本地，编写markdown文件链接。最后再转换成html文件发布到github io博客。经常要2~3个小时才能完成一篇文章的搬运。</p>
<p>前两天发现思源笔记可以直接拷贝粘贴翻译好的文章，生成笔记，作为平时的网络摘抄笔记。评估了一下思源的会员，最后还是安装思源笔记docker server版本，免费开源。会员有图传和同步功能，对于程序员来说，可以克服这些问题。</p>
<p>言归正传，对于经典的文章，想要发布到博客的，可以用思源笔记把文章导出到markdown文件，省掉编辑markdown的时间。不过，markdown里面的图片链接都是远程的，我们当然不希望这些图片不受控制，所以还需要把图片下载到本地，然后更新markdown文件中的链接。思源笔记有转换远程图片到思源笔记服务器的功能，对medium来说,要翻墙才行。</p>
<p>如果思源笔记服务器不翻墙,那就要在本地编辑电脑翻墙下载.写个python脚本，自动下载markdown的远程链接文件，把图片下载到本地，更新链接，这样就可以省下很多时间，而且图片也能更好地管理。</p>
<p>pip install requests python-magic</p>
<p>对于windows系统，还需要 pip install python-magic-bin</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> magic</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_images_and_update_markdown</span>(<span class="params">markdown_file, output_directory</span>):</span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_directory):</span><br><span class="line">        os.makedirs(output_directory)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将输出目录转换为绝对路径</span></span><br><span class="line">    output_directory = os.path.abspath(output_directory)</span><br><span class="line">    markdown_file = os.path.abspath(markdown_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取Markdown文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(markdown_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = file.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用正则表达式匹配图片URL</span></span><br><span class="line">    urls = re.findall(<span class="string">r&#x27;!\[.*?\]\((https?://[^\s]+)\)&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储远程到本地文件的映射</span></span><br><span class="line">    url_to_local = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(urls, start=<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 临时文件路径</span></span><br><span class="line">            temp_filename = os.path.join(output_directory, <span class="string">f&quot;temp_<span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 下载文件</span></span><br><span class="line">            response = requests.get(url, headers=headers)</span><br><span class="line">            response.raise_for_status()  <span class="comment"># 检查请求是否成功</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存临时文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(temp_filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(response.content)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用magic库检测文件类型</span></span><br><span class="line">            mime = magic.Magic(mime=<span class="literal">True</span>)</span><br><span class="line">            mime_type = mime.from_file(temp_filename)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 根据mime类型确定扩展名</span></span><br><span class="line">            <span class="keyword">if</span> mime_type == <span class="string">&#x27;image/jpeg&#x27;</span>:</span><br><span class="line">                extension = <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> mime_type == <span class="string">&#x27;image/png&#x27;</span>:</span><br><span class="line">                extension = <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> mime_type == <span class="string">&#x27;image/gif&#x27;</span>:</span><br><span class="line">                extension = <span class="string">&#x27;.gif&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                extension = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> extension:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Failed to determine the file type of <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最终文件名</span></span><br><span class="line">            filename = os.path.join(output_directory, <span class="string">f&quot;<span class="subst">&#123;index:02&#125;</span><span class="subst">&#123;extension&#125;</span>&quot;</span>)</span><br><span class="line">            os.rename(temp_filename, filename)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Downloaded: <span class="subst">&#123;url&#125;</span> to <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算相对于Markdown文件的相对路径并替换反斜杠为正斜杠</span></span><br><span class="line">            relative_path = os.path.relpath(filename, os.path.dirname(markdown_file)).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存远程到本地文件的映射</span></span><br><span class="line">            url_to_local[url] = relative_path</span><br><span class="line">        <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Failed to download <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新Markdown文件内容</span></span><br><span class="line">    <span class="keyword">for</span> url, local_path <span class="keyword">in</span> url_to_local.items():</span><br><span class="line">        content = content.replace(url, local_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将更新后的内容写回Markdown文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(markdown_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Download images from a markdown file and update the links.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;markdown_file&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;The path to the markdown file.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;output_directory&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;The path to the output directory.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    download_images_and_update_markdown(args.markdown_file, args.output_directory)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/07/03/serveless-ai/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/03/serveless-ai/" class="post-title-link" itemprop="url">使用 Google Cloud 预训练 AI 构建无服务器图像文本提取器和翻译器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 17:52:25" itemprop="dateCreated datePublished" datetime="2024-07-03T17:52:25+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-04 11:16:21" itemprop="dateModified" datetime="2024-07-04T11:16:21+08:00">2024-07-04</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>53 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/../asset_serveless_ai/01.jpg"></p>
<p> 图像-文本-翻译器</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一篇关于Google Cloud端到端开发体验的博客。</p>
<p><img src="/../asset_serveless_ai/02.png"></p>
<p>在这篇博客中，我将讨论如何构建一个无服务器 AI 应用程序，该应用程序获取用户上传的图像，提取它找到的任何文本，并在必要时对其进行翻译。我将利用：</p>
<ul>
<li>Cloud Run 以 Python Flask 应用程序的形式托管 UI。</li>
<li>Cloud Functions，用于托管后端逻辑以响应用户上传图像。</li>
<li><strong>Google 预构建的图像和翻译 AI 机器学习 API。</strong></li>
<li>使用 Visual Studio Code 进行本地开发，以及 functions-framework 用于本地 Cloud Functions 开发的 Cloud Code，以及用于本地 Cloud Run 开发的 Cloud Code。</li>
</ul>
<h1 id="AI-和-AI-产品概览"><a href="#AI-和-AI-产品概览" class="headerlink" title="AI 和 AI 产品概览"></a>AI 和 AI 产品概览</h1><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>人工智能是一个广义的术语，用于描述利用机器自动化来执行通常需要人类智能的任务。例如语音识别、视觉感知、语言翻译、决策。</p>
<p><img src="/../asset_serveless_ai/03.gif"></p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>人工智能的一个特定子领域，与教机器识别数据模式有关，并且能够在没有明确编码解决方案的情况下进行预测和解决问题。</p>
<h2 id="生成式人工智能（Gen-AI）"><a href="#生成式人工智能（Gen-AI）" class="headerlink" title="生成式人工智能（Gen AI）"></a>生成式人工智能（Gen AI）</h2><p>AI 的一个子类，能够生成与训练数据相似但不相同的新数据。Gen AI 依赖于基础模型，例如大型语言模型 （）、LLMs生成图像模型和多模态模型。多模态模型是一种能够处理多种类型的输入数据（例如文本、图像和视频）并生成多种类型内容的模型。</p>
<p><img src="/../asset_serveless_ai/04.png"></p>
<p>多模态 Gen AI — 例如 Google Gemini Pro</p>
<p>我的解决方案不会使用 Gen AI。但我在这里提到它，因为 Gen AI 非常普遍，我想确保你了解这些模型与我在解决方案中使用的预测模型有何不同。</p>
<h2 id="Google-的预训练机器学习-API"><a href="#Google-的预训练机器学习-API" class="headerlink" title="Google 的预训练机器学习 API"></a>Google 的预训练机器学习 API</h2><p>这些是 Google 预先构建和训练的 ML 模型，用于执行特定任务。它们被归类为预测模型，而不是生成模型。示例包括：</p>
<ul>
<li>Google Cloud Vision API — 用于分类、面部识别和文本检测等任务。</li>
<li>Google Cloud Natural Language API— 用于理解文本背后的含义。这包括识别文本的重要元素，以及情感分析。</li>
<li>Google Cloud Translation API — 用于将一种语言翻译成另一种语言。</li>
<li>Google Cloud Video — 用于视频分析和注释。</li>
</ul>
<h1 id="申请动机"><a href="#申请动机" class="headerlink" title="申请动机"></a>申请动机</h1><p>我学习乌克兰语已经有一段时间了,乌克兰有一种模因。有时我会理解这个模因。通常我不会。</p>
<p><img src="/../asset_serveless_ai/11.png"></p>
<p> 乌克兰模因</p>
<p>所以我想……“我想要一个应用程序，我可以上传一个模因（或任何图像），从中提取文本，并将该文本翻译成我的母语。”</p>
<p>当然，还有其他方法可以做到这一点。但我认为这是一个很好的用例，可以在 Google Cloud 中从头开始构建一个新的无服务器应用程序。</p>
<h1 id="应用程序架构"><a href="#应用程序架构" class="headerlink" title="应用程序架构"></a>应用程序架构</h1><p>这是一个非常简单的应用程序架构，托管在 Google Cloud 无服务器服务上：</p>
<p><img src="/../asset_serveless_ai/06.png"></p>
<p>图像-文本-翻译器应用程序的体系结构</p>
<h2 id="The-Webapp-UI-—-Cloud-Run"><a href="#The-Webapp-UI-—-Cloud-Run" class="headerlink" title="The Webapp UI — Cloud Run"></a>The Webapp UI — Cloud Run</h2><p>在这里，我在 Google Cloud Run 上将 Flask Web 应用程序作为容器运行。Web 应用程序执行以下几项操作：</p>
<ol>
<li>它呈现包含用于捕获用户输入（例如语言和图像上传）的表单的前端页面。</li>
<li>它处理来自用户的请求，捕获图像，并将其发送到 Cloud Function 后端。</li>
</ol>
<p>我之所以选择 Cloud Run，是因为：</p>
<ul>
<li>它提供了一种托管和运行容器化应用程序的无服务器方式。（即我们的 Python Flask Web 应用程序。</li>
<li>它非常适合托管简单的无状态 Web 应用程序，例如这个应用程序。</li>
<li>它会自动扩展，并在没有需求时缩减到 0 个实例。</li>
</ul>
<h2 id="后端-—-云函数"><a href="#后端-—-云函数" class="headerlink" title="后端 — 云函数"></a>后端 — 云函数</h2><p>Cloud Function 从用户处接收图像（通过 Web 应用程序界面），然后调用相应的 Google Cloud API，以便从图像中提取文本并进行翻译。</p>
<p>我之所以选择 Cloud Functions，是因为：</p>
<ul>
<li>它非常适合执行短期处理，以响应事件。因此，非常适合运行我们的提取和翻译任务，以响应用户上传的图像。</li>
<li>它会自动缩放，并在没有需求时缩减到 0。</li>
<li>我们可以将图像处理与实际用户前端解耦。因此，如果我们想使用不同的前端，我们可以轻松地做到这一点，而无需更改云函数中的代码。</li>
</ul>
<h2 id="文本提取和翻译"><a href="#文本提取和翻译" class="headerlink" title="文本提取和翻译"></a>文本提取和翻译</h2><p>我正在使用 Google 预构建的 Vision API 和 Translation API。但是，为什么不使用生成式AI模型，例如Gemini Pro Vision呢？</p>
<ul>
<li>视觉和翻译 API 是专门为我想要执行的任务而构建的。</li>
<li>相反，Gemini Pro Gen AI 多模态基础模型可以响应自然语言提示，实现相同的结果。但是，我们在这里不需要自然语言交互。为什么？因为我们确切地知道我们希望 API 在响应图像上传时执行什么操作。</li>
<li>尽管 Gemino Pro Vision 作为多模态基础模型具有更多的多功能性，但这种功能伴随着更高的价格标签。Vision API 每月允许 1000 次免费调用;翻译 API 每月免费提供前五十万个字符的翻译。</li>
</ul>
<h1 id="我的开发环境"><a href="#我的开发环境" class="headerlink" title="我的开发环境"></a>我的开发环境</h1><h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>我正在运行 Windows，其中包含适用于 Linux 的 Windows 子系统 （WSL）。对于那些不熟悉 WSL 的人来说，它是一个开箱即用的环境（包含在 Windows 10 及更高版本中），允许直接在 Windows 中运行完整的 Linux 环境。我碰巧在使用 Ubuntu。</p>
<p>在 WSL 中工作的好处是我可以用 bash 编写任何必要的脚本，这意味着我的代码将更具可移植性。例如，我可以在自己的环境中运行与在 Google Cloud Shell 中相同的脚本。</p>
<h2 id="Visual-Studio-代码"><a href="#Visual-Studio-代码" class="headerlink" title="Visual Studio 代码"></a>Visual Studio 代码</h2><p>VS Code 是我选择的代码编辑器。它是免费和开源的。它在 Windows、Linux 和 Mac 上运行，并具有许多有用的插件，例如 Git 集成和 Google Cloud Code：一组 AI 辅助插件（包括 Gemini Code Assist），用于促进使用 Google Cloud 服务的本地开发。</p>
<h1 id="开发项目结构"><a href="#开发项目结构" class="headerlink" title="开发项目结构"></a>开发项目结构</h1><p>如果你想查看 git 存储库，你可以在这里找到它。</p>
<p>整体结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">└── image-text-translator</span><br><span class="line">    ├── docs/                   - Documentation for the repo</span><br><span class="line">    |</span><br><span class="line">    ├── infra-tf/               - Terraform for installing infra</span><br><span class="line">    |</span><br><span class="line">    ├── scripts/                - For environment setup and helper scripts</span><br><span class="line">    |   └── setup.sh            - Setup helper script</span><br><span class="line">    |</span><br><span class="line">    ├── app/                    - The Application</span><br><span class="line">    │   ├── ui_cr/                - Browser UI (Cloud Run)</span><br><span class="line">    │   │   ├── static/             - Static content for frontend</span><br><span class="line">    |   |   ├── templates/          - HTML templates for frontend</span><br><span class="line">    |   |   ├── app.py              - The Flask application</span><br><span class="line">    |   |   ├── requirements.txt    - The UI Python requirements</span><br><span class="line">    |   |   ├── Dockerfile             - Dockerfile to build the Flask container</span><br><span class="line">    |   |   └── .dockerignore          - Files to ignore in Dockerfile</span><br><span class="line">    |   |</span><br><span class="line">    │   └── backend_gcf/          - Backend (Cloud Function)</span><br><span class="line">    │       ├── main.py             - The backend CF application</span><br><span class="line">    │       └── requirements.txt    - The backend CF Python requirements</span><br><span class="line">    |</span><br><span class="line">    ├── testing/</span><br><span class="line">    │   └── images/</span><br><span class="line">    |</span><br><span class="line">    ├── requirements.txt          - Python requirements for project local dev</span><br><span class="line">    └── README.md</span><br></pre></td></tr></table></figure>

<h1 id="一次性-Google-项目设置和权限"><a href="#一次性-Google-项目设置和权限" class="headerlink" title="一次性 Google 项目设置和权限"></a>一次性 Google 项目设置和权限</h1><h2 id="创建-Google-Cloud-项目"><a href="#创建-Google-Cloud-项目" class="headerlink" title="创建 Google Cloud 项目"></a>创建 Google Cloud 项目</h2><p>为您的应用创建 Google Cloud 项目。这是我的：</p>
<p><img src="/../asset_serveless_ai/07.png"></p>
<p>创建您的 Google Cloud 项目</p>
<p>从具有足够权限的帐户（例如 或 Project Admin Org Admin .</p>
<h2 id="启用-API"><a href="#启用-API" class="headerlink" title="启用 API"></a>启用 API</h2><p>最终，我们将对这种配置进行 Terraform。但最初，这些是您需要启用的 API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Authenticate to Google Cloud</span><br><span class="line">gcloud auth list</span><br><span class="line"></span><br><span class="line"># Check we have the correct project selected</span><br><span class="line">export PROJECT_ID=&lt;enter your project ID&gt;</span><br><span class="line">gcloud config set project $PROJECT_ID</span><br><span class="line"></span><br><span class="line"># Enable Cloud Build API</span><br><span class="line">gcloud services enable cloudbuild.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Storage API</span><br><span class="line">gcloud services enable storage-api.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Artifact Registry API</span><br><span class="line">gcloud services enable artifactregistry.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Eventarc API</span><br><span class="line">gcloud services enable eventarc.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Run Admin API</span><br><span class="line">gcloud services enable run.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Logging API</span><br><span class="line">gcloud services enable logging.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Pub/Sub API</span><br><span class="line">gcloud services enable pubsub.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Functions API</span><br><span class="line">gcloud services enable cloudfunctions.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Translation API</span><br><span class="line">gcloud services enable translate.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Cloud Vision API</span><br><span class="line">gcloud services enable vision.googleapis.com</span><br><span class="line"></span><br><span class="line"># Enable Service Account Credentials API</span><br><span class="line">gcloud services enable iamcredentials.googleapis.com</span><br></pre></td></tr></table></figure>

<h2 id="服务帐户和角色"><a href="#服务帐户和角色" class="headerlink" title="服务帐户和角色"></a>服务帐户和角色</h2><p>服务帐户是管理应用程序（而不是最终用户）的身份验证和授权的标准方法。我们的 Cloud Run 应用程序需要向 Cloud Function 进行身份验证，而 Cloud Function 需要向 Cloud Cloud Vision 和 Translation API 进行身份验证。</p>
<p>因此，让我们创建一个服务帐户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Make sure your PROJECT_ID variable is set before doing this!</span><br><span class="line">export SVC_ACCOUNT=image-text-translator-sa</span><br><span class="line">export SVC_ACCOUNT_EMAIL=$SVC_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com</span><br><span class="line"></span><br><span class="line"># Attaching a user-managed service account is the preferred way to provide credentials to ADC for production code running on Google Cloud.</span><br><span class="line">gcloud iam service-accounts create $SVC_ACCOUNT</span><br></pre></td></tr></table></figure>

<p>现在，我们将多个角色绑定到我们的服务帐户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Grant roles to the service account</span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/run.admin</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/run.invoker</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/cloudfunctions.admin</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=roles/cloudfunctions.invoker</span><br><span class="line"></span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot; \</span><br><span class="line">  --role=&quot;roles/cloudtranslate.user&quot;</span><br><span class="line"></span><br><span class="line"># Grant the required role to the principal that will attach the service account to other resources.</span><br><span class="line">gcloud iam service-accounts add-iam-policy-binding $SVC_ACCOUNT_EMAIL \</span><br><span class="line">  --member=&quot;group:gcp-devops@my-org.com&quot; \</span><br><span class="line">  --role=roles/iam.serviceAccountUser</span><br><span class="line"></span><br><span class="line"># Allow service account impersonation</span><br><span class="line">gcloud iam service-accounts add-iam-policy-binding $SVC_ACCOUNT_EMAIL \</span><br><span class="line">  --member=&quot;group:gcp-devops@my-org.com&quot; \</span><br><span class="line">  --role=roles/iam.serviceAccountTokenCreator</span><br><span class="line"></span><br><span class="line"># Ensure your account has access to deploy to Cloud Functions and Cloud Run</span><br><span class="line">gcloud projects add-iam-policy-binding $PROJECT_ID \</span><br><span class="line">   --member=&quot;group:gcp-devops@my-org.com&quot; \</span><br><span class="line">   --role roles/run.admin</span><br></pre></td></tr></table></figure>

<h1 id="本地开发环境设置"><a href="#本地开发环境设置" class="headerlink" title="本地开发环境设置"></a>本地开发环境设置</h1><p>（您需要在计划进行开发的任何计算机上执行这些步骤。</p>
<p>打开终端。（我正在从 Windows 终端打开 Ubuntu Shell。如果您尚未这样做，则需要将 Google gcloud CLI 和支持工具安装到您的本地环境中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Install Google Cloud CLI in your local Linux environment.</span><br><span class="line"># See https://cloud.google.com/sdk/docs/install</span><br><span class="line"></span><br><span class="line"># Setup Python and pip in Gcloud CLI</span><br><span class="line"># See https://cloud.google.com/python/docs/setup</span><br><span class="line"></span><br><span class="line"># Install additional Google Cloud CLI packages for local dev</span><br><span class="line">sudo apt install google-cloud-cli-gke-gcloud-auth-plugin kubectl google-cloud-cli-skaffold google-cloud-cli-minikube</span><br></pre></td></tr></table></figure>

<p>在这里（从现在开始），我们将使用我们的开发人员帐户进行身份验证，而不是组织管理员帐户。为什么？我遵循最小特权原则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Authenticate to Google Cloud</span><br><span class="line">gcloud auth login</span><br></pre></td></tr></table></figure>

<p>身份验证时，单击显示的第一个链接。然后，系统会提示您提供密码。</p>
<p><img src="/../asset_serveless_ai/08.png"></p>
<p>向 Google Cloud 进行身份验证</p>
<p>接下来，我们将设置应用程序项目文件夹并安装一些依赖项。如果您要遵循并从头开始构建应用程序，则接下来的步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># This is where I keep my project</span><br><span class="line">cd ~/localdev/gcp/image-text-translator</span><br><span class="line"></span><br><span class="line"># Create a Python virtual env. For example...</span><br><span class="line">python3 -m venv .venv</span><br><span class="line"># And now ACTIVATE it</span><br><span class="line"></span><br><span class="line"># Add Python packages we need...</span><br><span class="line">python3 -m pip install Flask</span><br><span class="line">python3 -m pip install pillow # For image handling</span><br><span class="line">python3 -m pip install functions-framework</span><br><span class="line">python3 -m pip install google-cloud-storage google-cloud-translate google-cloud-vision google-auth</span><br><span class="line"></span><br><span class="line"># And create the requirements.txt file</span><br><span class="line">python3 -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>或者，如果你想克隆我的 git 存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/derailed-dash/image-text-translator.git</span><br><span class="line"></span><br><span class="line">cd image-text-translator</span><br><span class="line"></span><br><span class="line"># Create a Python virtual env. For example...</span><br><span class="line">python3 -m venv .venv</span><br><span class="line"># And now ACTIVATE it. E.g.</span><br><span class="line">source .venv/bin/activate</span><br><span class="line"></span><br><span class="line"># Install the Python dependencies now</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="Git-设置"><a href="#Git-设置" class="headerlink" title="Git 设置"></a>Git 设置</h2><p>如果你从头开始构建所有内容（没有克隆我的存储库），你现在应该设置你的 Git 和 GitHub 环境。别忘了先创建 .gitignore .查看我的存储库以了解它应该是什么样子。然后按照下列步骤操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Setup git in Cloud Shell, if you haven&#x27;t done so before</span><br><span class="line">git config --global user.email &quot;bob@wherever.com&quot;</span><br><span class="line">git config --global user.name &quot;Bob&quot;</span><br><span class="line">git config --global core.autocrlf input # really important if you&#x27;re using WSL!</span><br><span class="line"></span><br><span class="line"># Create local git repo.</span><br><span class="line"># Before proceeding, make sure you have created .gitignore file </span><br><span class="line"># to ignore .terraform dirs and local state, plans, etc.</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line"># Let&#x27;s authenticate the GitHub command line tool</span><br><span class="line"># It is already installed on Cloud Shell</span><br><span class="line">gh auth login</span><br><span class="line"></span><br><span class="line"># Now let&#x27;s use gh cli to create a remote repo in GitHub.</span><br><span class="line"># You can make it private, if you prefer</span><br><span class="line">gh repo create image-text-translator --public --source=.</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="运行-VS-Code"><a href="#运行-VS-Code" class="headerlink" title="运行 VS Code"></a>运行 VS Code</h2><p>让我们从项目文件夹中打开 VS Code：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># From /path/to/your/image-text-translator</span><br><span class="line">code .</span><br></pre></td></tr></table></figure>

<p>VS Code 足够聪明，可以配置所需的任何必要的 WSL 插件。</p>
<p><img src="/../asset_serveless_ai/09.png"></p>
<p>VS Code 知道它在 WSL 环境中工作</p>
<h2 id="安装应用程序默认凭据-（ADC）"><a href="#安装应用程序默认凭据-（ADC）" class="headerlink" title="安装应用程序默认凭据 （ADC）"></a>安装应用程序默认凭据 （ADC）</h2><p>ADC 是一种策略，它允许身份验证库根据当前环境自动查找凭据。这很有用，因为我们既可以在本地环境（使用 Cloud SDK）中利用 ADC，也可以在 Google Cloud 上的目标环境中利用 ADC。</p>
<p>ADC 可以配置为使用我们的服务帐户凭据。有两种方法可以做到这一点：</p>
<ol>
<li>我们可以使用自己的用户身份模拟服务帐户。</li>
<li>我们可以为我们的服务帐户创建一个私钥，并将 ADC 指向此密钥的位置。</li>
</ol>
<p>我最初尝试使用模拟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud auth application-default login --impersonate-service-account $SVC_ACCOUNT_EMAIL</span><br></pre></td></tr></table></figure>

<p>不幸的是，在对 Cloud Run 的 Cloud Function 调用进行身份验证时，我很难做到这一点。因此，我创建了一个服务帐户密钥，我们可以将 ADC 指向：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gcloud auth application-default login</span><br><span class="line"></span><br><span class="line"># If these are not already set...</span><br><span class="line">export SVC_ACCOUNT=image-text-translator-sa</span><br><span class="line">export SVC_ACCOUNT_EMAIL=$SVC_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com</span><br><span class="line"></span><br><span class="line"># Create a service account key for local dev</span><br><span class="line">gcloud iam service-accounts keys create ~/.config/gcloud/$SVC_ACCOUNT.json \</span><br><span class="line">  --iam-account=$SVC_ACCOUNT_EMAIL</span><br><span class="line"></span><br><span class="line"># Configure the ADC environment variable</span><br><span class="line"># which is automatically detected by client libraries</span><br><span class="line">export GOOGLE_APPLICATION_CREDENTIALS=~/.config/gcloud/$SVC_ACCOUNT.json</span><br></pre></td></tr></table></figure>

<p>我们实际上需要在每个会话中设置这个 GOOGLE_APPLICATION_CREDENTIALS 环境变量。这就把我们带到了…</p>
<h1 id="每个会话的设置"><a href="#每个会话的设置" class="headerlink" title="每个会话的设置"></a>每个会话的设置</h1><p>您需要在每个新的终端会话中运行这些命令。（或者，您可以运行命令 source <project_dir>&#x2F;scripts&#x2F;setup.sh 来运行这些命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export PROJECT_ID=$(gcloud config list --format=&#x27;value(core.project)&#x27;)</span><br><span class="line">export REGION=europe-west4</span><br><span class="line">export SVC_ACCOUNT=image-text-translator-sa</span><br><span class="line">export SVC_ACCOUNT_EMAIL=$SVC_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com</span><br><span class="line">export GOOGLE_APPLICATION_CREDENTIALS=~/.config/gcloud/$SVC_ACCOUNT.json</span><br><span class="line"></span><br><span class="line"># Functions</span><br><span class="line">export FUNCTIONS_PORT=8081</span><br><span class="line">export BACKEND_GCF=https://$REGION-$PROJECT_ID.cloudfunctions.net/extract-and-translate</span><br><span class="line"></span><br><span class="line"># Flask</span><br><span class="line">export FLASK_SECRET_KEY=some-secret-1234</span><br><span class="line">export FLASK_RUN_PORT=8080</span><br><span class="line"></span><br><span class="line">echo &quot;Environment variables configured:&quot;</span><br><span class="line">echo PROJECT_ID=&quot;$PROJECT_ID&quot;</span><br><span class="line">echo REGION=&quot;$REGION&quot;</span><br><span class="line">echo SVC_ACCOUNT_EMAIL=&quot;$SVC_ACCOUNT_EMAIL&quot;</span><br><span class="line">echo BACKEND_GCF=&quot;$BACKEND_GCF&quot;</span><br><span class="line">echo FUNCTIONS_PORT=&quot;$FUNCTIONS_PORT&quot;</span><br><span class="line">echo FLASK_RUN_PORT=&quot;$FLASK_RUN_PORT&quot;</span><br></pre></td></tr></table></figure>

<h1 id="云函数后端"><a href="#云函数后端" class="headerlink" title="云函数后端"></a>云函数后端</h1><h2 id="功能的本地开发"><a href="#功能的本地开发" class="headerlink" title="功能的本地开发"></a>功能的本地开发</h2><p>我不会重现所有代码，因为您可以在 GitHub 中查看它。我只想指出几件关键的事情。</p>
<p>在我的 backend-gcf 文件夹中，我创建了一个 requirements.txt .这是为了定义必须安装的 Python 包。当您部署 Cloud Functions 时，Cloud Functions 会自动安装这些软件包。</p>
<p>然后我创建一个 main.py .以下是作为云函数入口点的部分函数： extract_and_translate() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@functions_framework.http</span><br><span class="line">def extract_and_translate(request):</span><br><span class="line">    &quot;&quot;&quot;Extract and translate the text from an image.</span><br><span class="line">    The image can be POSTed in the request, or it can be a GCS object reference.</span><br><span class="line"></span><br><span class="line">    If a POSTed image, enctype should be multipart/form-data and the file should be named &#x27;uploaded&#x27;.</span><br><span class="line">    If we&#x27;re passing a GCS object reference, content-type should be &#x27;application/json&#x27;, </span><br><span class="line">    with two attributes:</span><br><span class="line">    - bucket: name of GCS bucket in which the file is stored.</span><br><span class="line">    - filename: name of the file to be read.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # Check if the request method is POST</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        # Get the uploaded file from the request</span><br><span class="line">        uploaded = request.files.get(&#x27;uploaded&#x27;)  # Assuming the input filename is &#x27;uploaded&#x27;</span><br><span class="line">        to_lang = request.form.get(&#x27;to_lang&#x27;, &quot;en&quot;)</span><br><span class="line">        print(f&quot;&#123;uploaded=&#125;, &#123;to_lang=&#125;&quot;)</span><br><span class="line">        if not uploaded:</span><br><span class="line">            return flask.jsonify(&#123;&quot;error&quot;: &quot;No file uploaded.&quot;&#125;), 400</span><br><span class="line"></span><br><span class="line">        if uploaded: # Process the uploaded file</span><br><span class="line">            file_contents = uploaded.read()  # Read the file contents</span><br><span class="line">            image = vision.Image(content=file_contents)</span><br><span class="line">        else:</span><br><span class="line">            return flask.jsonify(&#123;&quot;error&quot;: &quot;Unable to read uploaded file.&quot;&#125;), 400</span><br></pre></td></tr></table></figure>

<p>这是不言自明的。</p>
<ul>
<li>我们检查函数是否已收到 POST。 （稍后，我们将创建 Cloud Run 应用程序来 POST 请求。</li>
<li>如果是这样，我们将在请求中查找一个名为 uploaded 的对象。（我们的 Cloud Run 应用程序会将其附加到请求中。</li>
<li>如果我们发现这个对象附加了，我们把它读成二进制，然后用它来创建 vision.Image 对象。</li>
<li>接下来我们调用函数 detect_text() ，传入图像。此函数将使用 Vision API 查看图像中是否有任何文本。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Use the Vision API to extract text from the image</span><br><span class="line">detected = detect_text(image)</span><br><span class="line">if detected:</span><br><span class="line">   translated = translate_text(detected, to_lang)</span><br><span class="line">   if translated[&quot;text&quot;] != &quot;&quot;:</span><br><span class="line">       return translated[&quot;text&quot;]</span><br></pre></td></tr></table></figure>

<p>如果是这样，它将返回包含此文本的 Python 字典。然后，它会将此文本传递到函数中 translate_text() ，以将文本翻译成我们选择的语言。</p>
<p>detect_text() 功能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def detect_text(image: vision.Image) -&gt; dict | None:</span><br><span class="line">    &quot;&quot;&quot;Extract the text from the Image object &quot;&quot;&quot;</span><br><span class="line">    text_detection_response = vision_client.text_detection(image=image)</span><br><span class="line">    annotations = text_detection_response.text_annotations</span><br><span class="line"></span><br><span class="line">    if annotations:</span><br><span class="line">        text = annotations[0].description</span><br><span class="line">    else:</span><br><span class="line">        text = &quot;&quot;</span><br><span class="line">    print(f&quot;Extracted text from image:\n&#123;text&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # Returns language identifer in ISO 639-1 format. E.g. en.</span><br><span class="line">    # See https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes</span><br><span class="line">    detect_language_response = translate_client.detect_language(text)</span><br><span class="line">    src_lang = detect_language_response[&quot;language&quot;]</span><br><span class="line">    print(f&quot;Detected language: &#123;src_lang&#125;.&quot;)</span><br><span class="line"></span><br><span class="line">    message = &#123;</span><br><span class="line">        &quot;text&quot;: text,</span><br><span class="line">        &quot;src_lang&quot;: src_lang,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return message</span><br></pre></td></tr></table></figure>

<p>此代码不仅检测图像中的任何文本，还使用 Google 语言 API 来确定文本的语言。</p>
<p>接下来， translate_text() 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def translate_text(message: dict, to_lang: str) -&gt; dict:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Translates the text in the message from the specified source language</span><br><span class="line">    to the requested target language, then sends a message requesting another</span><br><span class="line">    service save the result.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    text = message[&quot;text&quot;]</span><br><span class="line">    src_lang = message[&quot;src_lang&quot;]</span><br><span class="line"></span><br><span class="line">    translated = &#123; # before translating</span><br><span class="line">        &quot;text&quot;: text,</span><br><span class="line">        &quot;src_lang&quot;: src_lang,</span><br><span class="line">        &quot;to_lang&quot;: to_lang,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if src_lang != to_lang and src_lang != &quot;und&quot;:</span><br><span class="line">        print(f&quot;Translating text into &#123;to_lang&#125;.&quot;)</span><br><span class="line">        translated_text = translate_client.translate(</span><br><span class="line">                text, target_language=to_lang, source_language=src_lang)</span><br><span class="line"></span><br><span class="line">        translated = &#123;</span><br><span class="line">            &quot;text&quot;: unescape(translated_text[&quot;translatedText&quot;]),</span><br><span class="line">            &quot;src_lang&quot;: src_lang,</span><br><span class="line">            &quot;to_lang&quot;: to_lang,</span><br><span class="line">        &#125;</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;No translation required.&quot;)</span><br><span class="line"></span><br><span class="line">    return translated</span><br></pre></td></tr></table></figure>

<p>我们检查源语言和目标语言是否不同，并且源语言是否未定义。如果我们通过了此检查，我们将使用 Google 翻译 API 来翻译文本。</p>
<h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>首先，让我们在本地运行该函数。从我们的 backend-gcf 文件夹中运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run the function</span><br><span class="line">functions-framework --target extract_and_translate \</span><br><span class="line">  --debug --port $FUNCTIONS_PORT</span><br></pre></td></tr></table></figure>

<p>它应该看起来像这样：</p>
<p><img src="/../asset_serveless_ai/10.png"></p>
<p>在本地运行我们的函数</p>
<p>我将用这张图片进行测试：</p>
<p><img src="/../asset_serveless_ai/11.png"></p>
<p> 乌克兰语中的模因</p>
<p>从第二个终端，让我们对函数进行 POST 操作，使用 curl ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># You will first need to authenticate and set the environment vars in this terminal</span><br><span class="line">source ./scripts/setup.sh</span><br><span class="line"></span><br><span class="line"># now invoke</span><br><span class="line">curl -X POST localhost:$FUNCTIONS_PORT \</span><br><span class="line">   -H &quot;Content-Type: multipart/form-data&quot; \</span><br><span class="line">   -F &quot;uploaded=@./testing/images/ua_meme.jpg&quot; \</span><br><span class="line">   -F &quot;to_lang=en&quot;</span><br></pre></td></tr></table></figure>

<p> 它有效！！</p>
<p><img src="/../asset_serveless_ai/12.png"></p>
<p>我们申请的回应</p>
<h2 id="部署云功能（到-Google-Cloud）"><a href="#部署云功能（到-Google-Cloud）" class="headerlink" title="部署云功能（到 Google Cloud）"></a>部署云功能（到 Google Cloud）</h2><p>现在我们已经在本地测试了它，我们可以将其部署到 Google Cloud。同样，我们必须从我们的 backend-gcf 文件夹中运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># From the backend-gcf folder</span><br><span class="line">gcloud functions deploy extract-and-translate \</span><br><span class="line">  --gen2 --max-instances 1 \</span><br><span class="line">  --region $REGION \</span><br><span class="line">  --runtime=python312 --source=. \</span><br><span class="line">  --trigger-http --entry-point=extract_and_translate \</span><br><span class="line">  --no-allow-unauthenticated</span><br><span class="line"></span><br><span class="line"># Allow this function to be called by the service account</span><br><span class="line">gcloud functions add-invoker-policy-binding extract-and-translate \</span><br><span class="line">  --region=$REGION \</span><br><span class="line">  --member=&quot;serviceAccount:$SVC_ACCOUNT_EMAIL&quot;</span><br></pre></td></tr></table></figure>

<p> 部署结果：</p>
<p><img src="/../asset_serveless_ai/13.png"></p>
<p> 部署成功！</p>
<p>这是一件很酷的事情……借助 VS Code 中的 Cloud Code 扩展，我们现在可以看到我们在 Google Cloud 中部署的云功能！</p>
<p><img src="/../asset_serveless_ai/14.png"></p>
<p>在 Google Cloud 中查看我们的云功能，从 VS Code 中的 Cloud Code 查看</p>
<h2 id="测试云函数"><a href="#测试云函数" class="headerlink" title="测试云函数"></a>测试云函数</h2><p>我们只需要一个稍微不同的 curl 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST https://$REGION-$PROJECT_ID.cloudfunctions.net/extract-and-translate \</span><br><span class="line">    -H &quot;Authorization: Bearer $(gcloud auth print-identity-token)&quot; \</span><br><span class="line">    -H &quot;Content-Type: multipart/form-data&quot; \</span><br><span class="line">    -F &quot;uploaded=@./testing/images/ua_meme.jpg&quot; \</span><br><span class="line">    -F &quot;to_lang=en&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../asset_serveless_ai/15.png"></p>
<p> 它有效！</p>
<p>让我们用这个模因测试英语到英语：</p>
<p><img src="/../asset_serveless_ai/16.jpg"></p>
<p> 测试英语反式</p>
<p><img src="/../asset_serveless_ai/17.png"></p>
<p> 提取英语</p>
<p>现在我将尝试翻译成乌克兰语：</p>
<p><img src="/../asset_serveless_ai/18.png"></p>
<p> 翻译成乌克兰语</p>
<p>呜呜！它有效！现在到法语：</p>
<p><img src="/../asset_serveless_ai/19.png"></p>
<p> 翻译成法语</p>
<p>万岁！所有测试似乎都在起作用。</p>
<p>注意：如果您尝试在不传入经过身份验证和授权的凭据的情况下使用该函数，则会看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;403 Forbidden&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body text=#000000 bgcolor=#ffffff&gt;</span><br><span class="line">&lt;h1&gt;Error: Forbidden&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Your client does not have permission to get URL &lt;code&gt;/extract-and-translate&lt;/code&gt; from this server.&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="部署新版本"><a href="#部署新版本" class="headerlink" title="部署新版本"></a>部署新版本</h2><p>如果我们更新代码并想要重新部署，我们可以重新运行相同的 deploy 命令。</p>
<p><img src="/../asset_serveless_ai/20.png"></p>
<p>通过重新部署来更新我们的功能</p>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><p>如果要删除 Cloud Funtion，只需运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud functions delete extract-and-translate --region=$REGION</span><br></pre></td></tr></table></figure>

<h1 id="烧瓶用户界面"><a href="#烧瓶用户界面" class="headerlink" title="烧瓶用户界面"></a>烧瓶用户界面</h1><p>我们将使用 Cloud Run 创建一个简单的 Flask Python Web 应用程序。此应用程序将呈现表单页面，并处理表单。然后，在检索表单响应（包括上传的图像）后，它将调用我们的云函数。</p>
<h2 id="创建-Flask-Web-应用程序"><a href="#创建-Flask-Web-应用程序" class="headerlink" title="创建 Flask Web 应用程序"></a>创建 Flask Web 应用程序</h2><p>本文不打算作为 Flask 教程。因此，我的建议是查看 GitHub 存储库 ui_cr 文件夹中的代码。</p>
<p>但这里有一些关键点：</p>
<ul>
<li>我创建了一个 requirements.txt 来定义此应用程序所需的 Python 包。</li>
<li>我创建了一个 Dockerfile 负责将我们的 Flask 应用程序打包到 Docker 容器中。（稍后我们将需要此功能才能部署到 Cloud Run。为此，它复制 ui_cr 文件夹的内容，安装 Python 依赖项（如 中 requirements.txt 所定义），然后定义应用程序的入口点。即运行 python app.py .</li>
</ul>
<p>我们的 ui_cr 文件夹具有以下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── ui_cr/                - Browser UI (Cloud Run)</span><br><span class="line">    ├── static/             - Static content for frontend</span><br><span class="line">    ├── templates/          - HTML templates for frontend</span><br><span class="line">    ├── app.py              - The Flask application</span><br><span class="line">    ├── requirements.txt    - The UI Python requirements</span><br><span class="line">    ├── Dockerfile             - Dockerfile to build the Flask container</span><br><span class="line">    └── .dockerignore          - Files to ignore in Dockerfile</span><br></pre></td></tr></table></figure>

<h2 id="应用程序代码"><a href="#应用程序代码" class="headerlink" title="应用程序代码"></a>应用程序代码</h2><p>我不打算详细介绍代码。但我会强调一些有趣的观点和陷阱。</p>
<p>让我们来看看 app.py 。首先，实例化 Flask 应用程序的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def create_app():</span><br><span class="line">    &quot;&quot;&quot; Create and configure the app &quot;&quot;&quot;</span><br><span class="line">    flask_app = Flask(__name__, instance_relative_config=True)</span><br><span class="line">    flask_app.config.from_mapping(</span><br><span class="line">        SECRET_KEY=&#x27;dev&#x27;, # override with FLASK_SECRET_KEY env var</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # Load envs starting with FLASK_</span><br><span class="line">    # E.g. FLASK_SECRET_KEY, FLASK_PORT</span><br><span class="line">    flask_app.config.from_prefixed_env()</span><br><span class="line">    client = translate.Client()</span><br><span class="line">    flask_app.languages = &#123;lang[&#x27;language&#x27;]: lang[&#x27;name&#x27;] for lang in client.get_languages()&#125;</span><br><span class="line">    flask_app.backend_func = os.environ.get(&#x27;BACKEND_GCF&#x27;, &#x27;undefined&#x27;)</span><br><span class="line">    return flask_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br></pre></td></tr></table></figure>

<ul>
<li>Flask 应用程序需要密钥才能管理会话。我们可以使用环境变量 FLASK_SECRET_KEY 将密钥传递给应用程序。</li>
<li>我正在使用 Google 翻译 API 检索要翻译的可用语言列表。我将使用它在我的表单中填充下拉选择。</li>
<li>我们需要传递目标函数的 URL。同样，我将为此使用一个环境变量： BACKEND_GCF .</li>
</ul>
<h2 id="处理对-Flask-主页的请求"><a href="#处理对-Flask-主页的请求" class="headerlink" title="处理对 Flask 主页的请求"></a>处理对 Flask 主页的请求</h2><p>在这里，我们处理对 &#x2F; 的请求。当我们的用户第一次访问该页面时，他们将发送一个 GET 请求。但是，当他们提交带有要翻译的图像的表格时，该请求将作为 POST 收到。因此，我们需要同时处理两者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def entry():</span><br><span class="line">    &quot;&quot;&quot; Render the upload form &quot;&quot;&quot;</span><br><span class="line">    message = &quot;Upload your image!&quot;</span><br><span class="line">    to_lang = os.environ.get(&#x27;TO_LANG&#x27;, &#x27;en&#x27;)</span><br><span class="line">    encoded_img = &quot;&quot;</span><br><span class="line">    translation = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;: # Form has been posted</span><br><span class="line">        app.logger.debug(&quot;Got POST&quot;)</span><br><span class="line">        file = request.files.get(&#x27;file&#x27;)</span><br><span class="line">        to_lang = request.form.get(&#x27;to_lang&#x27;)</span><br><span class="line"></span><br><span class="line">        if file is None:</span><br><span class="line">            flash(&#x27;No file part.&#x27;)</span><br><span class="line">        elif file.filename == &#x27;&#x27;:</span><br><span class="line">            flash(&#x27;No file selected for uploading.&#x27;)</span><br><span class="line">        elif not allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            flash(f&#x27;&#123;secure_filename(filename)&#125; is not a supported image format. &#x27;</span><br><span class="line">                  f&#x27;Supported formats are: &#123;ALLOWED_EXTENSIONS&#125;&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            app.logger.debug(&quot;Got %s&quot;, filename)</span><br><span class="line">            app.logger.debug(&quot;Translating to %s&quot;, to_lang)</span><br><span class="line"></span><br><span class="line">            # We don&#x27;t need to save the image. We just want to binary encode it.</span><br><span class="line">            try:</span><br><span class="line">                img = Image.open(file.stream)</span><br><span class="line">                with BytesIO() as buf:</span><br><span class="line">                    if img_format := img.format: # e.g. JPEG, GIF, PNG</span><br><span class="line">                        img.save(buf, img_format.lower())</span><br><span class="line">                        content_type = f&quot;image/&#123;img_format.lower()&#125;&quot;</span><br><span class="line">                        image_bytes = buf.getvalue()</span><br><span class="line">                        encoded_img = base64.b64encode(image_bytes).decode()</span><br><span class="line">                    else:</span><br><span class="line">                        flash(&#x27;Unable to determine image format.&#x27;)</span><br><span class="line">            except UnidentifiedImageError:</span><br><span class="line">                # This will happen if we resubmit the form</span><br><span class="line">                flash(&#x27;Unable to process image.&#x27;)</span><br><span class="line"></span><br><span class="line">            if encoded_img:</span><br><span class="line">                message = f&quot;Processed &lt;&#123;secure_filename(filename)&#125;&gt;. Feel free to upload a new image.&quot;</span><br><span class="line">                func_response = make_authorized_post_request(endpoint=app.backend_func,</span><br><span class="line">                                        image_data=image_bytes, to_lang=to_lang,</span><br><span class="line">                                        filename=filename, content_type=content_type)</span><br><span class="line">                app.logger.debug(&quot;Function response code: %s&quot;, func_response.status_code)</span><br><span class="line">                app.logger.debug(&quot;Function response text: %s&quot;, func_response.text)</span><br><span class="line">                translation = func_response.text</span><br><span class="line"></span><br><span class="line">    return render_template(&#x27;index.html&#x27;,</span><br><span class="line">                           languages=app.languages,</span><br><span class="line">                           message=message,</span><br><span class="line">                           to_lang=to_lang,</span><br><span class="line">                           img_data=encoded_img,</span><br><span class="line">                           translation=translation), 200</span><br></pre></td></tr></table></figure>

<p>我们验证输入，然后 - 如果图像已上传并且是有效的图像 - 我们向云函数发出请求。此请求需要传递上传图像的原始字节。</p>
<p>此外，我希望能够在返回的页面中向用户显示上传的图像。我想避免将上传的图像保存在后端的磁盘上，所以我采取了这种方法：</p>
<ul>
<li>将上传的图像转换为内存中的 BytesIO 对象。</li>
<li>将内存中的对象转换为 JPEG。</li>
<li>在缓冲区中检索图像的原始字节数据。（这也是我将发送到函数的原始 make_authorised_post_request() 数据。</li>
<li>使用 Base64 编码对 JPEG 二进制图像数据进行编码，这是一种可以安全地发送回浏览器的字符串表示形式。</li>
</ul>
<h2 id="对我们的函数进行经过身份验证的调用"><a href="#对我们的函数进行经过身份验证的调用" class="headerlink" title="对我们的函数进行经过身份验证的调用"></a>对我们的函数进行经过身份验证的调用</h2><p>从 Cloud Run Flask 应用程序调用 Cloud Function 时，我们需要在请求标头中包含服务帐户访问令牌。Google 客户端库将自动从 ADC 检索凭据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def make_authorized_post_request(endpoint:str,</span><br><span class="line">                                 image_data, to_lang:str,</span><br><span class="line">                                 filename:str, content_type:str):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Make a POST request to the specified HTTP endpoint by authenticating with the ID token</span><br><span class="line">    obtained from the google-auth client library using the specified audience value.</span><br><span class="line">    Expects the image_data to be a bytes representation of the image.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if endpoint == &quot;undefined&quot;:</span><br><span class="line">        raise ValueError(&quot;Unable to retrieve Function endpoint.&quot;)</span><br><span class="line"></span><br><span class="line">    # Cloud Functions uses your function&#x27;s URL as the `audience` value</span><br><span class="line">    # For Cloud Functions, `endpoint` and `audience` should be equal</span><br><span class="line">    # ADC requires valid service account credentials</span><br><span class="line">    audience = endpoint</span><br><span class="line">    auth_req = GoogleAuthRequest()</span><br><span class="line"></span><br><span class="line">    # Requests OAuth 2.0 access token for the service identity</span><br><span class="line">    # from the instance metadata server or with local ADC. E.g.</span><br><span class="line">    # export GOOGLE_APPLICATION_CREDENTIALS=/path/to/svc_account.json</span><br><span class="line">    id_token = google.oauth2.id_token.fetch_id_token(auth_req, audience)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;Authorization&quot;: f&quot;Bearer &#123;id_token&#125;&quot;,</span><br><span class="line">        # &quot;Content-Type&quot;: &quot;multipart/form-data&quot; # Let requests library decide on the content-type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files = &#123;</span><br><span class="line">        &quot;uploaded&quot;: (filename, image_data, content_type),</span><br><span class="line">        &quot;to_lang&quot;: (None, to_lang)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # Send the HTTP POST request to the Cloud Function</span><br><span class="line">    response = requests.post(endpoint, headers=headers, files=files, timeout=10)</span><br><span class="line"></span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<h2 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h2><p>Flask 使用 Jinja2 模板将内容渲染回浏览器。这些是包含嵌入代码的 HTML 文件。当我们从 中 app.py 调用 render_template() 时，我们会传入一些变量，然后在模板中引用这些变量。</p>
<h2 id="启动和调试"><a href="#启动和调试" class="headerlink" title="启动和调试"></a>启动和调试</h2><p>我们可以通过以下几种方式在本地启动 Flask 应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd app/ui_cr/</span><br><span class="line">source ../../scripts/setup.sh  # Initialise vars if we&#x27;re in a new terminal</span><br><span class="line"></span><br><span class="line"># Run the Flask App</span><br><span class="line">python app.py</span><br><span class="line"></span><br><span class="line"># Or with the Flask command.</span><br><span class="line"># This will automatically load any environment vars starting FLASK_</span><br><span class="line"># The --debug tells Flask to automatically reload after any changes</span><br><span class="line"># and to set the app.logger to debug.</span><br><span class="line">python -m flask --app app run --debug</span><br></pre></td></tr></table></figure>

<p>此外，如果要使用 VS Code 交互式调试器，我建议创建如下所示的启动配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Python Debugger: Flask&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;debugpy&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;module&quot;: &quot;flask&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/app/ui_cr&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;</span><br><span class="line">                &quot;FLASK_APP&quot;: &quot;app.py&quot;,</span><br><span class="line">                &quot;FLASK_DEBUG&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;FLASK_RUN_PORT&quot;: &quot;8080&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;run&quot;,</span><br><span class="line">                &quot;--debug&quot;,</span><br><span class="line">                &quot;--no-debugger&quot;,</span><br><span class="line">                &quot;--no-reload&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;jinja&quot;: true,</span><br><span class="line">            &quot;autoStartBrowser&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        // Other configurations</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试应用程序"><a href="#测试应用程序" class="headerlink" title="测试应用程序"></a>测试应用程序</h2><p>好了，我们就可以运行应用程序了！</p>
<p><img src="/../asset_serveless_ai/21.png"></p>
<p> 启动 Flask 应用程序</p>
<p>以下是它在浏览器中的样子：</p>
<p><img src="/../asset_serveless_ai/22.png"></p>
<p> 运行应用程序</p>
<p>让我们用它来翻译我们的乌克兰模因：</p>
<p><img src="/../asset_serveless_ai/23.png"></p>
<p> 它有效！</p>
<p> 万岁！</p>
<h1 id="部署到-Google-Cloud-Run"><a href="#部署到-Google-Cloud-Run" class="headerlink" title="部署到 Google Cloud Run"></a>部署到 Google Cloud Run</h1><p>现在，我们已准备好将 Flask 应用程序部署到 Cloud Run。回想一下，Cloud Run 是一个无服务器容器运行时，因此我们需要先将应用程序打包为容器映像，然后才能部署它。</p>
<p>我们将运行以下步骤：</p>
<ol>
<li>创建一个 Google Artifact Registry （GAR） 存储库，用于存储我们的 Flask 应用容器映像。</li>
<li>使用 Cloud Build 从源代码构建容器映像并存储在 GAR 中。</li>
<li>将我们的应用程序从 GAR 部署到 Cloud Run。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud artifacts repositories create image-text-translator-artifacts \</span><br><span class="line">  --repository-format=docker \</span><br><span class="line">  --location=$REGION \</span><br><span class="line">  --project=$PROJECT_ID</span><br></pre></td></tr></table></figure>

<p><img src="/../asset_serveless_ai/24.png"></p>
<p> 构建存储库</p>
<p>您可以在 Cloud Console 中检查存储库是否已创建：</p>
<p><img src="/../asset_serveless_ai/25.png"></p>
<p> 工件注册表</p>
<p>现在构建 Docker 映像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export IMAGE_NAME=$REGION-docker.pkg.dev/$PROJECT_ID/image-text-translator-artifacts/image-text-translator-ui</span><br><span class="line"></span><br><span class="line"># configure Docker to use the Google Cloud CLI to authenticate requests to Artifact Registry.</span><br><span class="line">gcloud auth configure-docker $REGION-docker.pkg.dev</span><br><span class="line"></span><br><span class="line"># Build the image and push it to Artifact Registry</span><br><span class="line"># Run from the ui_cr folder</span><br><span class="line">gcloud builds submit --tag $IMAGE_NAME:v0.1 .</span><br></pre></td></tr></table></figure>

<p>这需要一分钟左右的时间。现在，我们的容器映像已被推送到存储库：</p>
<p><img src="/../asset_serveless_ai/26.png"></p>
<p>Google Artifact Registry 中的容器映像</p>
<p>最后，我们可以使用映像部署到 Cloud Run。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># create a random secret key for our Flask application</span><br><span class="line">export RANDOM_SECRET_KEY=$(openssl rand -base64 32)</span><br><span class="line"></span><br><span class="line">gcloud run deploy image-text-translator-ui \</span><br><span class="line">  --image=$IMAGE_NAME:v0.1 \</span><br><span class="line">  --region=$REGION \</span><br><span class="line">  --platform=managed \</span><br><span class="line">  --allow-unauthenticated \</span><br><span class="line">  --max-instances=1 \</span><br><span class="line">  --service-account=$SVC_ACCOUNT \</span><br><span class="line">  --set-env-vars BACKEND_GCF=$BACKEND_GCF,FLASK_SECRET_KEY=$RANDOM_SECRET_KEY</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<p><img src="/../asset_serveless_ai/27.png"></p>
<p> 部署到 Cloud Run</p>
<p>我们可以验证我们的服务是否已部署在 Google Cloud 控制台中：</p>
<p><img src="/../asset_serveless_ai/28.png"></p>
<p> 我们的 Cloud Run 服务</p>
<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>如果我们想部署应用程序的新版本，我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Check our IMAGE_NAME is set</span><br><span class="line">export IMAGE_NAME=$REGION-docker.pkg.dev/$PROJECT_ID/image-text-translator-artifacts/image-text-translator-ui</span><br><span class="line"># Set our new version number</span><br><span class="line">export VERSION=v0.2</span><br><span class="line"></span><br><span class="line"># Rebuild the container image and push to the GAR</span><br><span class="line">gcloud builds submit --tag $IMAGE_NAME:$VERSION .</span><br><span class="line"></span><br><span class="line"># create a random secret key for our Flask application</span><br><span class="line">export RANDOM_SECRET_KEY=$(openssl rand -base64 32)</span><br><span class="line"></span><br><span class="line"># Redeploy</span><br><span class="line">gcloud run deploy image-text-translator-ui \</span><br><span class="line">  --image=$IMAGE_NAME:$VERSION \</span><br><span class="line">  --region=$REGION \</span><br><span class="line">  --platform=managed \</span><br><span class="line">  --allow-unauthenticated \</span><br><span class="line">  --max-instances=1 \</span><br><span class="line">  --service-account=$SVC_ACCOUNT \</span><br><span class="line">  --set-env-vars BACKEND_GCF=$BACKEND_GCF,FLASK_SECRET_KEY=$RANDOM_SECRET_KEY</span><br></pre></td></tr></table></figure>

<h2 id="（可选）设置自定义-DNS-映射"><a href="#（可选）设置自定义-DNS-映射" class="headerlink" title="（可选）设置自定义 DNS 映射"></a>（可选）设置自定义 DNS 映射</h2><p>像 <a target="_blank" rel="noopener" href="https://image-text-translator-ui-adisqviovq-ez.a.run.app/">https://image-text-translator-ui-adisqviovq-ez.a.run.app/</a> 这样的 URL 不是很令人难忘！因此，您可能希望映射到自定义域。您可以在此处找到详细的指南。</p>
<blockquote>
<p>此时，我发现 Cloud Run 不支持该区域 europe-west2 的域映射。因此，我最终使用 europe-west4 .</p>
</blockquote>
<p>假设您已经创建了子域 image-text-translator.mydomain.com ，并且想要将此地址用于应用程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Verify your domain ownership with Google</span><br><span class="line">gcloud domains verify mydomain.com</span><br><span class="line"># Check it</span><br><span class="line">gcloud domains list-user-verified</span><br><span class="line"></span><br><span class="line"># Create a mapping to your domain</span><br><span class="line">gcloud beta run domain-mappings create \</span><br><span class="line">  --region $REGION \</span><br><span class="line">  --service image-text-translator-ui \</span><br><span class="line">  --domain image-text-translator.mydomain.com</span><br></pre></td></tr></table></figure>

<p><img src="/../asset_serveless_ai/29.png"></p>
<p>创建域映射的输出</p>
<p>现在我们需要获取此域映射的 DNS 记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Obtain the DNS records. We want everything under `resourceRecords`.</span><br><span class="line">gcloud beta run domain-mappings describe \</span><br><span class="line">  --region $REGION \</span><br><span class="line">  --domain image-text-translator.mydomain.com</span><br></pre></td></tr></table></figure>

<p>获取 下 resourceRecords 显示的任何 DNS 记录，并在 DNS 注册机构中创建这些 DNS 记录。对我来说，只有一条 CNAME 记录需要添加：</p>
<p><img src="/../asset_serveless_ai/30.png"></p>
<p> 要添加的 DNS 记录</p>
<p>DNS 记录的传播以及 Google 配置托管 SSL 证书可能需要相当长的时间。对我来说，花了将近两个小时。</p>
<p>在等待期间，您可以使用以下工具检查进度：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a></li>
</ul>
<p>但最后……这一切都在我的域中工作！</p>
<p><img src="/../asset_serveless_ai/31.png"></p>
<p>从您的域运行应用</p>
<h1 id="定价和成本管理"><a href="#定价和成本管理" class="headerlink" title="定价和成本管理"></a>定价和成本管理</h1><p>在撰写本文时…</p>
<h2 id="Google-Cloud-函数"><a href="#Google-Cloud-函数" class="headerlink" title="Google Cloud 函数"></a>Google Cloud 函数</h2><p>成本是函数调用、使用的计算和网络出口的总和。</p>
<ul>
<li>每个月的前 100 万次计算秒数是免费的，前 200 万次函数调用也是免费的。</li>
<li>前 400,000 GB 秒和前 200,000 GHz 秒的计算时间是免费的。</li>
<li>此外，由于 Cloud Functions 在不使用时会缩放到 0，因此对于零星或低利用率的工作负载来说，这可能非常经济高效。</li>
</ul>
<h2 id="Google-Cloud-Run（谷歌云运行酒店）"><a href="#Google-Cloud-Run（谷歌云运行酒店）" class="headerlink" title="Google Cloud Run（谷歌云运行酒店）"></a>Google Cloud Run（谷歌云运行酒店）</h2><p>成本是所用 CPU 和内存的组合。</p>
<ul>
<li>前 240000 vCPU 秒每月免费。之后，计算按每 vCPU 秒 0.00001800 USD 收费。</li>
<li>前 450,000 GiB 秒每月免费。之后，内存按 0.000000200 USD&#x2F;GiB 秒收费</li>
<li>由于 Cloud Run 在不使用时会扩展到 0，因此这对于零星或低利用率的工作负载来说可能非常经济高效。</li>
</ul>
<h2 id="Cloud-Vision-API"><a href="#Cloud-Vision-API" class="headerlink" title="Cloud Vision API"></a>Cloud Vision API</h2><p>每个月免费对每个图像进行前 1000 次文本检测。之后，每 1.50 张图像收费 1000 美元。</p>
<h2 id="云翻译-API"><a href="#云翻译-API" class="headerlink" title="云翻译 API"></a>云翻译 API</h2><p>每个月前 050 万个字符免费，用于检测和翻译呼叫。之后，它按每百万个字符 20 美元收费。</p>
<h2 id="一些成本控制策略"><a href="#一些成本控制策略" class="headerlink" title="一些成本控制策略"></a>一些成本控制策略</h2><p>应考虑实施以下成本控制策略：</p>
<ul>
<li>在结算帐号中设置预算提醒。如果超过预算阈值（例如 50%、75%、90%、100%），您将收到电子邮件通知。注意：这不会限制您的支出。它只是在达到阈值时提醒您。</li>
<li>限制自动缩放。虽然 Cloud Run 和 Cloud Functions 都是无服务器自动缩放服务，但我预计我的小应用程序不会有任何重大需求。因此，我将 Cloud Function 和 Cloud Run 服务都设置为 max-instances 1。这意味着每个服务永远不会部署多个并发实例。</li>
<li>更复杂的策略：当超出预算时，向 Pub&#x2F;Sub 发送通知。 使用 Pub&#x2F;Sub 事件触发云函数，然后将项目与计费帐户分离，从而有效地禁用项目中的所有资源。</li>
</ul>
<h1 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h1><p>扩展到 0 的无服务器服务的缺点之一是，如果需求较低且零星，则通常不会有正在运行的服务实例。对于Cloud Functions来说，这并不是一个真正的问题，因为Cloud Functions是超轻量级的，启动速度非常快。但是我们的 Cloud Run Flask 应用程序稍大一些，冷启动可能需要几秒钟。因此，我们的用户在访问页面时会发现应用程序很慢。</p>
<p>有几种策略可以通过 Cloud Run 处理此问题：</p>
<ol>
<li>我们可以将最小实例配置为 1。如果我们这样做，我们的 Cloud Run 服务将永远不会扩展到 0。总会有一个实例准备好处理请求。但是，这意味着我们将为此实例付费……一直以来。这通常是一个很好的策略。但是对于我点头的低利用率应用程序，我真的不想这样做。</li>
<li>我们可以配置 Cloud Run 启动 CPU 提升。在这里，Google Cloud 在启动期间为我们的 Cloud Run 容器动态分配更多 CPU，这可以显着缩短我们的启动时间。而且，由于这些额外的 CPU 仅分配给那些不频繁的冷启动，因此它通常比保持实例一直运行更具成本效益。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcloud beta run services update image-text-translator-ui \</span><br><span class="line">  --region=$REGION --cpu-boost</span><br></pre></td></tr></table></figure>

<p>此外，请检查 Flask 应用程序是否未在启用调试的情况下部署。这肯定会影响您的启动时间！</p>
<h1 id="一些常见问题、一般观察和提示"><a href="#一些常见问题、一般观察和提示" class="headerlink" title="一些常见问题、一般观察和提示"></a>一些常见问题、一般观察和提示</h1><h2 id="生成式人工智能！"><a href="#生成式人工智能！" class="headerlink" title="生成式人工智能！"></a>生成式人工智能！</h2><p>当然，我需要再次提到Gen AI！！虽然我没有在实际解决方案中使用任何 Gen AI，但我在构建解决方案时大量使用它来获得建议和答案。特别是，我与 Gemini Code Assist（包含在 VS Code 的 Cloud Code 插件中）和 ChatGPT 4 进行了多次对话。我估计，使用这些工具解决问题已经消除了我总时间和精力的 40%。</p>
<h2 id="为什么同时使用-Cloud-Run-和-Cloud-Functions？"><a href="#为什么同时使用-Cloud-Run-和-Cloud-Functions？" class="headerlink" title="为什么同时使用 Cloud Run 和 Cloud Functions？"></a>为什么同时使用 Cloud Run 和 Cloud Functions？</h2><p>为什么不只包含从我的 Flask 应用程序提取和翻译 API 调用？这样我就完全不需要 Cloud Functions。</p>
<p> 原因有二：</p>
<ol>
<li>我想将提取和翻译逻辑与 UI 分离。这样一来，如果我想更换 UI 或添加另一个 UI（例如移动应用程序），我仍然可以在不更改它的情况下使用我的 Cloud Function。</li>
<li>我想构建一个需要集成两个无服务器组件的应用程序。这样，我就可以演示一个如何调用另一个，还可以演示其他必要的元素，例如使用服务帐户。</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>大功告成！让我们回顾一下我们取得的成就：</p>
<ul>
<li>我们创建了一个 Google Cloud 项目来托管我们的应用程序。</li>
<li>我们建立了一个本地开发项目和环境。</li>
<li>我们定义了一个服务帐户并为其分配了角色。</li>
<li>我们配置了应用程序默认凭据，以便我们的代码可以在部署到的任何环境中查找凭据。</li>
<li>我们构建了一个 Google Cloud 函数（在 Python 中），用于接收图像数据，从图像中提取任何文本，然后将其翻译成任何指定的语言。我们通过调用 Google 的预制 AI API 来做到这一点。</li>
<li>我们已使用 Functions 框架在本地测试了 Cloud Function。</li>
<li>我们已将云功能部署到 GCP 并对其进行了测试。它只能由经过身份验证和授权的客户端调用。</li>
<li>我们使用 Flask 构建了一个 Python Web 用户界面应用程序。</li>
<li>我们使用 HTML Jinja 模板、CSS 样式表和 Javascript 构建了一个前端。</li>
<li>我们已将 Flask Web 应用程序配置为能够对函数进行经过身份验证的调用。</li>
<li>在本地测试 Flask 应用后，我们使用 Google Cloud Build 将应用打包为容器映像。</li>
<li>我们已将该图像推送到 Google Artifact Registry。</li>
<li>我们已从 Artifact Registry 部署到 Cloud Run。</li>
<li>我们已使用自己的域名公开了我们的 Cloud Run 服务。</li>
<li>我们回顾了一些成本管理最佳实践和控制措施。</li>
<li>我们实施了 cpu-boost 加速 Cloud Run 的冷启动。</li>
</ul>
<p><img src="/../asset_serveless_ai/32.gif"></p>
<p> 唷！</p>
<p>这很有趣！我希望你也喜欢它！</p>
<h1 id="下一步是什么？"><a href="#下一步是什么？" class="headerlink" title="下一步是什么？"></a>下一步是什么？</h1><p>我将跟进第二部分。在第 2 部分中，我将介绍：</p>
<ul>
<li>使用 Terraform 部署我们的 Google Cloud 基础架构。</li>
<li>设置 CI&#x2F;CD 管道，以自动生成和部署更改。</li>
<li>其他一些应用程序增强功能。</li>
</ul>
<h1 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h1><ul>
<li>请与您认为会感兴趣的任何人分享。它可能会帮助他们，它真的帮助了我！</li>
<li>请给我鼓掌！你知道你不止一次鼓掌，对吧？</li>
<li>随意发表评论💬。</li>
<li>关注并订阅，这样您就不会错过我的内容。转到我的个人资料页面，然后单击以下图标：</li>
</ul>
<p><img src="/../asset_serveless_ai/33.png"></p>
<p> 关注并订阅</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><ul>
<li><a target="_blank" rel="noopener" href="https://image-text-translator.just2good.co.uk/">https://image-text-translator.just2good.co.uk/</a></li>
</ul>
<h2 id="应用程序的源代码"><a href="#应用程序的源代码" class="headerlink" title="应用程序的源代码"></a>应用程序的源代码</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/derailed-dash/image-text-translator">GitHub 中的源代码存储库</a></li>
</ul>
<h2 id="开发设置"><a href="#开发设置" class="headerlink" title="开发设置"></a>开发设置</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/sdk/docs/install"> Gcloud CLI 设置</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/python/docs/setup">适用于 Gcloud CLI 的 Python 设置</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode">适用于 VS Code 的云代码</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/python/tutorial-flask">VS Code：示例 Python 烧瓶教程</a></li>
</ul>
<h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><ul>
<li>使用 Python 设置和调用 Cloud Functions，包括本地开发</li>
<li>适用于 Python 的 Functions 框架 — 适用于本地开发</li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/terraform-ml-image-annotation-gcf">Cloud Functions — 图像注释</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/calling/http">Cloud Functions — HTTP 触发器</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/tutorials/ocr">OCR 和 CF 翻译</a></li>
</ul>
<h2 id="云运行"><a href="#云运行" class="headerlink" title="云运行"></a>云运行</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode/create-service">在 VS Code 中从示例应用程序创建 Cloud Run 服务Create a Cloud Run service from a sample application in VS Code</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode/develop-service">在 Cloud Code 中本地开发云运行服务</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/code/docs/vscode/debug-service">在 VS Code 中调试云运行</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/run/helloworld">Cloud Run — Hello World</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/tree/main/run/image-processing">Cloud Run — 图像处理</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/run/docs/mapping-custom-domains">将自定义域映射到 Cloud Run 服务</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/run?utm_source=google&utm_medium=cpc&utm_campaign=emea-gb-all-en-dr-skws-all-all-trial-%7Bmatchtype%7D-gcp-1707574&utm_content=text-ad-none-any-DEV_%7Bdevice%7D-CRE_%7Bcreative%7D-ADGP_%7B_dsadgroup%7D-KWID_%7B_dstrackerid%7D-%7Btargetid%7D-userloc_%7Bloc_physical_ms%7D&utm_term=KW_%7Bkeyword%7D-NET_%7Bnetwork%7D-PLAC_%7Bplacement%7D&%7B_dsmrktparam%7D%7Bignore%7D=&%7B_dsmrktparam%7D=&gclsrc=aw.ds&gad_source=1&gclid=CjwKCAjw-O6zBhASEiwAOHeGxWZDg7nObT9R0wHudfnP1YHPkCpAq7PFfcyV7QBKZNQjp6jpgO2g0hoCLzcQAvD_BwE&hl=en#pricing"> Cloud Run 定价</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/blog/products/serverless/announcing-startup-cpu-boost-for-cloud-run--cloud-functions">云运行启动 CPU 提升</a></li>
</ul>
<h2 id="AI-ML-API"><a href="#AI-ML-API" class="headerlink" title="AI&#x2F;ML API"></a>AI&#x2F;ML API</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/vision/docs/ocr">视觉 API — 检测图像中的文本</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/vision/pricing">Google Cloud Vision API 定价</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/translate/docs/basic/translating-text">翻译 API — 翻译文本</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/translate/pricing/?gad_source=1&gclid=CjwKCAjw-O6zBhASEiwAOHeGxdMh6YLV1qcoix8_RgmX5O8Ql2HTmUdPBBX-ckt1bDnothunMt_u4hoCk8kQAvD_BwE&gclsrc=aw.ds">Google Cloud Translation API 定价</a></li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/docs/authentication/application-default-credentials">Appication 默认凭据的工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/docs/authentication/provide-credentials-adc#local-dev">设置应用程序默认凭据</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/blob/main/auth/service-to-service/auth.py">Python 服务到服务身份验证</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/securing/managing-access-iam#gcloud">管理对函数的访问</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/functions/docs/securing/authenticating">Cloud Functions：对调用进行身份验证</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/run/docs/securing/service-identity">Cloud Run：服务标识</a></li>
<li>Cloud Run：对服务到服务进行身份验证 — 创建服务帐户;获取 Google 签名的 ID 令牌，并将该令牌添加到标头。</li>
</ul>
<h2 id="DNS-和-SSL-配置"><a href="#DNS-和-SSL-配置" class="headerlink" title="DNS 和 SSL 配置"></a>DNS 和 SSL 配置</h2><ul>
<li><a target="_blank" rel="noopener" href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://medium.com/google-cloud/building-a-serverless-image-text-extractor-and-translator-using-google-cloud-pre-trained-ai-adfdccdb18d9">使用 Google Cloud 预训练 AI 构建无服务器图像文本提取器和翻译器 |by 达兹博 （Darren Lester） |Google Cloud - 社区 |2024年6月 |中等 — Building a Serverless Image Text Extractor and Translator Using Google Cloud Pre-Trained AI | by Dazbo (Darren Lester) | Google Cloud - Community | Jun, 2024 | Medium</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/06/20/erp-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/20/erp-introduce/" class="post-title-link" itemprop="url">ERP介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-06-20 10:22:06 / 修改时间：10:38:26" itemprop="dateCreated datePublished" datetime="2024-06-20T10:22:06+08:00">2024-06-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在技术驱动的世界中，在线开展业务并对其进行管理是日常业务活动不可或缺的一部分。</p>
<p>ERP（企业资源规划）是帮助企业进行数字化转型、提高利润率、升级服务并提供增强客户体验的解决方案。它不仅有助于自动化工作流程，还简化了业务流程。</p>
<h2 id="什么是ERP？"><a href="#什么是ERP？" class="headerlink" title="什么是ERP？"></a>什么是ERP？</h2><p>ERP 是企业资源规划的缩写，是一种软件应用程序，可帮助管理组织的核心活动，例如供应链流程、财务管理、风险和合规管理等等。它有效地帮助规划、管理、预测和报告组织的整体活动，同时确保整个业务流程的透明度。</p>
<p>ERP系统帮助组织的不同部门进行无缝协作和沟通，确保成本效益和生产力。</p>
<p>ERP系统主要有三种类型，即：本地ERP，基于云的ERP和混合ERP系统。</p>
<h2 id="ERP系统的组件"><a href="#ERP系统的组件" class="headerlink" title="ERP系统的组件"></a>ERP系统的组件</h2><p>ERP系统有五个关键组成部分，它们如下：</p>
<p><img src="/../asset_erpintroduce/01.png"></p>
<ul>
<li>客户关系管理（CRM）</li>
<li>金融</li>
<li>人力资源管理（HRM）</li>
<li>制造和物流</li>
<li>供应链管理 （SCM）</li>
</ul>
<h3 id="客户关系管理（CRM）"><a href="#客户关系管理（CRM）" class="headerlink" title="客户关系管理（CRM）"></a>客户关系管理（CRM）</h3><p>该系统使用客户的个人信息、购买历史、使用模式等相关数据与客户互动，以提供个性化的服务和建议，从而增加销售额并提高客户满意度。</p>
<h3 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h3><p>它是每个组织的核心流程和基础之一，ERP 解决方案有助于轻松监控和管理您的所有财务活动，如应收账款和应付账款、经常性成本、预算、总账等。<br>它有助于优化现金流、减少损失和提高业务的盈利能力，从而使您能够简化复杂的会计流程。</p>
<h3 id="人力资源管理（HRM）"><a href="#人力资源管理（HRM）" class="headerlink" title="人力资源管理（HRM）"></a>人力资源管理（HRM）</h3><p>它是一个重要的ERP模块，有助于有效管理人力资源，其中包括组织从下到上层次结构中的每个员工。<br>它有助于处理所有与员工相关的任务，例如考勤管理、工资单管理、绩效报告、员工详细信息等等。</p>
<h3 id="制造和物流"><a href="#制造和物流" class="headerlink" title="制造和物流"></a>制造和物流</h3><p>它是开源 ERP 系统中最重要和最复杂的组件之一，它使您能够战略性地计划、生产&#x2F;包装、运输和交付产品给客户，从而确保无缝的订单履行流程。<br>它使您能够清楚地了解组织每项活动的实时进度，同时在指尖有效地管理它们。</p>
<h3 id="供应链管理-（SCM）"><a href="#供应链管理-（SCM）" class="headerlink" title="供应链管理 （SCM）"></a>供应链管理 （SCM）</h3><p>这是ERP系统的另一个重要组成部分，它通过确保每个必需的资源都可用来促进货物的无缝生产。它通过收集实时信息来帮助优化制造和分销过程，从而提高您的服务效率。</p>
<p>ERP系统还有其他附加模块，包括库存管理、电子商务、营销自动化、仓库管理、订单管理、项目管理、采购等，有助于自动化工作流程并简化所有业务流程。</p>
<h2 id="ERP对企业有什么好处"><a href="#ERP对企业有什么好处" class="headerlink" title="ERP对企业有什么好处"></a>ERP对企业有什么好处</h2><p>ERP系统可帮助您优化业务运营和活动，并满足其他一些好处，其中包括以下内容：</p>
<p><img src="/../asset_erpintroduce/02.png"></p>
<ul>
<li>准确的报告和分析</li>
<li>集中式数据</li>
<li>节省成本</li>
<li>数据安全与合规</li>
<li>提高生产力</li>
<li>可扩展性和灵活性</li>
</ul>
<h3 id="准确的报告和分析-–"><a href="#准确的报告和分析-–" class="headerlink" title="准确的报告和分析 –"></a>准确的报告和分析 –</h3><p>ERP 的第一个也是最重要的好处是，它可以帮助您根据您的业务需求和要求、客户的购买模式、搜索趋势和其他几个方面提供详细的报告，您可以分析这些方面为您的客户提供优质的服务以及最大的客户满意度，同时使您能够在需要时改进您的服务。</p>
<h3 id="集中式数据-–"><a href="#集中式数据-–" class="headerlink" title="集中式数据 –"></a>集中式数据 –</h3><p>ERP使您能够在一个集中的位置管理所有业务数据，这意味着您可以随时随地访问它。它可以帮助您了解最新的市场趋势和消费者偏好，从而进一步增强您企业的决策过程。</p>
<h3 id="节省成本-–"><a href="#节省成本-–" class="headerlink" title="节省成本 –"></a>节省成本 –</h3><p>ERP解决方案的另一个重要好处是，它有助于自动化整个业务流程和工作流程，从而消除手动和重复性任务，这反过来又有助于节省相关成本，同时最大限度地减少错误，并使您的业务服务更加省时和具有成本效益。</p>
<h3 id="数据安全与合规-–"><a href="#数据安全与合规-–" class="headerlink" title="数据安全与合规 –"></a>数据安全与合规 –</h3><p>它还通过实施多层安全协议、防火墙、身份验证方法和其他安全措施，帮助保护敏感信息免受可能的网络攻击，从而确保安全的工作流程和业务流程。</p>
<p>此外，它还有助于遵守财务标准和法规以及其他必要的法规遵从性。</p>
<h3 id="提高生产力-–"><a href="#提高生产力-–" class="headerlink" title="提高生产力 –"></a>提高生产力 –</h3><p>它还有助于通过简化一个屋檐下的协作和通信环境来提高团队的生产力。它确保了团队成员之间的透明度，并实现了工作流程的自动化，从而减少了繁琐的手动工作，同时减少了错误或没有错误，从而确保了高质量的工作和服务。</p>
<h3 id="可扩展性和灵活性-–"><a href="#可扩展性和灵活性-–" class="headerlink" title="可扩展性和灵活性 –"></a>可扩展性和灵活性 –</h3><p>ERP还提供灵活性，这意味着您可以根据自己的要求构建自定义工作流程，并支持您独特的业务流程和服务。它还随着业务的增长进行相应的调整，使您的业务具有可扩展性，从而适应不断增长的用户群和业务需求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/06/04/ai-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/04/ai-integration/" class="post-title-link" itemprop="url">如何在应用程序中集成AI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-04 20:26:26" itemprop="dateCreated datePublished" datetime="2024-06-04T20:26:26+08:00">2024-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-05 16:30:38" itemprop="dateModified" datetime="2024-06-05T16:30:38+08:00">2024-06-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于许多企业拥有运行多年的大型复杂系统，对它们进行重大更改是有风险且昂贵的。</p>
<p>本文讨论如何将人工智能添加到现有的应用程序中，即使这些应用程序很难或不可能更改。我们将探讨实现这一目标的实际方法。</p>
<h2 id="业务用例"><a href="#业务用例" class="headerlink" title="业务用例"></a>业务用例</h2><p>我们模拟一个供应链管理公司，它有多个部门，每个部门都暴露自己的 REST API，要得到一个查询的答案，必须通过这些部门的 API 和数据库调用。我们将引入人工智能，但保持所有现有流程不变。</p>
<p><img src="/../asset_aiintegration/01.png"></p>
<p>该公司的中央部门是“Data Processing System”，负责数据管理和处理的核心操作。它通过不同的接口与其他各部门进行交互。 “Client Call”组件代表客户请求或查询进入系统的入口点。然后将这些请求传递给“Data Processing System”进行处理。该“Data Processing System”系统还与“Central Data Management”组件通信，后者作为管理和存储与供应链操作相关数据的集中存储库。</p>
<p>“Company Data Handling System”是另一个关键部门，包括一个“Data Retrieval Server”。该服务器存储和管理公司的内部数据，其中包括有关库存、订单、物流和其他运营细节的信息。 “AI Integration System” 组件专门设计用于将人工智能功能集成到现有系统中。它与“Company Data Handling System”互动，并间接访问“Central Data Management”组件，使其能够利用来自多个来源的数据进行基于 AI 的决策或自动化。</p>
<p>“Mapping System” 部门连接到包含有地理数据、路由信息以及与供应链映射和物流相关的其他细节的“Supply Chain Mapping DB”（数据库）。“System Admin Dashboard”允许授权员工登录并访问管理功能或监控系统性能。该仪表板与“AI Integration System”互动，以提供洞见、报告或对 AI 功能进行控制。</p>
<p>最后，“REST API call”组件公开了一个 RESTful API，允许外部系统或应用与其交互，并可能利用其功能或数据。</p>
<h2 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/szhowardhuang/ai_integration</span><br><span class="line"><span class="built_in">cd</span> ai_integration</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="客户端界面-dashboard-py"><a href="#客户端界面-dashboard-py" class="headerlink" title="客户端界面 dashboard.py"></a>客户端界面 dashboard.py</h2><h3 id="LLM客户端"><a href="#LLM客户端" class="headerlink" title="LLM客户端"></a>LLM客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client = Groq(api_key=os.getenv(<span class="string">&#x27;GROQ_API_KEY&#x27;</span>))</span><br><span class="line">MODEL = <span class="string">&#x27;mixtral-8x7b-32768&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>申请Groq的API，并配置好LLM模型 mixtral</li>
</ul>
<h3 id="定义-get-supply-chain-data-函数"><a href="#定义-get-supply-chain-data-函数" class="headerlink" title="定义 get_supply_chain_data 函数"></a>定义 get_supply_chain_data 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_supply_chain_data</span>(<span class="params">query</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the supply chain data for a given query by calling the Flask API.&quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">f&#x27;http://127.0.0.1:5000/supply-chain-data?query=<span class="subst">&#123;query&#125;</span>&#x27;</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> json.dumps(response.json())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> json.dumps(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;API request failed&quot;</span>, <span class="string">&quot;status_code&quot;</span>: response.status_code&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此函数通过向 Flask API 端点发出 HTTP GET 请求来检索供应链数据。</p>
</li>
<li><p>它需要一个 query 参数，该参数代表与供应链活动相关的查询。</p>
</li>
<li><p>URL 是使用提供的查询参数构建的。</p>
</li>
<li><p>该函数检查响应状态码。如果是 200（OK），则返回响应的 JSON 表示。否则，返回一个包含错误消息和状态码的 JSON 对象。</p>
</li>
</ul>
<h3 id="定义-run-conversation-函数"><a href="#定义-run-conversation-函数" class="headerlink" title="定义 run_conversation 函数"></a>定义 run_conversation 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_conversation</span>(<span class="params">user_prompt</span>):</span><br><span class="line">    messages = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a function calling LLM that uses the data extracted from the get_supply_chain_data function to answer questions related to supply chain management. Include the relevant supply chain activity and data in your response.&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: user_prompt,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    tools = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_supply_chain_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Get the supply chain data for a given query&quot;</span>,</span><br><span class="line">                <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The query related to a supply chain activity&quot;</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;query&quot;</span>],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此函数管理用户和 AI 模型之间的对话。</p>
</li>
<li><p>它准备好消息，包括系统消息和用户消息，其中包含它们的提示词。</p>
</li>
<li><p>它准备了 AI 模型在对话过程中可以使用的工具。包括一个名为“get_supply_chain_data”的函数，以及它的描述和参数。</p>
</li>
</ul>
<h3 id="Gradio-界面设置"><a href="#Gradio-界面设置" class="headerlink" title="Gradio 界面设置"></a>Gradio 界面设置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">background_path = os.path.join(os.getcwd(), <span class="string">&#x27;images&#x27;</span>, <span class="string">&#x27;background.png&#x27;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> gr.Blocks(css=<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...CSS Styling...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) <span class="keyword">as</span> demo:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此部分为用户交互设置了 Gradio 界面。</p>
</li>
<li><p>它构建了界面中背景图像的路径。</p>
</li>
<li><p>界面布局和样式是在 gr.Blocks 上下文管理器中使用 CSS 定义的。</p>
</li>
</ul>
<h3 id="Gradio-界面组件"><a href="#Gradio-界面组件" class="headerlink" title="Gradio 界面组件"></a>Gradio 界面组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gr.Markdown(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;header&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Supply Chain Management Company&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Your AI-powered supply chain management&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">gr.Markdown(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;<span class="subst">&#123;background_path&#125;</span>&quot; class=&quot;background-image&quot;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> gr.Row():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了 Gradio 界面的组件，包括一个带有标题和描述的标题栏，以及一张图片。</p>
</li>
<li><p>标题提供有关供应链管理系统的信息。</p>
</li>
<li><p>图像作为界面的背景。</p>
</li>
</ul>
<h3 id="设置用户输入和输出组件"><a href="#设置用户输入和输出组件" class="headerlink" title="设置用户输入和输出组件"></a>设置用户输入和输出组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> gr.Row():</span><br><span class="line">    <span class="keyword">with</span> gr.Column(scale=<span class="number">1</span>):</span><br><span class="line">        user_input = gr.Textbox(</span><br><span class="line">            label=<span class="string">&quot;Enter your query&quot;</span>,</span><br><span class="line">            placeholder=<span class="string">&quot;Ask a question about supply chain management...&quot;</span>,</span><br><span class="line">            lines=<span class="number">3</span>,</span><br><span class="line">            elem_id=<span class="string">&quot;user-input&quot;</span></span><br><span class="line">        )</span><br><span class="line">        submit_button = gr.Button(<span class="string">&quot;Submit&quot;</span>, variant=<span class="string">&quot;primary&quot;</span>, elem_classes=<span class="string">&quot;submit-button&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> gr.Column(scale=<span class="number">2</span>):</span><br><span class="line">        output_text = gr.Textbox(</span><br><span class="line">            label=<span class="string">&quot;Response&quot;</span>,</span><br><span class="line">            lines=<span class="number">10</span>,</span><br><span class="line">            elem_id=<span class="string">&quot;output-text&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此部分在行列布局中设置了用户输入（文本框和提交按钮）和输出（文本框）的组件。</p>
</li>
<li><p>用户可以在文本框中输入与供应链管理相关的查询。</p>
</li>
<li><p>提交查询后，AI 模型的响应将显示在输出文本框中。</p>
</li>
</ul>
<h3 id="更新供应链统计数据"><a href="#更新供应链统计数据" class="headerlink" title="更新供应链统计数据"></a>更新供应链统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stats_text = gr.Text(value=<span class="string">&quot;Loading...&quot;</span>, label=<span class="string">&quot;Supply Chain Stats&quot;</span>, interactive=<span class="literal">False</span>, elem_classes=<span class="string">&quot;stats&quot;</span>)</span><br><span class="line"></span><br><span class="line">submit_button.click(</span><br><span class="line">    gradio_interface,</span><br><span class="line">    inputs=user_input,</span><br><span class="line">    outputs=output_text,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">threading.Thread(target=update_stats_text, daemon=<span class="literal">True</span>).start()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此部分初始化文本组件以显示供应链统计数据。</p>
</li>
<li><p>它为提交按钮设置了一个点击事件处理程序。当按钮被点击时，使用者输入调用 gradio_interface 函数，并在输出文本框中显示输出。</p>
</li>
<li><p>此外，它启动一个单独的线程，持续更新显示在界面上的供应链统计数据。</p>
</li>
</ul>
<h3 id="启动-Gradio-界面"><a href="#启动-Gradio-界面" class="headerlink" title="启动 Gradio 界面"></a>启动 Gradio 界面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.launch()</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，这一行启动了 Gradio 界面，使用户能够与 AI 驱动的供应链管理系统进行交互。</li>
</ul>
<h2 id="公司数据处理系统-data-retriever-py"><a href="#公司数据处理系统-data-retriever-py" class="headerlink" title="公司数据处理系统 data_retriever.py"></a>公司数据处理系统 data_retriever.py</h2><h3 id="导入库并设置日志"><a href="#导入库并设置日志" class="headerlink" title="导入库并设置日志"></a>导入库并设置日志</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> WordNetLemmatizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">nltk.download(<span class="string">&#x27;punkt&#x27;</span>)</span><br><span class="line">nltk.download(<span class="string">&#x27;stopwords&#x27;</span>)</span><br><span class="line">nltk.download(<span class="string">&#x27;wordnet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化词形还原器</span></span><br><span class="line">lemmatizer = WordNetLemmatizer()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>导入了必要的库，如 json ， os ， logging 和 requests 。</p>
</li>
<li><p>设置日志以跟踪程序执行过程中的信息、警告和错误。</p>
</li>
<li><p>载入NLP模型，并初始化词形还原器</p>
</li>
</ul>
<h3 id="定义-SupplyChainDataRetriever-类"><a href="#定义-SupplyChainDataRetriever-类" class="headerlink" title="定义 SupplyChainDataRetriever 类"></a>定义 SupplyChainDataRetriever 类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SupplyChainDataRetriever</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, database_folder, mapping_api_url=<span class="string">&#x27;http://localhost:5001/mapping&#x27;</span></span>):</span><br><span class="line">        self.database_folder = database_folder</span><br><span class="line">        self.query_mapping = self.fetch_query_mapping(mapping_api_url)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了一个名为 SupplyChainDataRetriever 的类，用于根据用户查询来检索供应链数据。</p>
</li>
<li><p>该类使用 database_folder 路径和可选的 mapping_api_url 进行查询映射初始化。</p>
</li>
</ul>
<h3 id="获取查询映射"><a href="#获取查询映射" class="headerlink" title="获取查询映射"></a>获取查询映射</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_query_mapping</span>(<span class="params">self, mapping_api_url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(mapping_api_url)</span><br><span class="line">        response.raise_for_status()</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error fetching query_mapping: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    logger.info(<span class="string">f&quot;SupplyChainDataRetriever instance created with database folder: <span class="subst">&#123;database_folder&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法从指定的 API 端点获取查询映射。</p>
</li>
<li><p>它向 mapping_api_url 发送 HTTP GET 请求并处理任何异常。</p>
</li>
<li><p>如果成功，它将返回包含查询映射的 JSON 响应。</p>
</li>
</ul>
<h3 id="检索供应链数据"><a href="#检索供应链数据" class="headerlink" title="检索供应链数据"></a>检索供应链数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_supply_chain_data</span>(<span class="params">self, query</span>):</span><br><span class="line">    query = query.lower()</span><br><span class="line">    logger.info(<span class="string">f&quot;Received query: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> activity, filename <span class="keyword">in</span> self.query_mapping.items():</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法根据用户的查询检索供应链数据。</p>
</li>
<li><p>它首先将查询转换为小写，以进行不区分大小写的匹配，并记录接收到的查询。</p>
</li>
<li><p>然后，它通过查询映射字典进行迭代，以找到查询和已知供应链活动之间的匹配。</p>
</li>
</ul>
<h3 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_text</span>(<span class="params">text</span>):</span><br><span class="line">    tokens  = re.split(<span class="string">r&#x27;[\s_]+&#x27;</span>, text)</span><br><span class="line">    <span class="comment"># 转为小写</span></span><br><span class="line">    tokens = [token.lower() <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</span><br><span class="line">    <span class="comment"># 去除停用词和词形还原</span></span><br><span class="line">    tokens = [lemmatizer.lemmatize(word) <span class="keyword">for</span> word <span class="keyword">in</span> tokens <span class="keyword">if</span> word.isalpha() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> stopwords.words(<span class="string">&#x27;english&#x27;</span>)]</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br></pre></td></tr></table></figure>

<ul>
<li>preprocess_text根据空格和下划线来分词，并进行词形还原</li>
</ul>
<h3 id="将查询与活动匹配"><a href="#将查询与活动匹配" class="headerlink" title="将查询与活动匹配"></a>将查询与活动匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本预处理</span></span><br><span class="line">activity_words = preprocess_text(activity)</span><br><span class="line">query_words = preprocess_text(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征提取：使用TF-IDF</span></span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">tfidf_matrix = vectorizer.fit_transform([<span class="string">&#x27; &#x27;</span>.join(activity_words), <span class="string">&#x27; &#x27;</span>.join(query_words)])</span><br><span class="line"><span class="comment"># 计算余弦相似度</span></span><br><span class="line">similarity_score = cosine_similarity(tfidf_matrix[<span class="number">0</span>:<span class="number">1</span>], tfidf_matrix[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Text Similarity Score: <span class="subst">&#123;similarity_score[<span class="number">0</span>][<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> similarity_score[<span class="number">0</span>][<span class="number">0</span>] &gt;= <span class="number">0.3</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这里，将活动和查询预处理，分成一组词。</p>
</li>
<li><p>使用余弦相似度比较活动和查询之间的相似度</p>
</li>
</ul>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_path = os.path.join(self.database_folder, filename)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        data = json.load(file)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    logger.error(<span class="string">f&quot;File not found: <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果找到匹配查询的活动，根据 database_folder 和文件名构建文件路径。</p>
</li>
<li><p>检查文件是否存在，如果存在，从文件中读取 JSON 数据并返回。</p>
</li>
<li><p>如果文件不存在，会记录一个错误消息。</p>
</li>
</ul>
<h3 id="处理没有匹配活动"><a href="#处理没有匹配活动" class="headerlink" title="处理没有匹配活动"></a>处理没有匹配活动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error_message = &#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;No data found for the given query&quot;</span>&#125;</span><br><span class="line">logger.warning(<span class="string">f&quot;No data found for query: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> error_message</span><br></pre></td></tr></table></figure>

<ul>
<li>如果未找到与查询匹配的活动，会记录一个警告并返回一个错误消息。</li>
</ul>
<h2 id="数据处理系统-server-py"><a href="#数据处理系统-server-py" class="headerlink" title="数据处理系统 server.py"></a>数据处理系统 server.py</h2><h3 id="导入库并设置日志记录"><a href="#导入库并设置日志记录" class="headerlink" title="导入库并设置日志记录"></a>导入库并设置日志记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> data_retriever <span class="keyword">import</span> SupplyChainDataRetriever</span><br><span class="line"><span class="keyword">import</span> logging</span><br></pre></td></tr></table></figure>

<ul>
<li>导入了必要的库，比如 Flask 用于创建 Web 应用程序，logging 用于在程序执行过程中跟踪信息、警告和错误。</li>
</ul>
<h3 id="初始化-Flask-应用程序和数据检索器"><a href="#初始化-Flask-应用程序和数据检索器" class="headerlink" title="初始化 Flask 应用程序和数据检索器"></a>初始化 Flask 应用程序和数据检索器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">data_retriever = SupplyChainDataRetriever(<span class="string">&#x27;database&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建了一个名为 app 的 Flask 应用实例。</p>
</li>
<li><p>实例化了一个名为 data_retriever 的 SupplyChainDataRetriever 对象，用于根据用户查询来检索供应链数据。传递了名为 ‘database’ 的文件夹，其中存储着包含数据的 JSON 文件。</p>
</li>
</ul>
<h3 id="用于供应链数据检索的-Flask-路由"><a href="#用于供应链数据检索的-Flask-路由" class="headerlink" title="用于供应链数据检索的 Flask 路由"></a>用于供应链数据检索的 Flask 路由</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/supply-chain-data&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">supply_chain</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Flask route to handle supply chain data retrieval requests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Query Parameters:</span></span><br><span class="line"><span class="string">        query (str): The user&#x27;s query related to a supply chain activity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        JSON response: The corresponding supply chain data or an error message.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    query = request.args.get(<span class="string">&#x27;query&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> query:</span><br><span class="line">        logger.error(<span class="string">&quot;Missing query parameter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;Missing query&#x27;</span>&#125;), <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Received query: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line">    data = data_retriever.get_supply_chain_data(query)</span><br><span class="line">    logger.info(<span class="string">f&quot;Returning data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了一个 Flask 路由 &#x2F;supply-chain-data 来处理作为 HTTP GET 请求发送的供应链数据检索请求。</p>
</li>
<li><p>路由声明一个名为 ‘query’ 的查询参数，该参数代表与供应链活动相关的用户查询。</p>
</li>
<li><p>如果缺少查询参数，会记录一个错误并返回一个带有错误消息和状态码 400（错误请求）的 JSON 响应。</p>
</li>
<li><p>记录接收到的查询，使用 data_retriever 对象检索相应的供应链数据，并用 JSON 响应来返回之前的记录数据。</p>
</li>
</ul>
<h3 id="启动-Flask-应用程序"><a href="#启动-Flask-应用程序" class="headerlink" title="启动 Flask 应用程序"></a>启动 Flask 应用程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logger.info(<span class="string">&quot;Starting Flask application&quot;</span>)</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果脚本直接执行（而不是作为模块导入），启动 Flask 应用程序。</p>
</li>
<li><p>记录了一条消息，表明 Flask 应用程序正在启动。</p>
</li>
<li><p>启动 Flask 开发服务器，并启用了调试模式，以便在开发过程中进行简单调试。</p>
</li>
</ul>
<p>以这种方式构建代码，使用 Flask 创建了一个网络服务，为用户查询提供基于供应链数据的 API 端点。日志配置确保为调试和监控目的记录相关信息。</p>
<h2 id="映射系统-mapping-server-py"><a href="#映射系统-mapping-server-py" class="headerlink" title="映射系统 mapping_server.py"></a>映射系统 mapping_server.py</h2><h3 id="定义-MappingAPI-类"><a href="#定义-MappingAPI-类" class="headerlink" title="定义 MappingAPI 类"></a>定义 MappingAPI 类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingAPI</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mapping_file_path=<span class="literal">None</span></span>):</span><br><span class="line">        self.app = Flask(__name__)</span><br><span class="line">        self.app.add_url_rule(<span class="string">&#x27;/mapping&#x27;</span>, <span class="string">&#x27;mapping&#x27;</span>, self.get_mapping, methods=[<span class="string">&#x27;GET&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mapping_file_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            mapping_file_path = os.path.join(<span class="string">&#x27;center_dept_database&#x27;</span>, <span class="string">&#x27;mapping.json&#x27;</span>)</span><br><span class="line">        self.mapping_file_path = mapping_file_path</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义了一个名为 MappingAPI 的类，用于创建一个基于 Flask 的 API，用于提供中心和部门之间的 JSON 映射。</p>
</li>
<li><p>在构造函数（ <strong>init</strong> ）中，实例化了一个 Flask 应用程序（ app ），并为 &#x2F;mapping 端点添加了一个 URL 规则，通过 HTTP GET 访问时将调用 get_mapping 方法。</p>
</li>
<li><p>将映射文件的默认路径设置为 ‘center_dept_database&#x2F;mapping.json’ ，但在初始化 MappingAPI 对象时，可以通过提供不同的路径来覆盖它。</p>
</li>
</ul>
<h3 id="检索映射数据"><a href="#检索映射数据" class="headerlink" title="检索映射数据"></a>检索映射数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_mapping</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(self.mapping_file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        mapping_data = json.load(file)</span><br><span class="line">    <span class="keyword">return</span> jsonify(mapping_data)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此方法从由 mapping_file_path 指定的 JSON 文件中检索映射数据。</p>
</li>
<li><p>它打开文件，读取其内容，并将 JSON 数据加载到 Python 字典中（ mapping_data ）。</p>
</li>
<li><p>然后，使用 Flask 的 jsonify 函数将映射数据作为 JSON 响应返回。</p>
</li>
</ul>
<h3 id="启动-Flask-应用程序-1"><a href="#启动-Flask-应用程序-1" class="headerlink" title="启动 Flask 应用程序"></a>启动 Flask 应用程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5001</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Starting MappingAPI on <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line">    self.app.run(host=host, port=port, debug=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mapping_api = MappingAPI()</span><br><span class="line">    mapping_api.run()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>run 方法启动 Flask 开发服务器。</p>
</li>
<li><p>它需要可选参数 host 和 port 来指定服务器的主机名和端口号。默认情况下，它在端口 5001 上监听所有接口（ ‘0.0.0.0’ ）。</p>
</li>
<li><p>当脚本直接执行（ if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘: ）时，它会创建一个 MappingAPI 的实例，并使用 run 方法运行 Flask 应用程序。</p>
</li>
<li><p>此外，它打印一条消息，指示 API 服务器的启动。</p>
</li>
</ul>
<p>这段代码，用于创建一个简单的基于 Flask 的 API，用于提供中心和部门之间的 JSON 映射。该 API 提供了一个用于检索映射数据的单个端点，使其易于部署和配置到各种应用程序中。</p>
<h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#start mapping server</span></span><br><span class="line">python mapping_server.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#start backend server</span></span><br><span class="line">python server.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">http://127.0.0.1:5000/supply-chain-data?query=order_tracking</span><br><span class="line"></span><br><span class="line">python dashboard.py</span><br></pre></td></tr></table></figure>

<p>打开浏览器，查看 <a target="_blank" rel="noopener" href="http://127.0.0.1:5000/supply-chain-data?query=order_tracking">http://127.0.0.1:5000/supply-chain-data?query=order_tracking</a> ， 成功的话，可以看到json字串。</p>
<p>打开浏览器，查看 <a target="_blank" rel="noopener" href="http://127.0.0.1:7860/">http://127.0.0.1:7860</a> ， 页面如下：</p>
<p><img src="/../asset_aiintegration/02.png"></p>
<p>询问一下当前的库存 what is our current inventory?</p>
<p><img src="/../asset_aiintegration/03.gif"></p>
<p>询问一下货物的具体状态 i need shipment details for delivered status</p>
<p><img src="/../asset_aiintegration/04.gif"></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本文中我们探讨的供应链管理项目的例子，展示了如何将人工智能能力无缝集成到现有业务系统中，而无需进行重大改造。通过利用现代人工智能技术的灵活性和强大功能，我们能够增强供应链管理系统的功能，同时保留其核心运营和工作流程。</p>
<p>在整个开发过程中，我们非常强调减少对现有系统架构的影响。我们并没有试图替换或修改已建立的组件，而是引入了一个“AI 集成系统”，它充当现有基础设施和 AI 功能之间的桥梁。这种方法使我们能够保持现有系统的完整性，同时利用 AI 的好处。</p>
<p>这种整合策略的关键优势之一是能够利用现有系统中已有的大量数据。通过访问和处理这些数据，我们能够通过人工智能模型生成智能的用户查询响应，为特定供应链活动和情景提供有价值的见解和建议。</p>
<p>展望未来，将人工智能无缝集成到现有业务生态系统中的重要性只会继续增长。随着技术进步和对智能自动化和决策支持需求的增加，采用这种方法的组织将更好地把握人工智能带来的机遇，同时最大限度地减少对其运营的干扰。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://ai.gopubby.com/master-ai-integration-how-to-integrate-ai-in-your-application-6b936376df61">https://ai.gopubby.com/master-ai-integration-how-to-integrate-ai-in-your-application-6b936376df61</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/05/28/singleimageto3d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/28/singleimageto3d/" class="post-title-link" itemprop="url">通过单个图像进行 3D 重建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-28 20:10:00" itemprop="dateCreated datePublished" datetime="2024-05-28T20:10:00+08:00">2024-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-06 16:12:05" itemprop="dateModified" datetime="2024-06-06T16:12:05+08:00">2024-06-06</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用 Python 中的多视图扩散模型来重建 3D .</p>
<p>首先我们建立了一个适当的计算环境。接下来，我们需要为任务配置必要的模型。然后，我们处理图像以生成多个视图，这些视图是创建最终的 3D 重建对象所需的。</p>
<p>每个步骤都会详细讨论。我们将看到如何准备环境，设置模型，并使用 <a target="_blank" rel="noopener" href="https://github.com/Entreprenerdly/InstantMesh">InstantMesh</a> 将图像从单个图像转换为 3D 重建。</p>
<p><img src="/../asset_singlleimageto3d/01.gif"></p>
<h2 id="InstantMesh-的理论框架"><a href="#InstantMesh-的理论框架" class="headerlink" title="InstantMesh 的理论框架"></a>InstantMesh 的理论框架</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>InstantMesh 解决了从单个图像进行 3D 重建的挑战，这对虚拟现实和动画等应用非常重要。有限的 3D 数据和不完善的注释历来使得这项任务困难。然而，InstantMesh 利用大规模扩散模型和新颖的架构来增强 3D 网格生成。</p>
<h3 id="背景和相关工作"><a href="#背景和相关工作" class="headerlink" title="背景和相关工作"></a>背景和相关工作</h3><p>先前的研究已经将 2D 扩散扩展到 3D 空间，使用了诸如得分蒸馏采样（SDS）和大型重建模型（LRMs）这样的方法，直接将图像标记映射到 3D 表示。</p>
<h3 id="核心组件和创新"><a href="#核心组件和创新" class="headerlink" title="核心组件和创新"></a>核心组件和创新</h3><p>多视角扩散模型（MVD）。该组件从单个图像中合成多个视图，用于构建 3D 模型。此外，它使用了 <a target="_blank" rel="noopener" href="https://stability.ai/news/stable-zero123-3d-generation">Zero123++模型</a>的修改版本，经过优化以通过在生成的图像中保持一致的背景来减少伪影。</p>
<p>MVD 的数学表达。</p>
<p><img src="/../asset_singlleimageto3d/02.png"></p>
<p>扩散模型使用由𝜃表示的参数，经过微调以生成一致的背景，以𝐼作为输入图像，并合成多视角图像𝐼′。</p>
<p>稀疏视图大型重建模型（LRM）。使用基于 Transformer 的架构，能够处理稀疏输入，LRM 将多视图图像转换为 3D 网格。</p>
<p>等值面提取（FlexiCubes）。</p>
<p><img src="/../asset_singlleimageto3d/03.png"></p>
<p>𝑀是网格输出，𝑉代表 LRM 中的体积数据，𝜙是 FlexiCubes 模块的参数，它们直接应用于网格上的几何约束。</p>
<h3 id="训练策略和优化技术"><a href="#训练策略和优化技术" class="headerlink" title="训练策略和优化技术"></a>训练策略和优化技术</h3><p>数据准备和训练策略：训练采用两阶段方法，首先侧重于 NeRF 表示，然后过渡到网格优化。</p>
<p>阶段 1：基于 NeRF 的训练。</p>
<p>这个阶段的重点是利用 NeRF 的体积渲染能力建立一个强大的基础模型。目标是学习一个初始表示，从合成的多视角图像中捕捉整体形状和外观。</p>
<p><img src="/../asset_singlleimageto3d/04.png"></p>
<p>𝐼^𝑖和𝑀^𝑖是预测图像和掩模，𝐼𝑔𝑡𝑖和𝑀𝑔𝑡𝑖是实际图像和掩模，𝜆值是正则化系数。</p>
<p>阶段 2：基于网格的优化。</p>
<p>这个阶段转向基于网格的方法，其中使用 FlexiCubes 来细化表面细节并提高网格的几何精度。此外，在这个阶段，从 NeRF 中学到的初步知识被利用来专注于增强表面细节并应用逼真的纹理。</p>
<p><img src="/../asset_singlleimageto3d/05.png"></p>
<p>𝐷^𝑖和𝑁^𝑖是预测的深度图和法线图，𝐷𝑔𝑡𝑖和𝑁𝑔𝑡𝑖是地面真实值，⊗表示逐元素乘法，𝐿reg 是 FlexiCubes 的正则化项。</p>
<p>相机增强和扰动技术。增强包括对相机姿势进行随机旋转和缩放，以提高模型对不同输入的稳健性。</p>
<p>优化技术:</p>
<ul>
<li>AdaLN（自适应层归一化）：此技术用于transformer 内，以调整模型对不同相机姿势的敏感性，从而提高其在各种视角下的泛化能力。</li>
<li>正规化和监督：深度和法线监督对于优化模型的输出至关重要。此外，它确保 3D 网格在视觉上类似于输入，并且符合物理尺寸和方向。</li>
</ul>
<p>损失函数组件:</p>
<ul>
<li>深度和法线监督。通过将预测的深度图和法线与它们的地面真实对应物进行比较，增强模型预测准确几何属性的能力。</li>
<li>正则化项。包括维持网格完整性、防止过拟合和鼓励生成网格平滑的项。</li>
</ul>
<h3 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h3><p>下面的图表代表了 InstantMesh 框架的工作流程，用于从单个图像生成 3D 重建。以下是图表中每个组件如何产生作用：</p>
<ul>
<li><p>输入图像。流程始于单个输入图像，图示为一个插图人物。</p>
</li>
<li><p>多视角扩散模型。生成输入图像的多个视图，该模型增强了进行 3D 重建所需的空间理解。接下来，视图被展示为人物的几个不同视角，有助于全面捕捉其 3D 结构。</p>
</li>
<li><p>稀疏视图大重建模型。该模型由几个关键组件组成：</p>
<ul>
<li>ViT 编码器。处理多视图图像，视觉 Transformer（ViT）编码器将它们转换为一系列图像标记，这些标记封装了每个视图的关键特征。</li>
<li>三层面解码器。该组件将图像令牌解码为三层面表示，这是一种三维格式，用作最终网格生成之前的中间步骤。</li>
<li>FlexiCubes。作为等值面提取模块，FlexiCubes 将三面数据转换为网格，直接应用几何监督来细化和详细化 3D 输出。</li>
</ul>
</li>
<li><p>128³ 网格。该网格结构为 128x128x128，网格突出了最终 3D 模型中捕捉到的分辨率和细节。</p>
</li>
<li><p>渲染。从各个角度渲染，最终的网格展示了完成的 3D 模型，并展示了该模型在捕捉原始输入的全面几何细节方面的有效性。</p>
</li>
</ul>
<p><img src="/../asset_singlleimageto3d/06.png"></p>
<h3 id="模型变体和配置"><a href="#模型变体和配置" class="headerlink" title="模型变体和配置"></a>模型变体和配置</h3><p>InstantMesh 提供了几种模型变体，以满足各种计算需求和应用场景。</p>
<p>这些变体根据它们的 3D 表示（NeRF vs. Mesh）和参数规模（base vs. large）分为不同类别。</p>
<p>模型变体的参数配置:</p>
<ul>
<li>NeRF 和 Mesh 变体。NeRF 变体最初采用神经辐射场方法，擅长捕捉复杂的体积细节。另一方面，Mesh 变体从一开始就采用网格表示，实现直接的几何操作，通常使用 FlexiCubes 模块可以实现更快的处理时间。</li>
<li>基础和大型模型。transformer 网络的大小以及三角面或网格表示的复杂性来区分这些配置。更大的模型旨在处理更复杂的场景，但需要更多的计算资源。</li>
</ul>
<table>
<thead>
<tr>
<th>Model</th>
<th>Representation</th>
<th>Input Views</th>
<th>Transformer Layers</th>
<th>Triplane&#x2F;Mesh Details</th>
</tr>
</thead>
<tbody><tr>
<td>InstantNeRF</td>
<td>NeRF</td>
<td>6</td>
<td>12 (Base) &#x2F; 16 (Large)</td>
<td>Triplane 64x64</td>
</tr>
<tr>
<td>InstantMesh</td>
<td>Mesh</td>
<td>6</td>
<td>12 (Base) &#x2F; 16 (Large)</td>
<td>Mesh grid size 128x128</td>
</tr>
</tbody></table>
<h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><h3 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h3><p>从 GitHub 克隆‘InstantMesh’存储库，<a target="_blank" rel="noopener" href="https://github.com/Entreprenerdly/InstantMesh">https://github.com/Entreprenerdly/InstantMesh</a> ,  安装各种 Python 库的特定版本。其中包括深度学习 ( pytorch-lightning , torchmetrics )，以及其他实用工具 ( einops , omegaconf )。</p>
<ul>
<li>PyMCubes 和 trimesh 用于网格处理。提取等值面（将 3D 体素数据转换为网格）需要 PyMCubes 。相反， trimesh 用于轻松操作和查看 3D 网格数据。</li>
<li>rembg 用于从图像中去除背景，对于需要将图像主题隔离出来的处理至关重要。</li>
<li>nvdiffrast 和 jax 和 jaxlib. 这些库对可微光栅化和数值计算是必需的，从而实现基于梯度下降的复杂 3D 几何优化。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==2.1.0 torchvision==0.16.0 torchaudio==2.1.0 --index-url https://download.pytorch.org/whl/cu121</span><br><span class="line">pip install xformers==0.0.22.post7</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install ninja</span><br><span class="line">pip install bitsandbytes-windows</span><br></pre></td></tr></table></figure>
<p>windows系统要安装 bitsandbytes-windows</p>
<p>当运行 app.py 时，</p>
<p>如果碰到ninja编译的问题：</p>
<ul>
<li>安装 微软 vs_BuildTools ，然后选择安装 win10 SDK</li>
</ul>
<p>如果编译CUDA时，报告不支持的VS版本错误，直接修改CUDA相应的header文件： </p>
<p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vxx.x\include\crt&#x2F;host_config.h</p>
<p>请看log进入具体的文件，修改_MSC_VER的比较值, 让版本错误消失：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined(_WIN32)</span><br><span class="line"></span><br><span class="line">#if _MSC_VER &lt; 1910 || _MSC_VER &gt;= 2000</span><br></pre></td></tr></table></figure>

<p>因为gradio的安装版本不好控制，如果被逼安装到新的版本，需要修改 app.py的代码，把 width&#x3D;768 改成 min_width&#x3D;768</p>
<p>此外，需要16G VRAM以上的显卡。</p>
<h3 id="模型初始化"><a href="#模型初始化" class="headerlink" title="模型初始化"></a>模型初始化</h3><p>模型管道设置:</p>
<ul>
<li>一个 DiffusionPipeline 是从一个预训练模型实例化的。这个模型，由 sudo-ai&#x2F;zero123plus-v1.2 标识，专门配置为以半精度（ torch_dtype&#x3D;torch.float16 ）运行。</li>
<li>扩散模型的调度程序配置为 trailing 时间步距。该配置影响了扩散步骤的计算方式，优化了图像合成过程中降噪进程的处理。</li>
</ul>
<p>模型加载：</p>
<ul>
<li>从 Hugging Face Hub（ hf_hub_download ）下载模型，并将其加载到模型（ pipeline.unet.load_state_dict(state_dict, strict&#x3D;True) ）中，确保我们拥有准备部署的精确训练参数。</li>
</ul>
<p>设备配置:</p>
<ul>
<li>将计算设备设置为 GPU（ device &#x3D; torch.device(‘cuda’) ）并将管道移动到该设备（ pipeline &#x3D; pipeline.to(device) ）是深度学习任务的标准做法。</li>
</ul>
<p>可重复性:</p>
<ul>
<li>一个随机种子（ seed_everything(0) ）可以确保模型的输出是确定性的和可重现的。这在科学实验和产品开发中尤为重要。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load libraries</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># Empty Cache and clear any previous model references</span></span><br><span class="line">model = <span class="literal">None</span></span><br><span class="line">torch.cuda.empty_cache()</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> rembg</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pytorch_lightning <span class="keyword">import</span> seed_everything</span><br><span class="line"><span class="keyword">from</span> einops <span class="keyword">import</span> rearrange</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline, EulerAncestralDiscreteScheduler</span><br><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> hf_hub_download</span><br><span class="line"><span class="keyword">from</span> src.utils.infer_util <span class="keyword">import</span> remove_background, resize_foreground</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initialize a DiffusionPipeline with a pretrained model specified by its identifier.</span></span><br><span class="line"><span class="comment"># This model uses a custom pipeline setting and operates at half precision (float16) to enhance performance on compatible GPUs.</span></span><br><span class="line">pipeline = DiffusionPipeline.from_pretrained(<span class="string">&quot;sudo-ai/zero123plus-v1.2&quot;</span>, custom_pipeline=<span class="string">&quot;zero123plus&quot;</span>, torch_dtype=torch.float16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure the pipeline&#x27;s scheduler, setting the timestep spacing to &#x27;trailing&#x27; which affects how steps are calculated in the diffusion process.</span></span><br><span class="line">pipeline.scheduler = EulerAncestralDiscreteScheduler.from_config(pipeline.scheduler.config, timestep_spacing=<span class="string">&#x27;trailing&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the model checkpoint from the Hugging Face Hub, specifying the repository and the file name.</span></span><br><span class="line">unet_ckpt_path = hf_hub_download(repo_id=<span class="string">&quot;TencentARC/InstantMesh&quot;</span>, filename=<span class="string">&quot;diffusion_pytorch_model.bin&quot;</span>, repo_type=<span class="string">&quot;model&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the state dictionary of the model from the downloaded checkpoint, ensuring it&#x27;s loaded to CPU memory first.</span></span><br><span class="line">state_dict = torch.load(unet_ckpt_path, map_location=<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the state dictionary into the UNet model within the pipeline, ensuring strict loading to match all model parameters exactly.</span></span><br><span class="line">pipeline.unet.load_state_dict(state_dict, strict=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the device for model computation to GPU for faster processing if available.</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Move the pipeline to the specified device (GPU).</span></span><br><span class="line">pipeline = pipeline.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a seed for random number generation to ensure reproducibility of the results.</span></span><br><span class="line">seed_everything(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="图像处理和多视图合成功能"><a href="#图像处理和多视图合成功能" class="headerlink" title="图像处理和多视图合成功能"></a>图像处理和多视图合成功能</h3><p>实现负责图像预处理和从单个输入生成合成多视图图像的函数, 这个阶段通过transforms 输入可用的空间信息，将初始输入转换为适合 3D 建模的格式。</p>
<p>预处理功能：</p>
<ul>
<li>preprocess 函数旨在可选地从输入图像中移除背景。这一步骤对于将模型的注意力集中在图像的主题上并避免引入噪音是必要的。</li>
<li>调整前景大小。在去除背景后，将前景调整为其原始大小的 85％有助于标准化输入尺寸，可能减少处理过程中的计算负载。</li>
</ul>
<p>多视角合成:</p>
<ul>
<li>generate_mvs 函数使用扩散模型从预处理图像创建多个合成视图。这是必要的，因为人工生成同一对象的不同视角可以增加数据集的丰富性，并模拟多摄像头设置。</li>
<li>通过使用扩散模型，该功能合成保持与原始图像上下文一致但不同角度的新视图。</li>
<li>图像重新排列。合成视图被重新排列成网格格式。这一步骤并不简单，因为它涉及到操纵图像张量的形状和尺寸，以使多个视图对齐整齐。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">input_image, do_remove_background</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Preprocesses the input image by optionally removing the background.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    input_image (PIL.Image): The image to preprocess.</span></span><br><span class="line"><span class="string">    do_remove_background (bool): Flag to determine if the background should be removed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    PIL.Image: The preprocessed image.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Create a new rembg session only if background removal is requested</span></span><br><span class="line">    rembg_session = rembg.new_session() <span class="keyword">if</span> do_remove_background <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If background removal is enabled, apply the removal process and resize the foreground</span></span><br><span class="line">    <span class="keyword">if</span> do_remove_background:</span><br><span class="line">        input_image = remove_background(input_image, rembg_session)  <span class="comment"># Remove the background</span></span><br><span class="line">        input_image = resize_foreground(input_image, <span class="number">0.85</span>)  <span class="comment"># Resize the foreground to 85% of its original size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_mvs</span>(<span class="params">input_image, sample_steps, sample_seed</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generates multi-view synthetic images from a single input image using a diffusion model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    input_image (PIL.Image): The image to process.</span></span><br><span class="line"><span class="string">    sample_steps (int): Number of inference steps for the diffusion process.</span></span><br><span class="line"><span class="string">    sample_seed (int): Seed for random number generation to ensure reproducibility.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    tuple: A tuple containing:</span></span><br><span class="line"><span class="string">        - z123_image (torch.Tensor): The raw tensor image from the diffusion model.</span></span><br><span class="line"><span class="string">        - show_image (PIL.Image): The rearranged image ready for display.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Set a seed to ensure reproducibility in the generation process</span></span><br><span class="line">    seed_everything(sample_seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a new torch generator for random numbers on the specified device</span></span><br><span class="line">    generator = torch.Generator(device=device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate a synthetic image using the diffusion pipeline</span></span><br><span class="line">    z123_image = pipeline(</span><br><span class="line">        input_image,</span><br><span class="line">        num_inference_steps=sample_steps,</span><br><span class="line">        generator=generator,</span><br><span class="line">    ).images[<span class="number">0</span>]  <span class="comment"># Access the first image from the generated set</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the PyTorch tensor to a numpy array with type uint8</span></span><br><span class="line">    show_image = np.asarray(z123_image, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rearrange the image dimensions to organize multiple views into a grid format for display</span></span><br><span class="line">    show_image = torch.from_numpy(show_image)  <span class="comment"># Convert numpy array back to PyTorch tensor</span></span><br><span class="line">    show_image = rearrange(show_image, <span class="string">&#x27;(n h) (m w) c -&gt; (n m) h w c&#x27;</span>, n=<span class="number">3</span>, m=<span class="number">2</span>)  <span class="comment"># Rearrange for multi-view</span></span><br><span class="line">    show_image = rearrange(show_image, <span class="string">&#x27;(n m) h w c -&gt; (n h) (m w) c&#x27;</span>, n=<span class="number">2</span>, m=<span class="number">3</span>)  <span class="comment"># Adjust the final layout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the final tensor back to a PIL image for easy display and manipulation</span></span><br><span class="line">    show_image = Image.fromarray(show_image.numpy())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z123_image, show_image</span><br></pre></td></tr></table></figure>

<h3 id="图像加载、处理和多视图生成"><a href="#图像加载、处理和多视图生成" class="headerlink" title="图像加载、处理和多视图生成"></a>图像加载、处理和多视图生成</h3><ul>
<li>图像加载：该过程始于指定输入图像的路径，并使用 Python Imaging Library（PIL）加载图像。</li>
<li>背景去除和图像处理：使用前面讨论过的 preprocess 函数，我们去除加载图像的背景并调整大小。</li>
<li>合成多视图生成：然后将 generate_mvs 函数应用于预处理图像，以生成多个合成视图。此生成的参数 — 例如扩散过程中的步数（75）被选择以平衡计算需求和生成视图的质量之间的权衡。</li>
<li>图像保存和显示：扩散过程产生的原始张量图像和视觉上排列的多视图图像都保存到指定路径。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the path to the input image stored in the notebook&#x27;s workspace environment.</span></span><br><span class="line">input_image_path = <span class="string">&#x27;examples/bird.jpg&#x27;</span> <span class="comment">#@param &#123;type:&quot;string&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Open the image file from the specified path using PIL&#x27;s Image module.</span></span><br><span class="line">input_image = Image.<span class="built_in">open</span>(input_image_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocess the input image by removing the background, leveraging the &#x27;preprocess&#x27; function.</span></span><br><span class="line">processed_image = preprocess(input_image, <span class="literal">True</span>)  <span class="comment"># Pass True to indicate background removal is needed.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the processed image; useful for verification in a Jupyter Notebook environment.</span></span><br><span class="line">processed_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate multi-view synthetic images from the preprocessed image using a diffusion model.</span></span><br><span class="line"><span class="comment"># Specify 75 steps for the diffusion process and a seed value of 42 for reproducibility.</span></span><br><span class="line">mv_images, mv_show_images = generate_mvs(processed_image, <span class="number">75</span>, <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the path where the generated multi-view images will be saved.</span></span><br><span class="line">output_image_path = <span class="string">&#x27;mv_images.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the raw tensor image (not visually arranged) to the specified file path.</span></span><br><span class="line">mv_images.save(output_image_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the rearranged multi-view images, which are formatted for easy viewing.</span></span><br><span class="line"><span class="comment"># This output can be directly viewed in a Jupyter Notebook environment.</span></span><br><span class="line">mv_show_images</span><br></pre></td></tr></table></figure>
<p><img src="/../asset_singlleimageto3d/07.png"></p>
<h3 id="模型配置"><a href="#模型配置" class="headerlink" title="模型配置"></a>模型配置</h3><p>我们设置操作参数，从外部来源加载必要的配置，并确保模型在给定硬件上性能优化。</p>
<p>配置加载和应用。</p>
<ul>
<li>OmegaConf 从一个 YAML 文件中加载模型的配置。这一步提供了一种灵活且结构化的方式来管理设置和操作参数，可以在不改变代码库的情况下进行调整。</li>
<li>此外，YAML 文件包含各种模型方面的规范，包括架构细节和操作参数，这些规范指导系统在执行过程中的行为。</li>
</ul>
<p>模型初始化。</p>
<ul>
<li>根据上一步加载的配置，系统创建一个模型。这涉及设置模型架构，如在 YAML 文件中指定的那样。</li>
</ul>
<p>状态字典管理。</p>
<ul>
<li>从远程存储库下载模型后，系统将状态字典加载到实例化的模型中。该状态字典包含经过训练的权重和偏置。</li>
<li>状态字典的管理确保模型的所有组件都正确地使用训练参数进行初始化。</li>
</ul>
<p>GPU 加速设备配置。</p>
<ul>
<li>如果可用，系统会配置模型在 GPU 上运行以加快计算速度。这种设置涉及将模型的计算任务转移到 GPU 上，以便高效地处理并行处理。</li>
<li>这一步处理涉及 3D 建模和图像处理的复杂计算，特别是在处理大数据量或需要实时性能时。</li>
</ul>
<p>FlexiCubes 几何特殊配置。</p>
<ul>
<li>另外一项检查评估模型是否使用 FlexiCubes。如果 FlexiCubes 是配置的一部分，则会执行额外的初始化步骤来设置这个几何结构。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Empty Cache and clear any previous pipeline references</span></span><br><span class="line">pipeline = <span class="literal">None</span></span><br><span class="line">torch.cuda.empty_cache()</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> v2</span><br><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> OmegaConf</span><br><span class="line"><span class="keyword">from</span> einops <span class="keyword">import</span> repeat</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"><span class="keyword">from</span> src.utils.train_util <span class="keyword">import</span> instantiate_from_config</span><br><span class="line"><span class="keyword">from</span> src.utils.camera_util <span class="keyword">import</span> (FOV_to_intrinsics, get_zero123plus_input_cameras,get_circular_camera_poses,)</span><br><span class="line"><span class="keyword">from</span> src.utils.mesh_util <span class="keyword">import</span> save_obj, save_obj_with_mtl</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the path to the configuration file for the model.</span></span><br><span class="line">config_path = <span class="string">&#x27;configs/instant-mesh-base.yaml&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the configuration from the YAML file using OmegaConf.</span></span><br><span class="line">config = OmegaConf.load(config_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract the base name of the configuration file, removing the &#x27;.yaml&#x27; extension for use in conditional logic or naming.</span></span><br><span class="line">config_name = os.path.basename(config_path).replace(<span class="string">&#x27;.yaml&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Access specific configuration blocks for the model and inference from the loaded configuration.</span></span><br><span class="line">model_config = config.model_config</span><br><span class="line">infer_config = config.infer_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the model checkpoint from Hugging Face Hub, specifying the repository ID and filename.</span></span><br><span class="line">model_ckpt_path = hf_hub_download(repo_id=<span class="string">&quot;TencentARC/InstantMesh&quot;</span>, filename=<span class="string">&quot;instant_mesh_base.ckpt&quot;</span>, repo_type=<span class="string">&quot;model&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate the model using the configuration for the model.</span></span><br><span class="line">model = instantiate_from_config(model_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the model&#x27;s state dictionary from the checkpoint, ensuring it&#x27;s directed to CPU memory.</span></span><br><span class="line">state_dict = torch.load(model_ckpt_path, map_location=<span class="string">&#x27;cpu&#x27;</span>)[<span class="string">&#x27;state_dict&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter and adjust the keys in the state dictionary to match the expected format by removing a specific prefix and excluding any keys related to the &#x27;source_camera&#x27;.</span></span><br><span class="line">state_dict = &#123;k[<span class="number">14</span>:]: v <span class="keyword">for</span> k, v <span class="keyword">in</span> state_dict.items() <span class="keyword">if</span> k.startswith(<span class="string">&#x27;lrm_generator.&#x27;</span>) <span class="keyword">and</span> <span class="string">&#x27;source_camera&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> k&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the processed state dictionary into the model, ensuring a strict match.</span></span><br><span class="line">model.load_state_dict(state_dict, strict=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the device for model computation to GPU to accelerate processing.</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Move the model to the specified device.</span></span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if the configuration name starts with &#x27;instant-mesh&#x27; to determine if FlexiCubes geometry initialization is required.</span></span><br><span class="line">IS_FLEXICUBES = <span class="literal">True</span> <span class="keyword">if</span> config_name.startswith(<span class="string">&#x27;instant-mesh&#x27;</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If the model uses FlexiCubes, initialize the FlexiCubes geometry with the specified field of view.</span></span><br><span class="line"><span class="keyword">if</span> IS_FLEXICUBES:</span><br><span class="line">    model.init_flexicubes_geometry(device, fovy=<span class="number">30.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the model to evaluation mode, which disables training-specific behaviors like dropout.</span></span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>

<h3 id="3D-模型生成和可视化的功能"><a href="#3D-模型生成和可视化的功能" class="headerlink" title="3D 模型生成和可视化的功能"></a>3D 模型生成和可视化的功能</h3><p>实现从处理过的图像生成和可视化 3D 模型的功能。</p>
<p>这些功能将多视图图像转换为 3D 输出（MP4、对象文件等），可在各种应用中进行评估和利用。</p>
<ul>
<li>从图像序列创建视频： images_to_video 函数将图像序列转换为视频文件。该函数会检查和转换图像数据，以确保帧具有正确的格式和尺寸，然后将它们编译成视频。</li>
<li>用于 3D 渲染的相机参数生成： get_render_cameras 计算并提供渲染 3D 模型所需的相机参数。这些参数是基于圆形配置推导出来的，模拟了一个真实的相机设置，可以从多个角度捕捉对象。</li>
<li>3D 网格生成： make_mesh 函数从模型提供的平面数据创建 3D 网格。该函数生成网格，还可以选择性地应用纹理映射。</li>
<li>全面的 3D 模型和可视化生成： make3d 功能编排整个将图像数据转换为 3D 网格和相应视频的过程。它管理从处理初始图像、设置相机参数、生成网格平面，最后将输出编译成静态（网格）和动态（视频）格式的工作流程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">images_to_video</span>(<span class="params">images, output_path, fps=<span class="number">30</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Converts a sequence of images into a video file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    images (Tensor): A tensor of images to convert into video.</span></span><br><span class="line"><span class="string">    output_path (str): The file path where the video will be saved.</span></span><br><span class="line"><span class="string">    fps (int): Frames per second for the output video.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Ensure the directory for the output path exists, create if not.</span></span><br><span class="line">    os.makedirs(os.path.dirname(output_path), exist_ok=<span class="literal">True</span>)</span><br><span class="line">    frames = []</span><br><span class="line">    <span class="comment"># Convert each image tensor to a numpy array, adjust for display, and collect frames.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(images.shape[<span class="number">0</span>]):</span><br><span class="line">        frame = (images[i].permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).cpu().numpy() * <span class="number">255</span>).astype(np.uint8).clip(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">        <span class="comment"># Ensure frame dimensions match expected dimensions.</span></span><br><span class="line">        <span class="keyword">assert</span> frame.shape[<span class="number">0</span>] == images.shape[<span class="number">2</span>] <span class="keyword">and</span> frame.shape[<span class="number">1</span>] == images.shape[<span class="number">3</span>], \</span><br><span class="line">            <span class="string">f&quot;Frame shape mismatch: <span class="subst">&#123;frame.shape&#125;</span> vs <span class="subst">&#123;images.shape&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># Ensure pixel values are within the valid range.</span></span><br><span class="line">        <span class="keyword">assert</span> frame.<span class="built_in">min</span>() &gt;= <span class="number">0</span> <span class="keyword">and</span> frame.<span class="built_in">max</span>() &lt;= <span class="number">255</span>, \</span><br><span class="line">            <span class="string">f&quot;Frame value out of range: <span class="subst">&#123;frame.<span class="built_in">min</span>()&#125;</span> ~ <span class="subst">&#123;frame.<span class="built_in">max</span>()&#125;</span>&quot;</span></span><br><span class="line">        frames.append(frame)</span><br><span class="line">    <span class="comment"># Write the frames to a video file.</span></span><br><span class="line">    imageio.mimwrite(output_path, np.stack(frames), fps=fps, codec=<span class="string">&#x27;h264&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_render_cameras</span>(<span class="params">batch_size=<span class="number">1</span>, M=<span class="number">120</span>, radius=<span class="number">2.5</span>, elevation=<span class="number">10.0</span>, is_flexicubes=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generates camera parameters for 3D rendering based on a circular configuration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    batch_size (int): Number of camera sets to generate.</span></span><br><span class="line"><span class="string">    M (int): Number of camera positions.</span></span><br><span class="line"><span class="string">    radius (float): Radius of the camera circle.</span></span><br><span class="line"><span class="string">    elevation (float): Elevation angle of cameras.</span></span><br><span class="line"><span class="string">    is_flexicubes (bool): Flag to indicate if FlexiCubes geometry is used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    Tensor: Camera parameters for rendering.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Compute camera positions based on circular parameters.</span></span><br><span class="line">    c2ws = get_circular_camera_poses(M=M, radius=radius, elevation=elevation)</span><br><span class="line">    <span class="comment"># If using FlexiCubes, adjust camera parameters accordingly.</span></span><br><span class="line">    <span class="keyword">if</span> is_flexicubes:</span><br><span class="line">        cameras = torch.linalg.inv(c2ws)</span><br><span class="line">        cameras = cameras.unsqueeze(<span class="number">0</span>).repeat(batch_size, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        extrinsics = c2ws.flatten(-<span class="number">2</span>)</span><br><span class="line">        intrinsics = FOV_to_intrinsics(<span class="number">30.0</span>).unsqueeze(<span class="number">0</span>).repeat(M, <span class="number">1</span>, <span class="number">1</span>).<span class="built_in">float</span>().flatten(-<span class="number">2</span>)</span><br><span class="line">        cameras = torch.cat([extrinsics, intrinsics], dim=-<span class="number">1</span>)</span><br><span class="line">        cameras = cameras.unsqueeze(<span class="number">0</span>).repeat(batch_size, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> cameras</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_mesh</span>(<span class="params">mesh_fpath, planes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Creates a 3D mesh with optional texture mapping.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    mesh_fpath (str): File path for saving the mesh.</span></span><br><span class="line"><span class="string">    planes (Tensor): Planar data for mesh generation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    str: The file path where the mesh is saved.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Extract base filename and directory from path.</span></span><br><span class="line">    mesh_basename = os.path.basename(mesh_fpath).split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    mesh_dirname = os.path.dirname(mesh_fpath)</span><br><span class="line">    <span class="comment"># Use texture mapping to save a detailed mesh.</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        mesh_out = model.extract_mesh(planes, use_texture_map=<span class="literal">True</span>, **infer_config)</span><br><span class="line">        vertices, faces, uvs, mesh_tex_idx, tex_map = mesh_out</span><br><span class="line">        save_obj_with_mtl(</span><br><span class="line">            vertices.data.cpu().numpy(),</span><br><span class="line">            uvs.data.cpu().numpy(),</span><br><span class="line">            faces.data.cpu().numpy(),</span><br><span class="line">            mesh_tex_idx.data.cpu().numpy(),</span><br><span class="line">            tex_map.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).data.cpu().numpy(),</span><br><span class="line">            mesh_fpath,</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Mesh with texmap saved to <span class="subst">&#123;mesh_fpath&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> mesh_fpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make3d</span>(<span class="params">images</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generates a 3D mesh and a video of the mesh from images.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    images (Tensor or array): Image data used for 3D generation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    tuple: Paths to the generated video and mesh file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Convert image data to tensor and normalize.</span></span><br><span class="line">    images = np.asarray(images, dtype=np.float32) / <span class="number">255.0</span></span><br><span class="line">    images = torch.from_numpy(images).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).contiguous().<span class="built_in">float</span>()</span><br><span class="line">    <span class="comment"># Reorganize images for processing.</span></span><br><span class="line">    images = rearrange(images, <span class="string">&#x27;c (n h) (m w) -&gt; (n m) c h w&#x27;</span>, n=<span class="number">3</span>, m=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># Obtain camera parameters for input and rendering.</span></span><br><span class="line">    input_cameras = get_zero123plus_input_cameras(batch_size=<span class="number">1</span>, radius=<span class="number">4.0</span>).to(device)</span><br><span class="line">    render_cameras = get_render_cameras(</span><br><span class="line">        batch_size=<span class="number">1</span>, radius=<span class="number">4.5</span>, elevation=<span class="number">20.0</span>, is_flexicubes=IS_FLEXICUBES).to(device)</span><br><span class="line">    <span class="comment"># Resize images and move to GPU.</span></span><br><span class="line">    images = images.unsqueeze(<span class="number">0</span>).to(device)</span><br><span class="line">    images = v2.functional.resize(images, (<span class="number">320</span>, <span class="number">320</span>), interpolation=<span class="number">3</span>, antialias=<span class="literal">True</span>).clamp(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Prepare directory for temporary storage.</span></span><br><span class="line">    directory = <span class="string">&#x27;tmp&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">        os.makedirs(directory)</span><br><span class="line">    tempfile.tempdir = directory</span><br><span class="line">    <span class="comment"># Create temporary files for mesh and video.</span></span><br><span class="line">    mesh_fpath = tempfile.NamedTemporaryFile(suffix=<span class="string">&quot;.obj&quot;</span>, delete=<span class="literal">False</span>).name</span><br><span class="line">    mesh_basename = os.path.basename(mesh_fpath).split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    mesh_dirname = os.path.dirname(mesh_fpath)</span><br><span class="line">    video_fpath = os.path.join(mesh_dirname, <span class="string">f&quot;<span class="subst">&#123;mesh_basename&#125;</span>.mp4&quot;</span>)</span><br><span class="line">    <span class="comment"># Generate mesh planes and render frames for video.</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        planes = model.forward_planes(images, input_cameras)</span><br><span class="line">        chunk_size = <span class="number">20</span> <span class="keyword">if</span> IS_FLEXICUBES <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        render_size = <span class="number">384</span></span><br><span class="line">        frames = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">0</span>, render_cameras.shape[<span class="number">1</span>], chunk_size)):</span><br><span class="line">            <span class="keyword">if</span> IS_FLEXICUBES:</span><br><span class="line">                frame = model.forward_geometry(planes, render_cameras[:, i:i+chunk_size], render_size=render_size)[<span class="string">&#x27;img&#x27;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                frame = model.synthesizer(planes, cameras=render_cameras[:, i:i+chunk_size], render_size=render_size)[<span class="string">&#x27;images_rgb&#x27;</span>]</span><br><span class="line">            frames.append(frame)</span><br><span class="line">        frames = torch.cat(frames, dim=<span class="number">1</span>)</span><br><span class="line">        images_to_video(frames[<span class="number">0</span>], video_fpath, fps=<span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Video saved to <span class="subst">&#123;video_fpath&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># Save the mesh and return paths.</span></span><br><span class="line">    mesh_fpath = make_mesh(mesh_fpath, planes)</span><br><span class="line">    <span class="keyword">return</span> video_fpath, mesh_fpath</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Open the multi-view image file previously saved to check the output from the image generation process.</span></span><br><span class="line">mv_images = Image.<span class="built_in">open</span>(<span class="string">&#x27;mv_images.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pass the opened multi-view images to the &#x27;make3d&#x27; function to generate a 3D model and a video visualization of the model.</span></span><br><span class="line">output_video, output_model_obj = make3d(mv_images)</span><br></pre></td></tr></table></figure>
<p>播放生成的视频文件</p>
<p><img src="/../asset_singlleimageto3d/02.gif"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@crisvelasquez/3d-reconstructions-from-a-single-image-d53c387261b6">https://medium.com/@crisvelasquez/3d-reconstructions-from-a-single-image-d53c387261b6</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/05/27/deepQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/27/deepQ/" class="post-title-link" itemprop="url">强化学习：深度 Q 网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-27 17:29:10" itemprop="dateCreated datePublished" datetime="2024-05-27T17:29:10+08:00">2024-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-30 10:09:08" itemprop="dateModified" datetime="2024-05-30T10:09:08+08:00">2024-05-30</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在强化学习（RL）中，Q 学习是一种基础算法，帮助代理通过学习最大化累积奖励的策略来导航其环境。它通过更新动作值函数来实现这一点，该函数基于接收的奖励和未来的奖励来估计在给定状态下采取特定动作的预期效用。</p>
<p>然而，传统的 Q 学习也存在挑战。随着状态空间的增长，它在可扩展性方面遇到困难，并且在具有连续状态和动作空间的环境中效果较差。这就是深度 Q 网络（DQNs）发挥作用的地方。DQNs 使用神经网络来近似 Q 值，使代理能够有效处理更大更复杂的环境。</p>
<p>在本文中，我们将深入探讨深度 Q 网络。我们将探讨 DQN 如何克服传统 Q 学习的局限性，并讨论构成 DQN 的关键组件。我们还将介绍如何从头开始实现一个 DQN，并将其应用于更复杂的环境中。</p>
<h2 id="传统的-Q-学习"><a href="#传统的-Q-学习" class="headerlink" title="传统的 Q 学习"></a>传统的 Q 学习</h2><p>Q-learning 指导代理来学习在环境中最大化累积奖励的最佳行动。在深度 Q 网络之前，先简要回顾其前身 Q-learning 背后的机制。</p>
<h3 id="状态和动作"><a href="#状态和动作" class="headerlink" title="状态和动作"></a>状态和动作</h3><p>想象一下，你是一个在迷宫中导航的机器人。迷宫中你所占据的每个位置被称为“状态”。你可以采取的每个可能移动，比如向左、向右、向上或向下，都是一种“动作”。目标是找出在每个状态下应该采取哪种动作，最终找到迷宫中的最佳路径。</p>
<h3 id="Q-值"><a href="#Q-值" class="headerlink" title="Q-值"></a>Q-值</h3><p>Q 学习的核心是 Q 值，表示为𝑄(𝑠, 𝑎)。该值代表在特定状态 s 中采取特定动作 a 后预期的未来奖励，然后沿着最佳路径（策略）继续。</p>
<p>将 Q 值视为指南中的条目，评估每个可能移动的长期收益。例如，如果你在迷宫中的特定位置并考虑向左移动，Q 值会告诉你这一移动在未来奖励方面预计会有多大益处。较高的 Q 值表示更好的移动。</p>
<h3 id="Q-表"><a href="#Q-表" class="headerlink" title="Q 表"></a>Q 表</h3><p>Q 学习使用 Q 表来跟踪这些 Q 值。Q 表本质上是一个大型的电子表格，其中每一行对应一个状态，每一列对应一个动作，每个单元格包含该状态-动作对的 Q 值。</p>
<p>想象 Q 表格就像一个巨大的电子表格，其中每个单元格代表从迷宫中特定位置做出特定移动的潜在未来奖励。随着对环境的了解越来越多，您会用更好的估计值更新这个电子表格中的这些奖励。</p>
<h3 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h3><p>Q-Learning 中的学习过程是迭代的。它始于一个初始状态 s。然后，决定采取一个动作 a。这个选择可以基于：</p>
<ul>
<li>探索：尝试新的行动以发现它们的效果。</li>
<li>利用：利用现有知识选择具有已知最高 Q 值的动作。</li>
</ul>
<p>执行选择的动作，观察奖励 r，并移动到下一个状态 s′。使用 Q-Learning 公式更新状态-动作对 (s, a) 的 Q 值：</p>
<p><img src="/../asset_deepq/01.png" alt="Q-值更新公式"></p>
<p>这里：</p>
<ul>
<li>α是学习率，它决定了新信息覆盖旧信息的程度。</li>
<li>γ是折扣因子，它更高地重视即时奖励而不是遥远未来的奖励。</li>
<li>maxa′​Q(s′,a′)代表了在所有可能的动作 a′中，下一个状态 s′的最高 Q 值。</li>
</ul>
<p>想象一下，你不断更新你的指南。每次移动后，你会得到关于这个移动是好是坏的反馈（奖励）。然后，你会调整指南中的评分（Q 值）以反映这些新信息，使你未来的决策更加明智。</p>
<p>继续重复这个过程，直到 Q 值收敛，这意味着代理已经学会了在迷宫中导航的最优策略。随着时间的推移，通过反复探索迷宫并根据经验更新你的指南，你会制定出一套全面的策略，告诉你在任何给定位置做出最佳移动以最大化奖励。</p>
<h2 id="从-Q-学习到深度-Q-网络"><a href="#从-Q-学习到深度-Q-网络" class="headerlink" title="从 Q 学习到深度 Q 网络"></a>从 Q 学习到深度 Q 网络</h2><h3 id="传统-Q-学习的局限性"><a href="#传统-Q-学习的局限性" class="headerlink" title="传统 Q 学习的局限性"></a>传统 Q 学习的局限性</h3><p>虽然 Q 学习是一种强大的强化学习算法，但它有一些限制，阻碍了它在更复杂环境中的有效性：</p>
<ul>
<li><p>可扩展性问题：传统的 Q 学习维护一个 Q 表，其中每个状态-动作对都映射到一个 Q 值。随着状态空间的增长，特别是在高维度或连续环境中，Q 表变得过大，导致内存效率低下和学习过程缓慢。</p>
</li>
<li><p>离散状态和动作空间：Q 学习在状态和动作是离散和有限的环境中表现良好。然而，许多现实世界的问题涉及连续的状态和动作空间，传统的 Q 学习在不对这些空间进行离散化的情况下效率低下，这可能导致信息丢失和次优策略。</p>
</li>
</ul>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>让我们现在介绍神经网络，它在深度网络中扮演着关键角色。受到人类大脑结构和功能的启发，神经网络是强大的函数逼近器，能够从数据中学习复杂模式。它们由相互连接的节点（神经元）层组成，处理输入数据，并通过权重和偏差将其转换为输出。</p>
<p>在强化学习的背景下，神经网络可以用来逼近 Q 函数，它将状态-动作对映射到 Q 值。这使得代理能够更好地在各种状态和动作之间进行泛化，特别是在大型或连续空间中，维护 Q 表是不可行的。</p>
<p>因此，深度 Q 网络（DQNs）将 Q 学习的原理与神经网络的函数逼近能力相结合。通过这样做，它们解决了传统 Q 学习的关键局限性。</p>
<p>DQNs 不是将 Q 值存储在表中，而是使用神经网络来近似 Q 函数。该网络以状态作为输入，并为所有可能的动作输出 Q 值。通过使用来自环境的经验对网络进行训练，代理程序学会预测每个动作的预期奖励，有效地在大量状态和动作之间进行泛化。</p>
<p>想象一下，你正在学习下棋。与其记住每种可能的棋盘布局和每一步最佳走法（这是不可能的），你学习一般性的策略和原则（比如控制棋盘中心和保护国王）。同样，一个 DQN 通过神经网络学习一般模式和策略，使其能够做出明智的决策，而无需记住每种可能的状态。</p>
<p>神经网络的使用使 DQN 能够处理具有大型或连续状态空间的环境。网络可以学习状态空间的表示，捕捉关键特征，使代理能够做出明智的决策，而无需离散化空间。</p>
<p>考虑尝试在一个大城市中导航。与其记住每条街道和建筑物的布局（这就像一个巨大的 Q 表），不如学会识别地标和主要道路，这有助于您找到方向。DQN 中的神经网络工作方式类似，学会识别状态空间的重要特征，帮助代理在复杂环境中导航。</p>
<p>通过对各种经历进行训练，模型学会从过去的经历中归纳。这意味着代理可以将所学应用于新的、未曾见过的状态和行动，使其在不同情况下更具适应性和效率。</p>
<h2 id="深度-Q-网络的解剖"><a href="#深度-Q-网络的解剖" class="headerlink" title="深度 Q 网络的解剖"></a>深度 Q 网络的解剖</h2><h3 id="DQN-的组成部分"><a href="#DQN-的组成部分" class="headerlink" title="DQN 的组成部分"></a>DQN 的组成部分</h3><p>要理解深度 Q 网络（DQNs）的工作原理，必须分解它们的关键组成部分：</p>
<h4 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h4><p><img src="/../asset_deepq/02.png" alt="前馈神经网络 "></p>
<p>DQN 的核心是一个神经网络，它作为 Q 值的函数逼近器。典型的架构通常包括：</p>
<ul>
<li>输入层：将其想象为代理的“眼睛”。它接收来自环境的状态表示，类似于您的眼睛接收周围的视觉信息。这是上图左侧的第一层，有两个节点。</li>
<li>隐藏层：将这些层视为代理的“大脑”。它们通过多个思考阶段处理眼睛接收到的信息，识别复杂的特征和模式，就像你的大脑处理和理解世界一样。这是上图中具有三个节点的中间层。</li>
<li>输出层：这就像代理人的“决策”部分。它根据输入状态产生所有可能动作的 Q 值，类似于你的大脑根据所见和所想决定最佳动作。每个输出对应于采取特定动作的预期奖励。这是上图中最右边的最后一层，有一个节点。</li>
</ul>
<p>上面的图像代表了一个简单的前馈神经网络，是神经网络最基本的形式。虽然这种结构是基础的，但它还不是一个“深度”神经网络。要将其转变为深度神经网络，我们可以添加更多隐藏层，增加网络的深度。此外，我们可以尝试不同的架构和配置来开发更高级的模型。还要注意的是，每个层中的节点数量并不固定；它取决于特定的训练数据集和任务。这种灵活性使我们能够根据特定需求来定制网络。</p>
<h4 id="经历回放"><a href="#经历回放" class="headerlink" title="经历回放"></a>经历回放</h4><p>经历重放, 这是一种用于稳定和改进 DQN 学习过程的技术。它涉及：</p>
<ul>
<li>内存缓冲区：将其想象为代理的“日记”。它会随着时间而存储代理的经历（状态、动作、奖励、下一个状态、完成），就像你可能会每天写下发生在你身上的事情一样。</li>
<li>随机抽样：在训练过程中，代理人翻阅其日记的随机页面，以从过去的经历中学习。这打破了事件序列，帮助代理人通过防止过度拟合到经历顺序来更加稳健地学习。</li>
</ul>
<h4 id="目标网络"><a href="#目标网络" class="headerlink" title="目标网络"></a>目标网络</h4><p>最后，目标网络是一个单独的神经网络，用于计算目标 Q 值进行训练。它在架构上与主网络相同，但具有冻结的权重，这些权重会定期更新以匹配主网络的权重。可以将其视为代理的“稳定指南”。虽然主网络不断学习和更新，但目标网络为训练提供稳定的 Q 值。这就像有一个可靠的、定期更新的手册可供参考，有助于保持学习的稳定性和一致性。</p>
<h3 id="DQN-算法"><a href="#DQN-算法" class="headerlink" title="DQN 算法"></a>DQN 算法</h3><p>有了这些组件，DQN 算法可以在几个关键步骤中概述：</p>
<h4 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h4><p>首先，我们从前向传播开始，这对于预测 Q 值至关重要。这些 Q 值存储了在给定状态下采取某些行动的预期未来奖励。该过程始于状态输入。</p>
<ul>
<li><p>状态输入：<br>代理人从环境中观察当前状态 s。这个状态被表示为描述代理人当前情况的特征向量。将状态视为代理人周围世界的快照，类似于您环顾四周时眼睛捕捉视觉场景。这个快照包含了代理人做出决策所需的所有必要细节。</p>
</li>
<li><p>Q 值预测：<br>接下来，观察到的状态 s 被输入神经网络。神经网络通过多层处理这个输入，并输出一组 Q 值 Q(s, a; θ)。每个 Q 值对应一个可能的动作 a，参数 θ 表示网络的权重和偏差。</p>
</li>
</ul>
<p><img src="/../asset_deepq/03.png" alt="Q 值预测公式"></p>
<p>想象神经网络是代理的大脑中的一个复杂决策机器。当它接收到快照（状态）时，它通过几个阶段（层）处理这些信息，以找出不同行动的潜在结果（Q 值）。就像你的大脑根据所见的情况思考不同可能的行动一样。</p>
<ul>
<li>行动选择：<br>代理然后选择具有最高 Q 值的动作 a∗作为其下一步行动，遵循贪婪动作选择策略：</li>
</ul>
<p><img src="/../asset_deepq/04.png" alt="行动选择公式"></p>
<p>这就好比在深思熟虑所有选项后决定最佳行动。代理人选择它认为会带来最高奖励的行动，就像你根据所见和理解选择似乎最有前途的道路一样。</p>
<h4 id="经历重播"><a href="#经历重播" class="headerlink" title="经历重播"></a>经历重播</h4><p>接下来，我们继续进行经历重演，这有助于稳定和改善学习过程。</p>
<ul>
<li><p>记录经历：<br>代理程序执行动作 a 并获得奖励 r 和新状态 s′ 后，将这一经历存储为一个元组(s, a, r, s′, done) 放入重放缓冲区。变量 done 表示该情节是否已结束。可以将重放缓冲区视为代理程序记录经历的日记，就像记录一天中值得注意的事件一样。</p>
</li>
<li><p>小批量取样:<br>在训练期间，一小批经历从重播缓冲区中随机抽取。这一批数据用于通过计算目标 Q 值和最小化损失来更新网络。当代理进行训练时，它会翻阅其日记的随机页面，以从过去的经历中学习。这种随机抽样有助于打破事件序列，并提供多样化的学习示例，就像查看日记中不同日期以获得更广泛的视角一样。</p>
</li>
</ul>
<p><img src="/../asset_deepq/05.png" alt="深度 Q 网络中的小批量学习"></p>
<h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><p>最后一步涉及反向传播，它更新网络以改善其预测。</p>
<ul>
<li>计算目标 Q 值：<br>对于小批量中的每个经历，代理计算目标 Q 值 y_。如果下一个状态 s’是终止状态（done即为真），目标 Q 值就是简单的奖励 r。否则，它是奖励加上由目标网络 Qtarget 预测的下一个状态 s’ 的最大 Q 值的折扣：</li>
</ul>
<p><img src="/../asset_deepq/06.png" alt=" "></p>
<p>在这里，γ是折扣因子（0 ≤ γ &lt; 1）。这一步就像是基于过去的经历提前规划。如果经历结束了一段旅程（一个回合），目标就是所获得的奖励。如果继续下去，目标就包括了预期的未来奖励，类似于你考虑即时和未来利益来规划行动的方式。</p>
<ul>
<li>损失计算:<br>接下来，损失被计算为主网络预测的 Q 值 Q(s_i, a_i; θ)与目标 Q 值 y_i 之间的均方误差：</li>
</ul>
<p><img src="/../asset_deepq/07.png" alt="损失公式"></p>
<p>计算损失就像评估你的预测与实际发生情况之间的差距。就像检查你的猜测与实际结果相比有多准确，并注意其中的差异。</p>
<ul>
<li>反向传播和优化:<br>最后，执行反向传播以最小化这种损失。计算得到的损失通过网络进行反向传播，使用优化算法（如随机梯度下降（SGD）或 Adam）来更新权重。这个过程调整网络参数θ 以最小化损失：</li>
</ul>
<p><img src="/../asset_deepq/08.png" alt="反向传播公式 "></p>
<p>这里，α是学习率，∇θ​Loss 代表损失对网络参数的梯度。反向传播就像从错误中学习一样。当你意识到你的预测有多么偏离（损失）时，你会调整你的策略（网络权重）来改善你未来的决策。这就像根据反馈来微调你的方法，以便下次获得更好的结果。</p>
<p>使用这种架构，代理程序会迭代地改进其策略。它学会采取行动，以最大化随时间累积的奖励。神经网络、经历重放和目标网络的结合使得 DQN 能够在复杂的高维环境中有效学习。这个过程会持续下去，直到代理程序能够熟练地在其环境中导航。</p>
<h2 id="从头开始实现深度-Q-网络"><a href="#从头开始实现深度-Q-网络" class="headerlink" title="从头开始实现深度 Q 网络"></a>从头开始实现深度 Q 网络</h2><p>我们从0开始实现一个深度 Q 网络（DQN）。这样可以清楚地了解如何在 Python 中构建和训练一个 DQN。</p>
<p>我们将使用 OpenAI Gym 的LunarLander 环境。在这个环境中，目标是控制月球着陆器并成功降落在指定的着陆垫上。着陆器必须通过环境，使用推进器来控制其运动和方向。</p>
<h3 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gymnasium             0.29.1</span><br><span class="line">matplotlib            3.8.4</span><br><span class="line">numpy                 1.26.4</span><br><span class="line">optuna                3.6.1</span><br><span class="line">torch                 2.1.0+cu121</span><br><span class="line">torchaudio            2.1.0+cu121</span><br><span class="line">torchvision           0.16.0+cu121</span><br><span class="line">swig                  4.2.1</span><br><span class="line">moviepy               1.0.3</span><br></pre></td></tr></table></figure>
<p>安装box2D：  pip install gymnasium[box2d]</p>
<p>在win10系统会安装失败，显示log如下。安装微软工具，然后继续安装box2d 。</p>
<pre><code>Failed to build box2d-py
ERROR: Could not build wheels for box2d-py, which is required to install pyproject.toml-based projects
</code></pre>
<p>登录该网站<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/">build-tools</a> ，点击下载生成工具. 勾选使用C++的桌面开发，点击安装.</p>
<p><img src="/../asset_deepq/11.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"><span class="keyword">from</span> gymnasium.wrappers.monitoring.video_recorder <span class="keyword">import</span> VideoRecorder</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> optuna</span><br><span class="line"><span class="keyword">import</span> gc</span><br></pre></td></tr></table></figure>
<p>在这里，我们导入必要的库。 gym用于环境，torch用于构建和训练我们的神经网络，collections和 random、optuna 用于经历重放和超参数优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&#x27;LunarLander-v2&#x27;</span>, render_mode=<span class="string">&quot;rgb_array&quot;</span>)</span><br><span class="line">state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">action_dim = env.action_space.n</span><br></pre></td></tr></table></figure>

<p>我们初始化 LunarLander 环境并获取状态和动作空间的维度。state_dim表示状态中的特征数量，action_dim表示可能动作的数量。</p>
<h3 id="构建深度神经网络"><a href="#构建深度神经网络" class="headerlink" title="构建深度神经网络"></a>构建深度神经网络</h3><p>对于我们的深度神经网络，我们将创建一个名为DQN的类。这个类定义了一个具有三个全连接层的神经网络。输入层接收状态表示，隐藏层通过线性变换和 ReLU 激活函数处理这些信息，输出层为每个可能的动作产生 Q 值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state_dim, action_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(DQN, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(state_dim, <span class="number">128</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">128</span>, action_dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = torch.relu(self.fc1(x))</span><br><span class="line">        x = torch.relu(self.fc2(x))</span><br><span class="line">        <span class="keyword">return</span> self.fc3(x)</span><br></pre></td></tr></table></figure>

<p>我们定义一个名为DQN的类，它继承自 nn.Module，这是 PyTorch 中所有神经网络模块的基类。这使我们能够利用 PyTorch 的内置函数和特性来构建神经网络。</p>
<h4 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h4><p>__init__方法是一种特殊的方法，用于初始化对象的属性。在我们这个例子，它设置了神经网络的每一层。</p>
<p>我们定义三个全连接（线性）层：</p>
<ul>
<li>self.fc1 &#x3D; nn.Linear(state_dim, 128) ：第一层接受输入状态维度（状态中的特征数量）并将其映射到 128 个神经元。</li>
<li>self.fc2 &#x3D; nn.Linear(128, 128): 第二层将来自第一层的 128 个神经元映射到另外 128 个神经元。</li>
<li>self.fc3 &#x3D; nn.Linear(128, action_dim): 第三层将来自第二层的 128 个神经元映射到动作维度（可能动作数量）。</li>
</ul>
<p>每一层nn.Linear对输入数据执行线性变换：</p>
<p><img src="/../asset_deepq/09.png" alt="线性变换"></p>
<p>其中 x 是输入，W 是权重矩阵，b 是偏置向量。</p>
<h4 id="forward方法"><a href="#forward方法" class="headerlink" title="forward方法"></a>forward方法</h4><p>forward方法定义了数据如何在网络中流动。当您通过网络传递数据时，该方法会自动调用。</p>
<p>在第一层中，输入数据x通过第一个全连接层self.fc1传递。然后使用 ReLU（修正线性单元）激活函数进行转换。</p>
<p>ReLU 激活函数定义为：</p>
<p><img src="/../asset_deepq/10.png" alt="ReLU 激活函数公式"></p>
<p>它将非线性引入模型中，使网络能够学习更复杂的函数。</p>
<p>在第二层中，来自第一层的输出通过第二个全连接层（self.fc2）传递，并再次使用 ReLU 激活函数进行转换.</p>
<p>最后，在输出层，第二层的输出通过第三个全连接层（self.fc3）传递，没有激活函数. 该层为每个动作生成最终的 Q 值。每个值代表在给定状态下采取该动作的预期未来奖励。</p>
<h3 id="实现经历回放"><a href="#实现经历回放" class="headerlink" title="实现经历回放"></a>实现经历回放</h3><p>该ReplayBuffer类提供了一种存储和采样经历的机制，这对于稳定和改进 DQNs 中的学习过程至关重要。因此，它使代理能够从各种过去经历中学习，增强其泛化能力，并在复杂环境中表现良好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplayBuffer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        self.buffer = deque(maxlen=capacity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span><br><span class="line">        self.buffer.append((state, action, reward, next_state, done))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, batch_size</span>):</span><br><span class="line">        state, action, reward, next_state, done = <span class="built_in">zip</span>(*random.sample(self.buffer, batch_size))</span><br><span class="line">        <span class="keyword">return</span> state, action, reward, next_state, done</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.buffer)</span><br></pre></td></tr></table></figure>

<h4 id="类初始化-1"><a href="#类初始化-1" class="headerlink" title="类初始化"></a>类初始化</h4><p>__init__方法使用固定容量初始化双端队列。双端队列允许您高效地从两端添加和弹出数据。它特别适用于实现需要快速从两端添加和弹出数据的队列和栈。<br>self.buffer &#x3D; deque(maxlen&#x3D;capacity) 实际上创建了一个 deque，可以容纳capacity个的经历。当缓冲区已满时，添加新经历将自动删除最旧的经历。</p>
<h4 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h4><p>该push 方法向缓冲区添加新经历。每个经历都是一个元组，包括state，action，reward，next_state和done：</p>
<ul>
<li>state ：当前状态。</li>
<li>action ：代理人采取的行动。</li>
<li>reward ：执行动作后获得的奖励。</li>
<li>next_state ：代理采取行动后得到的状态。</li>
<li>done ：一个布尔值，指示该场景是否已结束。</li>
</ul>
<h4 id="采样方法"><a href="#采样方法" class="headerlink" title="采样方法"></a>采样方法</h4><p>该sample方法从缓冲区中随机采样一批经历。<br>random.sample(self.buffer, batch_size) 从缓冲区中随机选择batch_size 经历。 </p>
<p>zip(*random.sample(self.buffer, batch_size)) 将经历列表解压成单独的元组，赋值于state， action， reward， next_state， done</p>
<p>该方法返回这些元组。</p>
<h4 id="length方法"><a href="#length方法" class="headerlink" title="length方法"></a>length方法</h4><p>__len__方法返回缓冲区中存储的当前经历数量。 </p>
<h3 id="实现目标网络"><a href="#实现目标网络" class="headerlink" title="实现目标网络"></a>实现目标网络</h3><p>目标网络，我们为训练提供了一组稳定的 Q 值，这有助于稳定学习过程并提高代理在复杂环境中的性能。目标网络更新频率低于主网络，确保用于更新主网络权重的 Q 值估计更加稳定。</p>
<p>我们将在一个名为DQNTrainer的类中实现目标网络，该类管理 DQN 的训练过程，包括主网络、目标网络、优化器和重放缓冲区。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DQNTrainer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, env, main_network, target_network, optimizer, replay_buffer, model_path=<span class="string">&#x27;model/model.pth&#x27;</span>, gamma=<span class="number">0.99</span>, batch_size=<span class="number">64</span>, target_update_frequency=<span class="number">1000</span></span>):</span><br><span class="line">        self.env = env</span><br><span class="line">        self.main_network = main_network</span><br><span class="line">        self.target_network = target_network</span><br><span class="line">        self.optimizer = optimizer</span><br><span class="line">        self.replay_buffer = replay_buffer</span><br><span class="line">        self.model_path = model_path</span><br><span class="line">        self.gamma = gamma</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.target_update_frequency = target_update_frequency</span><br><span class="line">        self.step_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load the model if it exists</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(os.path.dirname(self.model_path)):</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(self.model_path):</span><br><span class="line">                self.main_network.load_state_dict(torch.load(self.model_path))</span><br><span class="line">                self.target_network.load_state_dict(torch.load(self.model_path))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Loaded model from disk&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            os.makedirs(os.path.dirname(self.model_path))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, num_episodes, save_model=SAVE_MODEL, save_video=SAVE_VIDEO</span>):</span><br><span class="line">        total_rewards = []</span><br><span class="line">        max_video_frames_size = <span class="number">10000</span>  <span class="comment"># Example size, adjust as needed</span></span><br><span class="line">        max_steps_on_episode = <span class="number">5000</span>  <span class="comment"># Example size, adjust as needed</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a VideoWriter to save the rendering</span></span><br><span class="line">        <span class="keyword">if</span> save_video:</span><br><span class="line">            base_video_path = os.path.join(os.path.expanduser(<span class="string">&#x27;~&#x27;</span>), <span class="string">&#x27;deepq/training_&#x27;</span>)</span><br><span class="line">            video_number = <span class="number">1</span></span><br><span class="line">            video_path = <span class="string">f&quot;<span class="subst">&#123;base_video_path&#125;</span><span class="subst">&#123;video_number&#125;</span>.mp4&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.path.dirname(video_path)):</span><br><span class="line">                os.makedirs(os.path.dirname(video_path))</span><br><span class="line">            video_recorder = VideoRecorder(env, video_path, enabled=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(num_episodes):</span><br><span class="line">            state, _ = self.env.reset()  <span class="comment"># Extract the state from the returned tuple</span></span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            steps_on_episode = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">                self.env.render()  <span class="comment"># Add this line to render the environment</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> save_video:</span><br><span class="line">                    video_recorder.capture_frame()</span><br><span class="line">                    <span class="comment"># avoid memory OOM, because capture_frame will consume memory</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(video_recorder.recorded_frames) &gt;= max_video_frames_size:</span><br><span class="line">                        video_recorder.close()</span><br><span class="line">                        <span class="keyword">del</span> video_recorder</span><br><span class="line">                        gc.collect()</span><br><span class="line">                        video_number += <span class="number">1</span></span><br><span class="line">                        video_path = <span class="string">f&quot;<span class="subst">&#123;base_video_path&#125;</span><span class="subst">&#123;video_number&#125;</span>.mp4&quot;</span></span><br><span class="line">                        video_recorder = VideoRecorder(env, video_path, enabled=<span class="literal">True</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Ensure the state is in the correct shape by adding an extra dimension</span></span><br><span class="line">                action = self.main_network(torch.FloatTensor(state).unsqueeze(<span class="number">0</span>)).argmax(dim=<span class="number">1</span>).item()</span><br><span class="line">                next_state, reward, done, _, _ = self.env.step(action)  <span class="comment"># Extract the next_state from the returned tuple</span></span><br><span class="line">                self.replay_buffer.push(state, action, reward, next_state, done)</span><br><span class="line">                state = next_state</span><br><span class="line">                total_reward += reward</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt;= self.batch_size:</span><br><span class="line">                    self.update_network()</span><br><span class="line"></span><br><span class="line">                steps_on_episode += <span class="number">1</span></span><br><span class="line">                <span class="comment"># avoid one episode process long time</span></span><br><span class="line">                <span class="keyword">if</span> steps_on_episode &gt; max_steps_on_episode:</span><br><span class="line">                    done = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            total_rewards.append(total_reward)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Episode <span class="subst">&#123;episode&#125;</span>, Total Reward: <span class="subst">&#123;total_reward&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save the model after training</span></span><br><span class="line">        <span class="keyword">if</span> save_model:</span><br><span class="line">            torch.save(self.main_network.state_dict(), self.model_path)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Saved model to disk&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> save_video:</span><br><span class="line">             <span class="comment"># Save any remaining frames in the buffer</span></span><br><span class="line">            <span class="keyword">if</span> video_recorder:</span><br><span class="line">                video_recorder.close()</span><br><span class="line"></span><br><span class="line">        self.env.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(total_rewards) / <span class="built_in">len</span>(total_rewards)  <span class="comment"># Return average reward</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_network</span>(<span class="params">self</span>):</span><br><span class="line">        state_batch, action_batch, reward_batch, next_state_batch, done_batch = self.replay_buffer.sample(self.batch_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert to tensors</span></span><br><span class="line">        state_batch = torch.FloatTensor(state_batch)</span><br><span class="line">        action_batch = torch.LongTensor(action_batch)</span><br><span class="line">        reward_batch = torch.FloatTensor(reward_batch)</span><br><span class="line">        next_state_batch = torch.FloatTensor(next_state_batch)</span><br><span class="line">        done_batch = torch.FloatTensor(done_batch)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate the current Q-values</span></span><br><span class="line">        q_values = self.main_network(state_batch).gather(<span class="number">1</span>, action_batch.unsqueeze(<span class="number">1</span>)).squeeze(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate the target Q-values</span></span><br><span class="line">        next_q_values = self.target_network(next_state_batch).<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        expected_q_values = reward_batch + self.gamma * next_q_values * (<span class="number">1</span> - done_batch)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute the loss</span></span><br><span class="line">        loss = nn.MSELoss()(q_values, expected_q_values.detach())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Optimize the model</span></span><br><span class="line">        self.optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Periodically update the target network</span></span><br><span class="line">        <span class="keyword">if</span> self.step_count % self.target_update_frequency == <span class="number">0</span>:</span><br><span class="line">            self.target_network.load_state_dict(self.main_network.state_dict())</span><br><span class="line"></span><br><span class="line">        self.step_count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>__init__方法初始化了训练所需的各种组件： </p>
<ul>
<li>env ：代理程序运行的环境。</li>
<li>main_network ：正在训练的主要神经网络。</li>
<li>target_network ：用于稳定 Q 值估计的目标神经网络。</li>
<li>optimizer ：用于更新主网络权重的优化器。</li>
<li>replay_buffer ：用于存储和采样经历的缓冲区。</li>
<li>model_path ：保存&#x2F;加载训练模型的路径。</li>
<li>gamma ：未来奖励的折现因子。</li>
<li>batch_size ：每个训练步骤从replay缓冲区中采样的经历数量。</li>
<li>target_update_frequency ：匹配主网络权重的目标网络权重更新频率</li>
<li>step_count ：一个用于跟踪训练过程中步骤数量的计数器。</li>
</ul>
<h4 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h4><p>我们用 os.path.exists(os.path.dirname(self.model_path)) 检查模型路径的目录是否存在。如果存在已保存的模型，则加载该模型以继续训练，从离开的地方继续 。</p>
<p>torch.load 使用 load_state_dict 将保存的模型权重加载到主网络和目标网络中。如果模型目录不存在，则使用 os.makedirs 创建它。</p>
<h3 id="训练深度-Q-网络"><a href="#训练深度-Q-网络" class="headerlink" title="训练深度 Q 网络"></a>训练深度 Q 网络</h3><p>接下来，我们将实现训练循环来训练我们的 DQN。这个DQNTrainer方法发生在内部。它运行 DQN 的训练循环，代理与环境交互，收集经验，更新网络，并跟踪性能。<br>train方法运行指定回合数量的训练循环。这个循环对于代理获取经验并提高其决策能力至关重要。</p>
<p>首先将total_rewards 初始化为空列表。 在每个回合开始时，环境会被重置到初始状态。 代理根据当前状态使用主网络选择动作。</p>
<p>torch.FloatTensor(state).unsqueeze(0) 将状态转换为 PyTorch 张量，并添加额外的维度以匹配网络的预期输入形状。</p>
<p>self.main_network(…).argmax(dim&#x3D;1).item() 选择由主网络预测的具有最高 Q 值的动作。</p>
<p>代理程序执行所选动作，观察奖励和下一个状态，并将经历存储在重放缓冲区中。</p>
<p>self.env.step(action) 执行动作并返回下一个状态、奖励以及该情节是否已结束。</p>
<p>self.replay_buffer.push(…) 将经历存储在重放缓冲区中。</p>
<p>state &#x3D; next_state 将当前状态更新为下一个状态。</p>
<p>total_reward +&#x3D; reward 累积当前回合的奖励。</p>
<p>如果重放缓冲区有足够的经历，网络就会被更新。</p>
<p>if len(self.replay_buffer) &gt;&#x3D; self.batch_size 检查回放缓冲区是否至少有batch_size经验。 </p>
<p>self.update_network() 使用来自重放缓冲区的一批经历更新网络。</p>
<p>每个回合结束时记录并打印总奖励。</p>
<p>total_rewards.append(total_reward) 将当前回合的总奖励添加到总奖励列表中。</p>
<p>训练完成后，模型被保存到磁盘。</p>
<p>torch.save(self.main_network.state_dict(), self.model_path) 将主网络的状态字典保存到指定的文件路径。</p>
<p>最后，该方法关闭环境并返回所有剧集的平均奖励。</p>
<p>return sum(total_rewards) &#x2F; len(total_rewards) 计算并返回平均奖励。</p>
<h3 id="调整模型"><a href="#调整模型" class="headerlink" title="调整模型"></a>调整模型</h3><p>最后，我们将看看如何评估和调整训练模型。让我们构建一个Optimizer类，负责优化超参数以提高 DQN 的性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Optimizer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, env, main_network, target_network, replay_buffer, model_path, params_path=<span class="string">&#x27;params.pkl&#x27;</span></span>):</span><br><span class="line">        self.env = env</span><br><span class="line">        self.main_network = main_network</span><br><span class="line">        self.target_network = target_network</span><br><span class="line">        self.replay_buffer = replay_buffer</span><br><span class="line">        self.model_path = model_path</span><br><span class="line">        self.params_path = params_path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">self, trial, n_episodes=<span class="number">10</span></span>):</span><br><span class="line">        lr = trial.suggest_loguniform(<span class="string">&#x27;lr&#x27;</span>, <span class="number">1e-5</span>, <span class="number">1e-1</span>)</span><br><span class="line">        gamma = trial.suggest_uniform(<span class="string">&#x27;gamma&#x27;</span>, <span class="number">0.9</span>, <span class="number">0.999</span>)</span><br><span class="line">        batch_size = trial.suggest_categorical(<span class="string">&#x27;batch_size&#x27;</span>, [<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>])</span><br><span class="line">        target_update_frequency = trial.suggest_categorical(<span class="string">&#x27;target_update_frequency&#x27;</span>, [<span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>])</span><br><span class="line"></span><br><span class="line">        optimizer = optim.Adam(self.main_network.parameters(), lr=lr)</span><br><span class="line">        trainer = DQNTrainer(self.env, self.main_network, self.target_network, optimizer, self.replay_buffer, self.model_path, gamma=gamma, batch_size=batch_size, target_update_frequency=target_update_frequency)</span><br><span class="line">        reward = trainer.train(n_episodes, save=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> reward</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">optimize</span>(<span class="params">self, n_trials=<span class="number">100</span>, save_params=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> TRAIN <span class="keyword">and</span> os.path.isfile(self.params_path):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.params_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                best_params = pickle.load(f)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Loaded parameters from disk&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> FINETUNE:</span><br><span class="line">            best_params = &#123;</span><br><span class="line">                <span class="string">&#x27;lr&#x27;</span>: LEARNING_RATE, </span><br><span class="line">                <span class="string">&#x27;gamma&#x27;</span>: GAMMA, </span><br><span class="line">                <span class="string">&#x27;batch_size&#x27;</span>: BATCH_SIZE, </span><br><span class="line">                <span class="string">&#x27;target_update_frequency&#x27;</span>: TARGET_UPDATE_FREQUENCY</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Using default parameters: <span class="subst">&#123;best_params&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Optimizing hyperparameters&quot;</span>)</span><br><span class="line">            study = optuna.create_study(direction=<span class="string">&#x27;maximize&#x27;</span>)</span><br><span class="line">            study.optimize(self.objective, n_trials=n_trials)</span><br><span class="line">            best_params = study.best_params</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> save_params:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(self.params_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    pickle.dump(best_params, f)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Saved parameters to disk&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best_params</span><br></pre></td></tr></table></figure>

<h4 id="objective方法建议超参数的值，并使用这些值训练模型"><a href="#objective方法建议超参数的值，并使用这些值训练模型" class="headerlink" title="objective方法建议超参数的值，并使用这些值训练模型"></a>objective方法建议超参数的值，并使用这些值训练模型</h4><ul>
<li>lr &#x3D; trial.suggest_loguniform(‘lr’, 1e-5, 1e-1) ：建议学习率在[1e-5, 1e-1]范围内。</li>
<li>gamma &#x3D; trial.suggest_uniform(‘gamma’, 0.9, 0.999) ：建议在范围[0.9, 0.999]内选择折扣因子。</li>
<li>batch_size &#x3D; trial.suggest_categorical(‘batch_size’, [32, 64, 128]) ：建议从指定列表中选择一个批次大小。</li>
<li>target_update_frequency &#x3D; trial.suggest_categorical(‘target_update_frequency’, [500, 1000, 2000]) ：建议从指定列表中选择目标更新频率。</li>
</ul>
<p>我们使用建议的学习率设置了一个 Adam 优化器。Adam（自适应矩估计的缩写）是一种常用于训练神经网络的优化算法。</p>
<p>对于神经网络中的每个参数，Adam 计算损失函数对该参数的梯度。它跟踪梯度的指数移动平均值（第一时刻，表示为 m）和平方梯度（第二时刻，表示为 v）。</p>
<p>为了考虑移动平均数的初始化偏差，Adam 对第一和第二时刻的估计值应用偏差校正。然后使用校正后的第一和第二时刻来更新参数。更新规则旨在结合学习率和时刻，以一种考虑梯度的大小和方向的方式调整参数。</p>
<p>使用建议的超参数初始化DQNTrainer 实例。 最后，为模型训练指定数量的周期，并返回平均奖励</p>
<h4 id="Optimize方法，该方法运行指定次数的优化过程"><a href="#Optimize方法，该方法运行指定次数的优化过程" class="headerlink" title="Optimize方法，该方法运行指定次数的优化过程"></a>Optimize方法，该方法运行指定次数的优化过程</h4><p>我们使用 Optuna，这是一个 Python 库，它将帮助我们系统地探索超参数空间，高效地找到最大化模型性能的组合。</p>
<p>如果不需要训练(not TRAIN)并且参数文件存在，则从磁盘加载参数。</p>
<p>如果不需要微调（not FINETUNE），则使用默认参数。 </p>
<p>如果需要超参数优化，将使用 Optuna 来找到最佳参数。</p>
<p>study &#x3D; optuna.create_study(direction&#x3D;’maximize’) 创建一个 Optuna study以最大化objective函数。</p>
<p>study.optimize(self.objective, n_trials&#x3D;n_trials) 运行指定次数的优化。</p>
<p>如果save_params是True，则最佳参数将保存到磁盘。</p>
<h3 id="运行模型"><a href="#运行模型" class="headerlink" title="运行模型"></a>运行模型</h3><h4 id="设置训练和微调"><a href="#设置训练和微调" class="headerlink" title="设置训练和微调"></a>设置训练和微调</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TRAIN = <span class="literal">True</span></span><br><span class="line">FINETUNE = <span class="literal">False</span></span><br><span class="line">SAVE_MODEL = <span class="literal">True</span> <span class="comment"># Save the model after training</span></span><br><span class="line">SAVE_VIDEO = <span class="literal">False</span> <span class="comment"># Save the video of the training process</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Training hyperparameters</span></span><br><span class="line">TRAINING_EPISODES = <span class="number">1000</span> <span class="comment"># valid only if TRAIN is True</span></span><br><span class="line">FINETUNE_TRIALS = <span class="number">100</span> <span class="comment"># valid only if FINETUNE is True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the following hyperparameters if FINETUNE is False</span></span><br><span class="line">GAMMA = <span class="number">0.99</span></span><br><span class="line">BATCH_SIZE = <span class="number">64</span></span><br><span class="line">TARGET_UPDATE_FREQUENCY = <span class="number">1000</span></span><br><span class="line">LEARNING_RATE = <span class="number">1e-3</span></span><br></pre></td></tr></table></figure>

<p>TRAIN &#x3D; True 表示是否训练模型。如果设置为False，训练将被跳过。 </p>
<p>FINETUNE &#x3D; False 表示是否微调模型。如果设置为True，将使用现有参数并进行微调。</p>
<p>如果FINETUNE是False，我们设置以下超参数： </p>
<ul>
<li>GAMMA &#x3D; 0.99 ：未来奖励的折现因子。这决定了未来奖励相对于即时奖励的价值有多大。</li>
<li>BATCH_SIZE &#x3D; 64 ：每个训练步骤从重播缓冲区中采样的经历数量。</li>
<li>TARGET_UPDATE_FREQUENCY &#x3D; 1000 ：匹配主网络权重的目标网络权重更新的频率（以步数计）。</li>
<li>LEARNING_RATE &#x3D; 1e-3 ：优化器的学习率，控制模型在每次更新模型权重时根据估计误差进行的改变大小。</li>
</ul>
<h4 id="初始化网络和重放缓冲区"><a href="#初始化网络和重放缓冲区" class="headerlink" title="初始化网络和重放缓冲区"></a>初始化网络和重放缓冲区</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main_network = DQN(state_dim, action_dim)</span><br><span class="line">target_network = DQN(state_dim, action_dim)</span><br><span class="line">target_network.load_state_dict(main_network.state_dict())</span><br><span class="line">target_network.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">replay_buffer = ReplayBuffer(<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>


<p>main_network &#x3D; DQN(state_dim, action_dim) 使用指定的状态和动作维度初始化主网络。</p>
<p>target_network &#x3D; DQN(state_dim, action_dim) 使用与主网络相同的架构初始化目标网络。</p>
<p>target_network.load_state_dict(main_network.state_dict()) 将权重从主网络复制到目标网络。</p>
<p>target_network.eval() 将目标网络设置为评估模式。这可以确保在推断期间某些层（如 dropout 和批量归一化）的行为是适当的。</p>
<p>replay_buffer &#x3D; ReplayBuffer(10000) 使用容量为 10,000 的重放缓冲区进行初始化。</p>
<h4 id="设置步数"><a href="#设置步数" class="headerlink" title="设置步数"></a>设置步数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STEP_COUNT = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>STEP_COUNT &#x3D; 0 初始化一个计数器，用于跟踪训练过程中所采取的步骤数量。</p>
<h4 id="优化器初始化和超参数优化"><a href="#优化器初始化和超参数优化" class="headerlink" title="优化器初始化和超参数优化"></a>优化器初始化和超参数优化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">home_directory = os.path.expanduser(<span class="string">&#x27;~&#x27;</span>)</span><br><span class="line"></span><br><span class="line">optimizer = Optimizer(env, main_network, target_network, replay_buffer, <span class="string">f&#x27;<span class="subst">&#123;home_directory&#125;</span>/model/model.pth&#x27;</span>, <span class="string">f&#x27;<span class="subst">&#123;home_directory&#125;</span>/model/params.pkl&#x27;</span>)</span><br><span class="line">best_params = optimizer.optimize(n_trials=<span class="number">2</span>, save_params=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>optimizer &#x3D; Optimizer(…) 使用环境、网络、重放缓冲区、模型路径和参数路径初始化Optimizer 类。</p>
<p>best_params &#x3D; optimizer.optimize(n_trials&#x3D;2, save_params&#x3D;True) 运行优化过程以找到最佳超参数。这个函数：</p>
<ul>
<li>运行指定次数的优化（n_trials&#x3D;2）。 </li>
<li>如果save_params是True，则将最佳超参数保存到磁盘。</li>
</ul>
<h4 id="创建-PyTorch-优化器和-DQN-训练器"><a href="#创建-PyTorch-优化器和-DQN-训练器" class="headerlink" title="创建 PyTorch 优化器和 DQN 训练器"></a>创建 PyTorch 优化器和 DQN 训练器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.Adam(main_network.parameters(), lr=best_params[<span class="string">&#x27;lr&#x27;</span>])</span><br><span class="line">trainer = DQNTrainer(env, main_network, target_network, optimizer, replay_buffer, <span class="string">f&#x27;<span class="subst">&#123;home_directory&#125;</span>/model/model.pth&#x27;</span>, gamma=best_params[<span class="string">&#x27;gamma&#x27;</span>], batch_size=best_params[<span class="string">&#x27;batch_size&#x27;</span>], target_update_frequency=best_params[<span class="string">&#x27;target_update_frequency&#x27;</span>])</span><br><span class="line">trainer.train(TRAINING_EPISODES, save_model=SAVE_MODEL, save_video=SAVE_VIDEO)</span><br></pre></td></tr></table></figure>

<p>optimizer &#x3D; optim.Adam(main_network.parameters(), lr&#x3D;best_params[‘lr’]) 使用最佳超参数创建一个 Adam 优化器。</p>
<p>trainer &#x3D; DQNTrainer(…) 使用最佳参数从环境、网络、优化器、重放缓冲区、模型路径和超参数初始化DQNTrainer 类。 </p>
<p>trainer.train(…) 为模型训练了 TRAINING_EPISODES 个周期。</p>
<p>代理在培训的前 10 回合中的表现：</p>
<p><img src="/../asset_deepq/11.gif"></p>
<p>可以看到模型笨拙，做出随机且经常是次优的决策。这是预期的，因为代理仍在探索环境并学习基础知识。它还没有制定出最大化奖励的强大策略。随着更多的训练周期，代理的表现应该会显著提高，因为它不断完善其策略并从经验中学习。</p>
<p>模型训练了 1000 次后的 10 个训练集</p>
<p><img src="/../asset_deepq/12.gif"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>采用先进技术并探索新架构，以提高您的代理性能。例如，您可以尝试设置不同的超参数，使用不同的优化算法（如 SGD 或 Nadam），使用不同的微调算法等等！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/reinforcement-learning-from-scratch-deep-q-networks-0a8d33ce165b">https://towardsdatascience.com/reinforcement-learning-from-scratch-deep-q-networks-0a8d33ce165b</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/05/20/voice-with-llama3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/20/voice-with-llama3/" class="post-title-link" itemprop="url">用llama3实现语音助手</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-20 15:51:55" itemprop="dateCreated datePublished" datetime="2024-05-20T15:51:55+08:00">2024-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-27 17:28:26" itemprop="dateModified" datetime="2024-05-27T17:28:26+08:00">2024-05-27</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>Whisper: 由 OpenAI 开发，Whisper 擅长将口语转录为文本。其理解和处理多种语言的能力使其成为任何基于语音的应用程序的必不可少的工具。</p>
<p>LangChain 用于协调组件处理模型和数据库的复杂用户交互。</p>
<p>矢量数据库（Qdrant）：Qdrant 旨在高效处理高维数据，使其非常适用于依赖机器学习和大规模数据检索的应用程序。</p>
<p>检索增强生成（RAG）：RAG 结合了检索和生成模型的优点，使我们的语音助手能够利用大量信息数据库生成明智和具有上下文相关性的回应。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul>
<li><p>transformers（4.33.0）：提供了各种预构建模型，用于文本翻译和摘要等语言任务，使其成为语言项目的关键工具。</p>
</li>
<li><p>accelerate （0.22.0）：帮助在不需要改变太多代码的情况下，在不同类型的计算机硬件上运行机器学习模型，如 CPU 或 GPU。</p>
</li>
<li><p>einops (0.6.1)：使得在机器学习中使用的数据结构更易于处理和改变形状，有助于构建复杂模型。</p>
</li>
<li><p>langchain (0.0.300)：用于将不同的语言技术结合到一个应用程序中，特别适用于需要多个处理步骤的项目。</p>
</li>
<li><p>xformers（0.0.22.post7）：提供模型的部分，这些部分在学习和使用阶段都能够高效处理数据。</p>
</li>
<li><p>bitsandbytes-windows（windows版本）：有助于更快地训练深度学习模型，并且占用更少的内存，非常适合处理大型数据集。</p>
</li>
<li><p>sentence_transformers (2.2.2)：基于 transformers 库构建详细特征，对于需要理解文本之间相似性的任务非常重要。</p>
</li>
</ul>
<p>让我们首先建立一个虚拟环境并安装库。打开命令行界面 ，然后运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a virtual environment</span></span><br><span class="line">conda create -n llama3-whisper python=3.11</span><br><span class="line">conda activate llama3-whisper</span><br></pre></td></tr></table></figure>

<p>我的CUDA版本是12.1，如果在线安装torch 持续中断失败，可以去下载 <a target="_blank" rel="noopener" href="https://download.pytorch.org/whl/">wheel</a> 文件，然后本地安装。</p>
<p>在线安装torch：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch==2.1.0 torchvision==0.16.0 torchaudio==2.1.0 --index-url https://download.pytorch.org/whl/cu121</span><br></pre></td></tr></table></figure>

<p>本地安装torch，进入wheel文件所在的目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">&quot;torch-2.1.0+cu121-cp311-cp311-win_amd64.whl&quot;</span> </span><br><span class="line">pip install <span class="string">&quot;torchaudio-2.1.0+cu121-cp311-cp311-win_amd64.whl&quot;</span></span><br><span class="line">pip install <span class="string">&quot;torchvision-0.16.0+cu121-cp311-cp311-win_amd64.whl&quot;</span></span><br></pre></td></tr></table></figure>
<p>安装完torch后，安装xformers， 因为xformers和torch的版本对应没有文档，所以要一起安装来约束xformers：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==2.1.0 torchvision==0.16.0 torchaudio==2.1.0  xformers  --index-url https://download.pytorch.org/whl/cu121</span><br></pre></td></tr></table></figure>

<p>约束后，可以看到安装的xformers版本，所以可以用以下命令直接安装xformers。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xformers==0.0.22.post7 --index-url https://download.pytorch.org/whl/cu121</span><br></pre></td></tr></table></figure>

<p>继续安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install dependencies</span></span><br><span class="line">pip3 install openai</span><br><span class="line">pip3 install transformers==4.33.0 </span><br><span class="line">pip3 install accelerate==0.22.0 </span><br><span class="line">pip3 install einops==0.6.1 </span><br><span class="line">pip3 install langchain==0.0.300 </span><br><span class="line">pip3 install bitsandbytes-windows</span><br><span class="line">pip3 install sentence_transformers==2.2.2</span><br><span class="line">pip3 install arxiv</span><br><span class="line">pip3 install huggingface_hub</span><br><span class="line">pip3 install optimum</span><br><span class="line">pip3 install <span class="string">&quot;git+https://github.com/PanQiWei/AutoGPTQ.git@v0.7.1&quot;</span> </span><br></pre></td></tr></table></figure>

<p>为了准备从 PDF 文件中提取数据、执行 OCR 并创建嵌入，以进行高级数据处理和检索，我们还需要安装一些软件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pip3 install unstructured</span><br><span class="line">pip3 install <span class="string">&quot;unstructured[pdf]&quot;</span></span><br><span class="line">pip3 install poppler-utils</span><br><span class="line">pip3 install pytesseract</span><br><span class="line">pip3 install grpcio-tools==1.60.1</span><br><span class="line">pip3 install qdrant-client==1.7.2</span><br><span class="line">pip3 install WhisperSpeech</span><br><span class="line">pip3 install rich</span><br></pre></td></tr></table></figure>
<p>由于我的win10在线安装tesseract-ocr不成功，改成<a target="_blank" rel="noopener" href="https://github.com/simonflueckiger/tesserocr-windows_build/releases">wheel</a>安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tesserocr-2.7.0-cp311-cp311-win_amd64.whl</span><br></pre></td></tr></table></figure>

<p>设置系统环境变量，window如下图：<br><img src="/../asset_voicellama3/01.png"></p>
<p>注册Hugging Face，生成token. 登录 Hugging Face Hub, 预先下载模型，并保存到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loging to Huggingface Hub</span></span><br><span class="line">huggingface-cli login</span><br><span class="line">huggingface-cli download --resume-download astronomer/Llama-3-8B-Instruct-GPTQ-4-Bit</span><br></pre></td></tr></table></figure>

<h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><p>导入必要的库，包括模型交互、文档处理和嵌入管理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> HTTPError</span><br><span class="line"><span class="keyword">import</span> arxiv</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> cuda, bfloat16</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> transformers</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM, GPTQConfig</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> HuggingFacePipeline</span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> PyPDFLoader,DirectoryLoader,WebBaseLoader</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter,CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Qdrant</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> whisperspeech.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> rich.console <span class="keyword">import</span> Console</span><br><span class="line"><span class="keyword">from</span> rich.markdown <span class="keyword">import</span> Markdown</span><br></pre></td></tr></table></figure>

<h2 id="处理语音助手的数据"><a href="#处理语音助手的数据" class="headerlink" title="处理语音助手的数据"></a>处理语音助手的数据</h2><p>为 AI 应用构建数据管道, 数据管道对于高效管理和处理应用程序中的数据至关重要，特别是启用了带 RAG 的语音助手等复杂应用程序。</p>
<p>这些管道通常涉及五个关键阶段：</p>
<ul>
<li><p>收集： 在这个阶段，数据从各种来源收集，包括数据存储、数据流和应用程序。对于语音助手来说，这意味着从用户互动、音频输入以及内部和外部数据库收集数据。数据可以来自语音助手需要交互的远程设备、应用程序或业务系统。典型的工具有 Apache Nifi、Apache Flume、Talend 和自定义 API。</p>
</li>
<li><p>摄取：在摄取过程中，收集的数据被加载到系统中，并在事件队列中进行组织。对于语音助手，这涉及捕获音频输入，将其转录为文本，并将其排队等待进一步处理。摄取过程确保所有传入数据都准备好进行实时或批处理。典型工具包括 Apache Kafka、AWS Kinesis、Google Cloud Pub&#x2F;Sub、Apache Airflow。</p>
</li>
<li><p>存储：在摄取后，组织好的数据存储在各种存储解决方案中，如数据仓库、数据湖和数据湖屋。在语音助手的背景下，这包括存储转录、用户查询以及从 RAG 系统检索的文档。存储系统确保数据可供未来处理和分析。典型工具有 Amazon S3、Google Cloud Storage、Azure Data Lake、Snowflake、Apache Hudi、Delta Lake。</p>
</li>
<li><p>处理：在这个阶段，数据经历转换任务，如聚合、清洗和操作，以确保它符合所需的标准。对于语音助手，这意味着将文本数据转换为向量，压缩它，并将其分区以实现高效检索。为了确保数据始终是最新和准确的，使用批处理（一次处理大型数据集）和流处理（实时处理数据）技术。典型的工具有 Apache Spark、Apache Flink、Databricks、AWS Glue、Google Cloud Dataflow。</p>
</li>
<li><p>消费：最后阶段涉及将处理后的数据提供给用户使用。在语音助手的背景下，这意味着使系统能够准确理解和回应用户的查询。它还可以支持决策引擎和面向用户的应用程序，使语音助手能够对用户请求提供相关和及时的响应。典型工具有 Tableau、Power BI、Looker、Elasticsearch、Kibana、Apache Superset、自定义仪表板。</p>
</li>
</ul>
<p>让我们创建一个目录，搜索并下载“LLM”搜索词的Arxiv论文：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dirpath = <span class="string">&quot;arxiv_papers&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dirpath):</span><br><span class="line">   os.makedirs(dirpath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_papers</span>():</span><br><span class="line">    search = arxiv.Search(</span><br><span class="line">    query = <span class="string">&quot;LLM&quot;</span>, <span class="comment"># your query length is limited by ARXIV_MAX_QUERY_LENGTH which is 300 characters</span></span><br><span class="line">    max_results = <span class="number">10</span>,</span><br><span class="line">    sort_by = arxiv.SortCriterion.LastUpdatedDate, <span class="comment"># you can also use SubmittedDate or Relevance</span></span><br><span class="line">    sort_order = arxiv.SortOrder.Descending</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> search.results():</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result.download_pdf(dirpath=dirpath)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;-&gt; Paper id <span class="subst">&#123;result.get_short_id()&#125;</span> with title &#x27;<span class="subst">&#123;result.title&#125;</span>&#x27; is downloaded.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;File not found&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> HTTPError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Forbidden&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Connection reset by peer&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="RAG简要概述"><a href="#RAG简要概述" class="headerlink" title="RAG简要概述"></a>RAG简要概述</h2><p>RAG 工作流帮助我们管理和利用来自各种来源的数据，以提供准确和相关的结果。</p>
<p><img src="/../asset_voicellama3/02.png"></p>
<ul>
<li><p>数据加载：从不同来源收集数据，如文本文件、PDF、网站、数据库或 API。例如，Llama Hub 提供许多连接器，使这一步骤更容易。</p>
</li>
<li><p>索引：在索引阶段，系统将原始数据转换为向量嵌入，并对其进行组织。</p>
<ul>
<li><p>矢量化：每个文档或数据片段都被转换为一个高维向量，利用句子转换器等模型捕捉语义含义。</p>
</li>
<li><p>结构化：这些向量然后被组织成一个高效的数据结构，通常是一个 n 维树或哈希映射，从而实现快速的相似性搜索。</p>
</li>
</ul>
</li>
<li><p>存储：保存索引数据和标签，这样您以后就不必再次整理它。</p>
</li>
<li><p>查询: 在查询阶段，系统根据查询向量检索最相关的文档。</p>
<ul>
<li>向量匹配：将查询转换为向量，并使用余弦相似度或其他距离度量标准与索引向量进行比较。</li>
<li>检索：系统检索与查询向量最接近的文档，确保系统能够提供的响应在语境上和用户的请求相关。</li>
</ul>
</li>
<li><p>评估: 评估可能会因其随机性而变得相当具有挑战性。然而，可以用度量标准和工具进行客观评估。</p>
</li>
</ul>
<p>一些示例指标可能包括：忠实度、答案相关性、上下文精度、召回率、相关性和实体召回、答案语义相似度、答案正确性。</p>
<h2 id="文本分割器"><a href="#文本分割器" class="headerlink" title="文本分割器"></a>文本分割器</h2><p>使用 text_splitter 来管理大型文本文档，将它们分成更小、更易管理的块：</p>
<ul>
<li><p>RecursiveCharacterTextSplitter 递归地将文本分割成更小的片段，适用于非常大的文本。它有 2 个主要参数：</p>
<ul>
<li>chunk_size ：每个块的最大字符数（例如，1000 个字符）。</li>
<li>chunk_overlap ：保持上下文的重叠块大小（例如，100 个字符）。</li>
</ul>
<p>  这通常最适合于没有自然分割点的非常大的文本，并通过保持块之间的重叠来防止上下文丢失，确保后续处理具有连续性。</p>
</li>
<li><p>CharacterTextSplitter 根据指定的字符分隔符拆分文本，非常适合具有自然分隔的文本。它有 3 个主要参数</p>
<ul>
<li>separator ：用于分隔的字符（例如， \n 用于换行）。</li>
<li>chunk_size 和 chunk_overlap ：类似于递归分割器，定义块的大小和重叠。</li>
</ul>
<p>  适用于具有明确分界点的文本，如脚本或具有明确定义部分的文档，通过在自然断点处分割文本来确保数据完整性，有助于保持意义和上下文，而无需重叠。</p>
</li>
</ul>
<h2 id="文档加载器"><a href="#文档加载器" class="headerlink" title="文档加载器"></a>文档加载器</h2><p>文档加载器在处理自然语言处理工作流中的不同数据源时至关重要。有以下几种：</p>
<ul>
<li>DirectoryLoader: 从指定目录加载所有文件，通常用于处理多个文本或 PDF 文件。</li>
<li>WebBaseLoader：从指定的 URL 检索文本，从中提取网络内容以进行处理。</li>
<li>PyPDFLoader：专注于从单个 PDF 文件中提取文本以进行进一步分析。</li>
<li>TextLoader：专门设计用于加载纯文本文件，直接读取文本数据以供立即使用。</li>
</ul>
<p>所有的加载器都用于收集数据，然后对数据进行处理，可能用于生成嵌入。</p>
<p>我们将使用 DirectoryLoader 和 RecursiveCharacterTextSplitter 来高效地分块和管理多个文件。</p>
<p>分割器和文档加载器的结合使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">document_loader_spilter</span>():</span><br><span class="line">    papers = []</span><br><span class="line">    loader = DirectoryLoader(dirpath, glob=<span class="string">&quot;./*.pdf&quot;</span>, loader_cls=PyPDFLoader)</span><br><span class="line">    papers = loader.load()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Total number of pages loaded:&quot;</span>, <span class="built_in">len</span>(papers)) <span class="comment"># Total number of pages loaded: 410</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This merges all papes from all papers into single text block for chunking</span></span><br><span class="line">    full_text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> paper <span class="keyword">in</span> papers:</span><br><span class="line">        full_text = full_text + paper.page_content</span><br><span class="line">        </span><br><span class="line">    full_text = <span class="string">&quot; &quot;</span>.join(l <span class="keyword">for</span> l <span class="keyword">in</span> full_text.splitlines() <span class="keyword">if</span> l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(full_text))</span><br><span class="line"></span><br><span class="line">    text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">        chunk_size = <span class="number">500</span>,</span><br><span class="line">        chunk_overlap  = <span class="number">50</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    paper_chunks = text_splitter.create_documents([full_text])</span><br><span class="line">    <span class="keyword">return</span> paper_chunks</span><br></pre></td></tr></table></figure>

<h2 id="模型配置"><a href="#模型配置" class="headerlink" title="模型配置"></a>模型配置</h2><p>配置了一个用于语言生成任务的 Meta LLaMA 3 模型,由于我的显卡只有8GB显存，所以只能使用 4-bit 模型。</p>
<p>配置：</p>
<ul>
<li>model_id ：标识具有 80 亿参数的特定 Meta LLaMA 模型，用于高级语言任务。</li>
<li>device ：将模型设置为在 GPU（ “cuda” ）上运行，提高处理速度和效率。</li>
<li>dtype ：使用 torch.float16 来优化内存和计算速度。</li>
</ul>
<p>初始化:</p>
<ul>
<li>tokenizer ：从 Hugging Face 加载一个分词器，将文本预处理为模型可以理解的标记。</li>
<li>model ：使用 AutoModelForCausalLM.from_pretrained 配置初始化模型，用于因果语言建模，模型根据先前文本预测下一个单词。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_llm_model</span>():</span><br><span class="line">    model_id = <span class="string">&quot;astronomer/Llama-3-8B-Instruct-GPTQ-4-Bit&quot;</span></span><br><span class="line">    device = <span class="string">&quot;cuda&quot;</span></span><br><span class="line">    dtype = torch.float16</span><br><span class="line">    </span><br><span class="line">    tokenizer = AutoTokenizer.from_pretrained(model_id)</span><br><span class="line">    model = AutoModelForCausalLM.from_pretrained(model_id, device_map=device, torch_dtype=dtype)</span><br><span class="line">    <span class="keyword">return</span> model, tokenizer</span><br></pre></td></tr></table></figure>

<h2 id="设置查询管道并初始化管道"><a href="#设置查询管道并初始化管道" class="headerlink" title="设置查询管道并初始化管道"></a>设置查询管道并初始化管道</h2><p>现在我们使用 Hugging Face的 transformers 库设置一个 query_pipeline ，旨在简化预训练模型和分词器的使用：</p>
<ul>
<li>model ：指定预训练语言模型。</li>
<li>tokenizer ：将输入文本转换为标记。</li>
<li>torch_dtype ：使用 torch.float16 进行高效计算。</li>
<li>max_length ：将输出限制在 1024 个标记。</li>
<li>device_map ：自动优化模型层的分配到可用硬件。</li>
</ul>
<p>然后使用我们配置的 query_pipeline 初始化一个 HuggingFacePipeline 对象，以便简化文本生成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_query_pipeline</span>(<span class="params">model, tokenizer</span>):</span><br><span class="line">    query_pipeline = transformers.pipeline(</span><br><span class="line">            <span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">            model=model,</span><br><span class="line">            tokenizer=tokenizer,</span><br><span class="line">            torch_dtype=torch.float16,</span><br><span class="line">            max_length=<span class="number">1024</span>,</span><br><span class="line">            device_map=<span class="string">&quot;auto&quot;</span>,)</span><br><span class="line"></span><br><span class="line">    llm = HuggingFacePipeline(pipeline=query_pipeline)</span><br><span class="line">    <span class="keyword">return</span> llm</span><br></pre></td></tr></table></figure>


<h2 id="处理模型加载并回退到本地资源"><a href="#处理模型加载并回退到本地资源" class="headerlink" title="处理模型加载并回退到本地资源"></a>处理模型加载并回退到本地资源</h2><p>我们现在将从 Hugging Face 的存储库中加载 sentence-transformers&#x2F;all-mpnet-base-v2 嵌入模型，配置为在 CUDA 设备上运行。</p>
<p>如果此过程遇到任何问题，比如连接问题或访问限制，您也可以添加异常以返回使用本地存储的嵌入模型。</p>
<p>通过这种方法，我们的应用程序可以在主要来源不可用时继续使用备用模型进行处理，这有助于我们在不同的运行环境中保持稳健性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_embeddings_model</span>():</span><br><span class="line">    model_name = <span class="string">&quot;sentence-transformers/all-mpnet-base-v2&quot;</span></span><br><span class="line">    model_kwargs = &#123;<span class="string">&quot;device&quot;</span>: <span class="string">&quot;cuda&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># try to access the sentence transformers from HuggingFace: https://huggingface.co/api/models/sentence-transformers/all-mpnet-base-v2</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        embeddings = HuggingFaceEmbeddings(model_name=model_name, model_kwargs=model_kwargs)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exception: &quot;</span>, ex)</span><br><span class="line">        <span class="comment"># # alternatively, we will access the embeddings models locally</span></span><br><span class="line">        <span class="comment"># local_model_path = &quot;/kaggle/input/sentence-transformers/minilm-l6-v2/all-MiniLM-L6-v2&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;Use alternative (local) model: &#123;local_model_path&#125;\n&quot;)</span></span><br><span class="line">        <span class="comment"># embeddings = HuggingFaceEmbeddings(model_name=local_model_path, model_kwargs=model_kwargs)</span></span><br><span class="line">    <span class="keyword">return</span> embeddings</span><br></pre></td></tr></table></figure>

<h2 id="集成-Qdrant-用于嵌入式存储和检索"><a href="#集成-Qdrant-用于嵌入式存储和检索" class="headerlink" title="集成 Qdrant 用于嵌入式存储和检索"></a>集成 Qdrant 用于嵌入式存储和检索</h2><p>我们将使用 Qdrant 作为我们的向量数据库，因为它在处理向量相似性搜索、可扩展性和灵活的向量数据管理方面具有出色的能力。</p>
<p>此外，Qdrant 支持本地和云存储选项，以便您可以适应各种本地和云环境。</p>
<p>我们已经安装了 Qdrant，并且正在从 LangChain 的向量存储中导入它</p>
<p>Qdrant.from_documents 方法通过将文档及其对应的嵌入作为输入来简化流程。</p>
<p>然后将 vectordb 对象转换为一个具有 vectordb.as_retriever() 的检索器。该检索器被配置为根据向量相似性查询向量数据库，以便检索相关文档，这对于有效的信息检索至关重要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_retriever</span>():</span><br><span class="line">    documents=document_loader_spilter()</span><br><span class="line">    embeddings=load_embeddings_model()</span><br><span class="line"></span><br><span class="line">    vectordb = Qdrant.from_documents(</span><br><span class="line">        documents,</span><br><span class="line">        embeddings,</span><br><span class="line">        path=<span class="string">&quot;Qdrant_Persist&quot;</span>,</span><br><span class="line">        collection_name=<span class="string">&quot;voice_assistant_documents&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    retriever = vectordb.as_retriever()</span><br><span class="line">    <span class="keyword">return</span> retriever</span><br></pre></td></tr></table></figure>

<p>使用的参数的详细说明：</p>
<ul>
<li>documents ：生成嵌入的原始文档。</li>
<li>embeddings ：从文档中提取的嵌入已准备好被索引和存储。</li>
<li>path ：指定的本地目录，Qdrant 数据库将在其中持久保存数据，确保嵌入数据安全存储并易于将来检索。</li>
<li>collection_name ：Qdrant 中数据集的标签，有助于组织和检索特定组的嵌入。</li>
</ul>
<p>如果想要在 Qdrant 向量数据库中重用持久化数据, 创建一个 QdrantClient 实例，指向存储我们数据库文件的路径，从而实现对持久化数据的访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qdrant_client <span class="keyword">import</span> QdrantClient</span><br><span class="line"></span><br><span class="line">client = QdrantClient(path = <span class="string">&quot;Qdrant_Persist&quot;</span>)</span><br><span class="line"></span><br><span class="line">vectordb = Qdrant(</span><br><span class="line">    client=client,</span><br><span class="line">    collection_name=<span class="string">&quot;voice_assistant_documents&quot;</span>,</span><br><span class="line">    embeddings=embeddings,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="设置检索器"><a href="#设置检索器" class="headerlink" title="设置检索器"></a>设置检索器</h2><p>用我们 Qdrant 向量数据库中存储的嵌入来建立一个检索式问答（QA）系统</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model, tokenizer=load_llm_model()</span><br><span class="line">llm=load_query_pipeline(model, tokenizer)</span><br><span class="line">retriever=create_retriever()</span><br><span class="line">qa = RetrievalQA.from_chain_type(</span><br><span class="line">    llm=llm,</span><br><span class="line">    chain_type=<span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    retriever=retriever,</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后我们初始化一个 RetrievalQA 实例，它是我们 AI 链中的一部分。该实例使用检索器来获取与查询相关的信息。这里， llm 代表我们的语言模型， chain_type 设置为”stuff”，表示此链将处理的任务或操作类型， verbose&#x3D;True 在操作期间启用详细输出，提供有关检索过程的见解。</p>
<h2 id="测试和可视化-RAG-系统"><a href="#测试和可视化-RAG-系统" class="headerlink" title="测试和可视化 RAG 系统"></a>测试和可视化 RAG 系统</h2><p>我们实现了用于测试和可视化检索增强生成（RAG）系统的功能：</p>
<ul>
<li>colorize_text 功能: 为“Reasoning”、“Question”、“Answer”和“Total time”等关键术语添加颜色，以获得清晰且视觉上吸引人的输出。</li>
<li>test_rag 功能: 接受 QA 系统 ( qa ) 和查询字符串。它测量响应时间，检索答案，并在 Markdown 中显示格式化结果，突出关键元素以便阅读。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">colorize_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">for</span> word, color <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;Reasoning&quot;</span>, <span class="string">&quot;Question&quot;</span>, <span class="string">&quot;Answer&quot;</span>, <span class="string">&quot;Total time&quot;</span>], [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;magenta&quot;</span>]):</span><br><span class="line">        text = text.replace(<span class="string">f&quot;<span class="subst">&#123;word&#125;</span>:&quot;</span>, <span class="string">f&quot;\n\n**&lt;font color=&#x27;<span class="subst">&#123;color&#125;</span>&#x27;&gt;<span class="subst">&#123;word&#125;</span>:&lt;/font&gt;**&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_rag</span>(<span class="params">qa, query</span>):</span><br><span class="line">    console = Console()</span><br><span class="line"></span><br><span class="line">    time_start = time()</span><br><span class="line">    response = qa.run(query)</span><br><span class="line">    time_end = time()</span><br><span class="line">    total_time = <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">round</span>(time_end-time_start, <span class="number">3</span>)&#125;</span> sec.&quot;</span></span><br><span class="line"></span><br><span class="line">    full_response =  <span class="string">f&quot;Question: <span class="subst">&#123;query&#125;</span>\nAnswer: <span class="subst">&#123;response&#125;</span>\nTotal time: <span class="subst">&#123;total_time&#125;</span>&quot;</span></span><br><span class="line">    colored_text = colorize_text(full_response)</span><br><span class="line">    console.<span class="built_in">print</span>(Markdown(colored_text))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<h2 id="Llama-3-和-Whisper-的文本转语音处理"><a href="#Llama-3-和-Whisper-的文本转语音处理" class="headerlink" title="Llama 3 和 Whisper 的文本转语音处理"></a>Llama 3 和 Whisper 的文本转语音处理</h2><p><img src="/../asset_voicellama3/03.png"></p>
<ul>
<li>知识库到向量数据库：最初，知识库中的文档通过嵌入模型进行处理。该模型将文本数据转换为数字向量，然后存储在像 Qdrant 这样的向量数据库中。这种设置通过将文档的语义含义表示为高维空间中的点，实现了高效的检索。</li>
<li>用户查询处理：当用户提交查询时，它首先与嵌入模型交互，将查询转换为其向量表示。</li>
<li>检索：然后使用查询向量从向量数据库中获取与之最相似的前 K 个向量（上下文）。这个过程被称为“检索”，有助于识别与用户查询相关的知识库中最相关的文档或数据片段。</li>
<li>阅读和响应生成：然后将检索到的上下文输入到 Meta Llama 3 LLM中，该系统会阅读和理解这些上下文中与用户查询相关的信息。然后生成一个响应，旨在提供最准确和相关的信息。然后 Whisper 将文本转换为音频响应。</li>
</ul>
<p>首先定义“Whisper”管道。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe = Pipeline(s2a_ref=<span class="string">&#x27;WhisperSpeech/WhisperSpeech:s2a-q4-tiny-en+pl.model&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>为windows系统，我们定义一个函数，用于将音频张量转换为音频文件。</p>
<p>然后通过我们的查询来使用 Llama 3 进行文本生成，接着我们可以使用 Whisper 进行音频生成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_audio_for_windows</span>(<span class="params">audio_tensor,wav_file_path</span>):</span><br><span class="line">    <span class="keyword">from</span> pydub <span class="keyword">import</span> AudioSegment</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">    <span class="comment"># generate uses CUDA if available; therefore, it&#x27;s necessary to move to CPU before converting to NumPy array</span></span><br><span class="line">    audio_np = (audio_tensor.cpu().numpy() * <span class="number">32767</span>).astype(np.int16)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(audio_np.shape) == <span class="number">1</span>:</span><br><span class="line">        audio_np = np.expand_dims(audio_np, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        audio_np = audio_np.T</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Array shape:&quot;</span>, audio_np.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Array dtype:&quot;</span>, audio_np.dtype)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        audio_segment = AudioSegment(</span><br><span class="line">            audio_np.tobytes(), </span><br><span class="line">            frame_rate=<span class="number">24000</span>, </span><br><span class="line">            sample_width=<span class="number">2</span>, </span><br><span class="line">            channels=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        audio_segment.export(wav_file_path, <span class="built_in">format</span>=<span class="string">&#x27;wav&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Audio file generated: <span class="subst">&#123;wav_file_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error writing audio file: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="string">&quot;How LLMs can be used to understand and interact with the complex 3D world&quot;</span></span><br><span class="line">aud = test_rag(qa, query)</span><br><span class="line"></span><br><span class="line">audio_tensor = pipe.generate(<span class="string">f&quot;<span class="subst">&#123;aud&#125;</span>&quot;</span>)</span><br><span class="line">generate_audio_for_windows(audio_tensor, <span class="string">f&quot;output.wav&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查询处理：我们从查询“如何LLMs用于理解和与复杂的 3D 世界互动”开始，通过使用模型（ qa ）的检索增强生成（RAG）系统进行处理。该系统的响应已准备用于语音合成。</li>
<li>语音合成：使用 whisper 模型与语音，我们将文本响应转换为音频并保存为 output.wav 。</li>
<li>语音转文本：可以使用 whisper 模型将音频文件转录回文本，以验证语音合成的准确性。</li>
</ul>
<p><img src="/../asset_voicellama3/04.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@datadrifters/llama-3-powered-voice-assistant-integrating-local-rag-withdrant-whisper-and-langchain-b4d075b00ac5">https://medium.com/@datadrifters/llama-3-powered-voice-assistant-integrating-local-rag-withdrant-whisper-and-langchain-b4d075b00ac5</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/05/19/rpa-agent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/19/rpa-agent/" class="post-title-link" itemprop="url">从 RPA 到企业 AI 代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-19 16:18:05" itemprop="dateCreated datePublished" datetime="2024-05-19T16:18:05+08:00">2024-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-20 10:37:30" itemprop="dateModified" datetime="2024-05-20T10:37:30+08:00">2024-05-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RPA(机器人流程自动化) 又称软件机器人，它使用自动化技术模拟人类的后台任务，如提取数据、填写表单和移动文件等等。 它结合了 API 和用户界面 (UI) 互动，整合并执行企业与生产力应用之间的重复性任务。 通过部署用于模拟人工流程的脚本，RPA 工具可以在各个不相关的软件系统中自动执行各项活动和事务。</p>
<p>AI 代理是一种由LLMs实现的新软件范式。代理可以推理、协作和行动，类似于人类的工作方式。代理不仅仅是自动化的一种逐步改进方式，而且是一种完全新的突破性技术，需要掌握新的技能和工具。它们将范围从战术任务级自动化扩展到自动化和增强复杂的知识工作。</p>
<h2 id="RPA-和人工智能"><a href="#RPA-和人工智能" class="headerlink" title="RPA 和人工智能"></a>RPA 和人工智能</h2><p>机器人流程自动化经常被误认为是人工智能 (AI)，但两者截然不同。 AI 结合了认知自动化、机器学习 (ML)、自然语言处理 (NLP) 、推理、假设生成和分析。</p>
<p>关键区别在于 RPA 是流程驱动的，AI 则是数据驱动的。 RPA 机器人只遵循最终用户定义的流程，而 AI 机器人则使用机器学习来识别数据中的模式，特别是非结构化数据，并持续进行学习。 换句话说，AI 旨在模拟人类智能，而 RPA 则仅用于复制人类指导的任务。 虽然人工智能和 RPA 工具的使用能够最大程度地减少人工干预，但它们实现流程自动化的方式是不同的。 </p>
<p>也就是说，RPA 和 AI 彼此还起到很好的互补作用。 AI 可以帮助 RPA 更全面地自动完成任务，并处理更复杂的用例。 RPA 则有助于更迅速地对 AI 洞察采取行动，而不是等待人工实施。</p>
<p>当企业需要加速将AI融入到一线活动和决策中时，许多企业发现RPA可以作为AI的“最后一英里”交付系统。配置的机器人可以将机器学习模型应用到自动化决策流程和分析中，将机器智能深入到日常操作。</p>
<p>企业自动化的演变:</p>
<ul>
<li>自动化任务 — RPA</li>
<li>自动化流程 — 自动化即代码</li>
<li>自动化工作 — 智能人工智能代理</li>
</ul>
<h2 id="超越-RPA-和智能自动化"><a href="#超越-RPA-和智能自动化" class="headerlink" title="超越 RPA 和智能自动化"></a>超越 RPA 和智能自动化</h2><p>企业自动化正在经历一场演变。它始于机器人流程自动化（RPA）, RPA 的崛起得益于录制和播放方式的 UI 自动化，它打造了围绕低代码业务的应用的繁荣。</p>
<p>如今，每家大公司都建立了围绕自动化的中心，并扩展到通常被称为智能自动化（IA）的领域。</p>
<p>IA 并不是一个明确定义的术语，通常是从 RPA 到 API 自动化以及通过 OCR 进行文档处理的技术混合体。它标志着超越点对点自动化，转向使用工具进行流程自动化，这些工具通常将编码与低代码混合，并需要专业技能来部署。然而，基本原则仍然相同 — RPA 和 IA 纯粹基于规则，并适用于明确定义、高度结构化的流程。</p>
<p>AI 代理，使用完全不同的代理规划和执行工作流程。他们可以通过灵活的推理能力来实现理解本地非结构化数据和非结构化流程。这使得代理不仅适用于无法用简单规则捕捉的工作，而且适用于用自然语言描述的手册和工作指南。这也使代理比预先编程的机器人更具弹性 — 代理可以在遇到错误时自行纠正或与人类联系以获得反馈。</p>
<p><img src="/../asset_rpaagent/01.png"></p>
<h2 id="从战术自动化到战略人工智能代理"><a href="#从战术自动化到战略人工智能代理" class="headerlink" title="从战术自动化到战略人工智能代理"></a>从战术自动化到战略人工智能代理</h2><p>尽管人工智能代理采取了一种与企业自动化非常不同的方法，但它们并不标志着 RPA 的终结。如果您的任务需要每天向生产 ERP 系统输入一千条记录，或将十万份电子健康记录迁移到新系统，那么试图使用代理来解决重复的例行任务是没有意义的。</p>
<p>AI 代理扩展了企业自动化的范围，超出了以前可能的范围。由于 AI 代理是一个仍在形成中的新类别，想象代理使用案例的最简单方法是通过代理推理扩展现有的自动化例程。随着时间的推移，AI 代理将扩展到企业核心业务工作流程，这些工作流程是企业的核心。</p>
<p><img src="/../asset_rpaagent/02.png"><br>AI 代理和企业自动化用例的层次结构</p>
<p>上面的插图显示了三种不同类别的自动化使用案例。在底部，有大量不需要复杂决策但在自定义环境下运行的战术性工作。也就是说，这项工作是在与企业高度相关的数据、文件和系统上运行的。</p>
<p>这是 RPA 运作的地方，也是开始实践第一个 AI 代理项目的好地方。寻找在 RPA 例行程序之前和之后出现的工作流中的机会，并通过代理扩大自动化范围。使用 AI 代理来扩大自动化的范围，超越标准 RPA 所能实现的范围。</p>
<p>往上一层，我们有涉及标准决策的工作，这些决策是在标准背景下进行的。这通常是由 ServiceNow 或 Salesforce 等平台和记录系统来做的工作。在这里，您最好通过从这些供应商购买人工智能和自动化解决方案，并依赖于他们创新数据和流程的能力来服务企业。现在每个应用程序都有一个协助机器人，它帮助企业自动化其业务流程。</p>
<p>最后，在金字塔的顶端，我们有最战略性的工作类别，这是企业业务和运营的核心。这项工作涉及复杂的决策，并且在特定的背景下运作。没有人能够从外部进来教你如何更好地做这项工作，因为这就是公司存在的原因。这就是专为企业定制的人工智能代理将产生最大影响的地方。</p>
<p>代理可以与人类一起工作，或完全取代一些人类任务，并使人们专注于更有生产力的工作。由于智能 AI 代理仍处于早期阶段，所以要达到这项最有价值和战略性的工作需要时间，但现在是开始建立所需技能和平台的时候了。</p>
<h2 id="案例：-ERP-低代码平台-RPA-AI"><a href="#案例：-ERP-低代码平台-RPA-AI" class="headerlink" title="案例： ERP+低代码平台+RPA+AI"></a>案例： ERP+低代码平台+RPA+AI</h2><p><img src="/../asset_rpaagent/03.png"></p>
<p>在此架构中，ERP系统可以继续保持不变，低代码平台则通过无代码或低代码快速开发，快速部署上线的特性，以小步快跑，快速迭代的方式，实现企业创新与管理改善。</p>
<p>每个企业的采购申请可能存在比较大的差异，因此很多ERP系统的标准功能都无法满足企业的个性需求,比如定制审批流程.</p>
<h3 id="识别需要与ERP系统交互的数据"><a href="#识别需要与ERP系统交互的数据" class="headerlink" title="识别需要与ERP系统交互的数据:"></a>识别需要与ERP系统交互的数据:</h3><ul>
<li>一是物料数据从ERP同步到低代码平台，以便在低代码平台发起申请时用户可以选择采购物料。</li>
<li>二是将低代码平台审批通过的采购申请返回ERP系统形成PO（采购订单）</li>
</ul>
<h3 id="正常方式"><a href="#正常方式" class="headerlink" title="正常方式:"></a>正常方式:</h3><p>通过低代码平台的JDBC Binder做数据库层面的集成或者通过ERP系统的Web Service接口完成上述的数据交互</p>
<h3 id="另类方式"><a href="#另类方式" class="headerlink" title="另类方式:"></a>另类方式:</h3><p>用RPA完成低代码平台与ERP系统的数据交互. </p>
<ul>
<li>让RPA定时在ERP系统中查询新增的物料和更新的物料，然后将这些值更新到低代码平台中。</li>
<li>低代码平台中采购审批通过的数据，通过低代码平台流程工具触发RPA机器人，在SAP系统中创建新的PO（采购订单）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szhowardhuang.github.io/2024/05/13/gymnasium-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Howard Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 嵌入式老兵博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/13/gymnasium-introduce/" class="post-title-link" itemprop="url">Gymnasium 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-05-13 15:12:51 / 修改时间：15:48:36" itemprop="dateCreated datePublished" datetime="2024-05-13T15:12:51+08:00">2024-05-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前面介绍了强化学习的例子，觉得有必要介绍gymnasium环境。 作为强化学习最常用的工具，gym一直在不停地升级和折腾，比较大的变化就是2021年接口从gym库变成了gymnasium库。</p>
<h3 id="step和观察结果"><a href="#step和观察结果" class="headerlink" title="step和观察结果"></a>step和观察结果</h3><p>总体来说，对于gymnasium我们只需要做两件事情：一个是初始化环境，另一个就是通过step函数不停地给环境做输入，然后观察对应的结果。</p>
<p>初始化环境分为两步。<br>第一步是创建gymnasium中所支持的环境，比如我们使用经典的让一个杆子不倒的CartPole环境：</p>
<pre><code>import gymnasium as gym
env = gym.make(&quot;CartPole-v1&quot;)
</code></pre>
<p>第二步，我们就可以通过env的reset函数来进行环境的初始化：</p>
<pre><code>observation, info = env.reset()
</code></pre>
<p>我们可以将observation打印出来，它一个4元组，4个数值分别表示：</p>
<ul>
<li>小车位置</li>
<li>小车速度</li>
<li>棍的倾斜角度</li>
<li>棍的角速度</li>
</ul>
<p>如果角度大于12度，或者小车位置超出了2.4，就意味着失败了，直接结束。</p>
<p>小车的输入就是一个力，要么是向左的力，要么是向右的力。0是向左推小车，1是向右推小车。</p>
<p>下面我们让代码跑起来。</p>
<p>首先我们通过pip来安装gymnasium的包：</p>
<pre><code>pip install gymnasium
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"></span><br><span class="line">num_eval_episodes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;CartPole-v1&quot;</span>, render_mode=<span class="string">&quot;rgb_array&quot;</span>)  <span class="comment"># replace with your environment</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(env.action_space)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> episode_num <span class="keyword">in</span> <span class="built_in">range</span>(num_eval_episodes):</span><br><span class="line">    obs, info = env.reset()</span><br><span class="line"></span><br><span class="line">    episode_over = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> episode_over:</span><br><span class="line">        action = env.action_space.sample()  <span class="comment"># replace with actual agent</span></span><br><span class="line">        obs, reward, terminated, truncated, info = env.step(action)</span><br><span class="line"></span><br><span class="line">        episode_over = terminated <span class="keyword">or</span> truncated</span><br><span class="line">env.close()</span><br></pre></td></tr></table></figure>

<p>env.action_space输出是Discrete(2)。也就是两个离散的值0和1。前面我们介绍了，这分别代表向左和向右推动小车。</p>
<p>obs输出的4元组，我们前面也讲过了，像这样：<br>[ 0.0273956 -0.00611216 0.03585979 0.0197368 ]</p>
<p>下面就是关键的step一步：</p>
<pre><code>action = env.action_space.sample()  # replace with actual agent
obs, reward, terminated, truncated, info = env.step(action)
</code></pre>
<p>CartPole的输入只有0和1两个值。我们采用sample()函数只是随机采用左右动的方式来试图让小车不倒。</p>
<p>返回的5元组，obs就是位置4元组，reward是用于强化学习的奖励，在本例中只要是不死就是1. terminated就是是否游戏结束了。<br>Truncated在官方定义中用于处理比如超时等特殊结束的情况。<br>truncated, info对于CartPole来说没有用到。</p>
<p>搭建好了gymnasium环境之后，我们就可以进行策略的升级与迭代了。<br>比如我们写死一个策略，如果位置小于0则向右推，反之则向左推：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">action_pos</span>(<span class="params">obs</span>): </span><br><span class="line">    pos, v, ang, va = obs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pos &lt;= <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>用 action_pos(obs) 替换 env.action_space.sample() 即可。</p>
<h3 id="与老gym的主要区别"><a href="#与老gym的主要区别" class="headerlink" title="与老gym的主要区别"></a>与老gym的主要区别</h3><p>目前版本与之前gym的最主要区别在于step返回值从原来的4元组变成了5元组。<br>原来是observation, reward, done, info，而现在done变成了 terminated增加了truncated。</p>
<p>老版本的：</p>
<pre><code>status, reward, done, info = env.step(0)
</code></pre>
<p>新版的：</p>
<pre><code>observation, reward, terminated, truncated, info = env.step(0)
</code></pre>
<p>因而，原来处理done的地方需要改成terminated或truncated:</p>
<pre><code>if terminated or truncated:
    something()
</code></pre>
<p>另外，env.reset函数目前返回的是两个值，而不是原来的一个值：</p>
<pre><code>obs,info = env.reset()
</code></pre>
<h3 id="gymnasium与强化学习算法库的结合"><a href="#gymnasium与强化学习算法库的结合" class="headerlink" title="gymnasium与强化学习算法库的结合"></a>gymnasium与强化学习算法库的结合</h3><p>stable-baselines3等强化学习库已经对gymnasium进行了支持，所以我们可以在stable-baselines3中直接使用gymnasium的环境。</p>
<p>先安装库：</p>
<pre><code>pip install gymnasium[atari]
pip install gymnasium[accept-rom-license]
pip install stable_baselines3
</code></pre>
<p>我们用DQN算法来训练乒乓球游戏：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stable_baselines3 <span class="keyword">import</span> DQN</span><br><span class="line"><span class="keyword">from</span> stable_baselines3.dqn <span class="keyword">import</span> CnnPolicy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">game = <span class="string">&#x27;ALE/Pong-v5&#x27;</span></span><br><span class="line"></span><br><span class="line">env = gym.make(game,render_mode=<span class="string">&quot;rgb_array&quot;</span>)</span><br><span class="line"></span><br><span class="line">save_file = <span class="string">&#x27;dqn_&#x27;</span>+game;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(env.action_space)</span><br><span class="line">model = DQN(CnnPolicy, env, verbose=<span class="number">1</span>,exploration_final_eps=<span class="number">0.01</span>,exploration_fraction=<span class="number">0.1</span>,gradient_steps=<span class="number">1</span>,learning_rate=<span class="number">0.0001</span>,buffer_size=<span class="number">10000</span>)</span><br><span class="line">model.set_env(env)</span><br><span class="line">model.learn(total_timesteps=<span class="number">1000000</span>, log_interval=<span class="number">10</span>)</span><br><span class="line">model.save(save_file)</span><br><span class="line"></span><br><span class="line">obs,info = env.reset()</span><br><span class="line"></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line">rewards_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    action, _states = model.predict(obs, deterministic=<span class="literal">True</span>)</span><br><span class="line">    obs, reward, terminated, truncated, info = env.step(action)</span><br><span class="line">    score = score + <span class="number">1</span></span><br><span class="line">    rewards_sum += reward</span><br><span class="line">    <span class="keyword">if</span> reward &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;win!!!&#x27;</span>, reward)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> terminated <span class="keyword">or</span> truncated:</span><br><span class="line">        <span class="comment"># obs = env.reset()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finished&#x27;</span>, score)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;reward sum=&#x27;</span>, rewards_sum)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>上面的代码我们还可以做两处改进：</p>
<p>如果存在save_file，我们可以直接加载模型，在原有模型上继续训练。<br>我们可以增加一个测试模式，观看训练后模型打游戏的真实效果。</p>
<p>我们让PPO算法来玩乒乓球游戏了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stable_baselines3 <span class="keyword">import</span> PPO</span><br><span class="line"><span class="keyword">from</span> stable_baselines3.dqn <span class="keyword">import</span> MlpPolicy</span><br><span class="line"><span class="keyword">from</span> stable_baselines3.dqn <span class="keyword">import</span> CnnPolicy</span><br><span class="line"></span><br><span class="line">game = <span class="string">&#x27;ALE/Pong-v5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eval = True</span></span><br><span class="line"><span class="built_in">eval</span> = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">cont = <span class="literal">True</span></span><br><span class="line"><span class="comment">#cont = False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()))</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">start_date = datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">eval</span>:</span><br><span class="line">    env = gym.make(game,render_mode=<span class="string">&quot;human&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    env = gym.make(game,render_mode=<span class="string">&quot;rgb_array&quot;</span>)</span><br><span class="line"></span><br><span class="line">save_file = <span class="string">&#x27;./dqn_&#x27;</span>+game;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(env.action_space)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">eval</span>:</span><br><span class="line">    model = PPO.load(save_file)</span><br><span class="line">    model.set_env(env) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> cont:</span><br><span class="line">        model = PPO.load(save_file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model = PPO(<span class="string">&quot;MlpPolicy&quot;</span>, env, verbose=<span class="number">1</span>,learning_rate=<span class="number">2.5e-4</span>,clip_range=<span class="number">0.1</span>,vf_coef=<span class="number">0.5</span>,ent_coef=<span class="number">0.01</span>,n_steps=<span class="number">128</span>)    </span><br><span class="line">    model.set_env(env)</span><br><span class="line">    model.learn(total_timesteps=<span class="number">1000000</span>, log_interval=<span class="number">10</span>)</span><br><span class="line">    model.save(save_file)</span><br><span class="line"></span><br><span class="line">obs,info = env.reset()</span><br><span class="line"></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line">rewards_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    action, _states = model.predict(obs)</span><br><span class="line">    obs, reward, terminated, truncated, info = env.step(action)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">eval</span>:</span><br><span class="line">        env.render()</span><br><span class="line"></span><br><span class="line">    score = score + <span class="number">1</span></span><br><span class="line">    rewards_sum += reward</span><br><span class="line">    <span class="keyword">if</span> reward &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;win!!!&#x27;</span>, reward)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> terminated <span class="keyword">or</span> truncated:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finished&#x27;</span>, score)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;reward sum=&#x27;</span>, rewards_sum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">duration = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;duration=&#x27;</span>, duration)</span><br><span class="line"></span><br><span class="line">time_cost = datetime.now() - start_date</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;time cost=&#x27;</span>, time_cost)</span><br></pre></td></tr></table></figure>
<h3 id="视频输出-从Monitor到RecordVideo"><a href="#视频输出-从Monitor到RecordVideo" class="headerlink" title="视频输出 - 从Monitor到RecordVideo"></a>视频输出 - 从Monitor到RecordVideo</h3><p>有时候我们希望把游戏的视频输出出来，gym曾经使用Monitor来实现。现在gymnasium则改用RecordVideo来实现。</p>
<p>使用RecordVideo需要先安装moviepy库：</p>
<pre><code>pip install moviepy
</code></pre>
<p>然后从gymnasium.wrappers包中引用RecordVideo：</p>
<pre><code>from gymnasium.wrappers import RecordVideo
</code></pre>
<p>human模式是没有办法输出视频的，所以我们需要把human模式改成rgb_array模式。</p>
<pre><code>env = gym.make(&quot;CartPole-v1&quot;, render_mode=&quot;rgb_array&quot;)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"><span class="keyword">from</span> gymnasium.wrappers <span class="keyword">import</span> RecordEpisodeStatistics, RecordVideo</span><br><span class="line"></span><br><span class="line">training_period = <span class="number">250</span>  <span class="comment"># record the agent&#x27;s episode every 250</span></span><br><span class="line">num_training_episodes = <span class="number">10_000</span>  <span class="comment"># total number of training episodes</span></span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;CartPole-v1&quot;</span>, render_mode=<span class="string">&quot;rgb_array&quot;</span>)  <span class="comment"># replace with your environment</span></span><br><span class="line">env = RecordVideo(env, video_folder=<span class="string">&quot;cartpole-agent&quot;</span>, name_prefix=<span class="string">&quot;training&quot;</span>,</span><br><span class="line">                  episode_trigger=<span class="keyword">lambda</span> x: x % training_period == <span class="number">0</span>)</span><br><span class="line">env = RecordEpisodeStatistics(env)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> episode_num <span class="keyword">in</span> <span class="built_in">range</span>(num_training_episodes):</span><br><span class="line">    obs, info = env.reset()</span><br><span class="line"></span><br><span class="line">    episode_over = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> episode_over:</span><br><span class="line">        action = env.action_space.sample()  <span class="comment"># replace with actual agent</span></span><br><span class="line">        obs, reward, terminated, truncated, info = env.step(action)</span><br><span class="line"></span><br><span class="line">        episode_over = terminated <span class="keyword">or</span> truncated</span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">f&quot;episode-<span class="subst">&#123;episode_num&#125;</span>&quot;</span>, info[<span class="string">&quot;episode&quot;</span>])</span><br><span class="line">env.close()</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://gymnasium.farama.org/">https://gymnasium.farama.org/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Howard Huang</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">638k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19:19</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动-->
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.js" integrity="sha256-+2+qOqR8CKoHh/AsVR9k2qaDBKWjYNC2nozhYmv5j9k=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
